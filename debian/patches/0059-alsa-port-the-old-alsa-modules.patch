From 8bc034eb4b1318146dd81cd6cd16eaa0a4a3df82 Mon Sep 17 00:00:00 2001
From: Maemo Multimedia <multimedia@maemo.org>
Date: Fri, 17 Apr 2009 17:08:35 +0300
Subject: [PATCH 59/62] alsa: port the old alsa modules

---
 src/Makefile.am                                  |   16 +-
 src/modules/alsa/module-alsa-sink-old-symdef.h   |   27 +
 src/modules/alsa/module-alsa-sink-old.c          | 1013 ++++++++++++++++
 src/modules/alsa/module-alsa-source-old-symdef.h |   27 +
 src/modules/alsa/module-alsa-source-old.c        | 1385 ++++++++++++++++++++++
 5 files changed, 2467 insertions(+), 1 deletions(-)
 create mode 100644 src/modules/alsa/module-alsa-sink-old-symdef.h
 create mode 100644 src/modules/alsa/module-alsa-sink-old.c
 create mode 100644 src/modules/alsa/module-alsa-source-old-symdef.h
 create mode 100644 src/modules/alsa/module-alsa-source-old.c

diff --git a/src/Makefile.am b/src/Makefile.am
index 6d26863..b5c828b 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1005,7 +1005,9 @@ modlibexec_LTLIBRARIES += \
 		libalsa-util.la \
 		module-alsa-sink.la \
 		module-alsa-source.la \
-		module-alsa-card.la
+		module-alsa-card.la \
+		module-alsa-sink-old.la \
+		module-alsa-source-old.la
 endif
 
 if HAVE_SOLARIS
@@ -1116,6 +1118,8 @@ SYMDEF_FILES = \
 		modules/alsa/module-alsa-sink-symdef.h \
 		modules/alsa/module-alsa-source-symdef.h \
 		modules/alsa/module-alsa-card-symdef.h \
+		modules/alsa/module-alsa-sink-old-symdef.h \
+		modules/alsa/module-alsa-source-old-symdef.h \
 		modules/module-solaris-symdef.h \
 		modules/module-waveout-symdef.h \
 		modules/module-detect-symdef.h \
@@ -1355,6 +1359,16 @@ module_alsa_card_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_alsa_card_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
 module_alsa_card_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
 
+module_alsa_sink_old_la_SOURCES = modules/alsa/module-alsa-sink-old.c
+module_alsa_sink_old_la_LDFLAGS = $(MODULE_LDFLAGS)
+module_alsa_sink_old_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
+module_alsa_sink_old_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
+
+module_alsa_source_old_la_SOURCES = modules/alsa/module-alsa-source-old.c
+module_alsa_source_old_la_LDFLAGS = $(MODULE_LDFLAGS)
+module_alsa_source_old_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
+module_alsa_source_old_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
+
 # Solaris
 
 module_solaris_la_SOURCES = modules/module-solaris.c
diff --git a/src/modules/alsa/module-alsa-sink-old-symdef.h b/src/modules/alsa/module-alsa-sink-old-symdef.h
new file mode 100644
index 0000000..0c74afc
--- /dev/null
+++ b/src/modules/alsa/module-alsa-sink-old-symdef.h
@@ -0,0 +1,27 @@
+#ifndef foomodulealsasinkoldsymdeffoo
+#define foomodulealsasinkoldsymdeffoo
+
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/macro.h>
+
+#define pa__init module_alsa_sink_old_LTX_pa__init
+#define pa__done module_alsa_sink_old_LTX_pa__done
+#define pa__get_author module_alsa_sink_old_LTX_pa__get_author
+#define pa__get_description module_alsa_sink_old_LTX_pa__get_description
+#define pa__get_usage module_alsa_sink_old_LTX_pa__get_usage
+#define pa__get_version module_alsa_sink_old_LTX_pa__get_version
+#define pa__load_once module_alsa_sink_old_LTX_pa__load_once
+#define pa__get_n_used module_alsa_sink_old_LTX_pa__get_n_used
+
+int pa__init(pa_module*m);
+void pa__done(pa_module*m);
+int pa__get_n_used(pa_module*m);
+
+const char* pa__get_author(void);
+const char* pa__get_description(void);
+const char* pa__get_usage(void);
+const char* pa__get_version(void);
+pa_bool_t pa__load_once(void);
+
+#endif
diff --git a/src/modules/alsa/module-alsa-sink-old.c b/src/modules/alsa/module-alsa-sink-old.c
new file mode 100644
index 0000000..f6dc0f4
--- /dev/null
+++ b/src/modules/alsa/module-alsa-sink-old.c
@@ -0,0 +1,1013 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright (C) 2008-2009 Nokia Corporation and/or its subsidiary(-ies).
+  Copyright 2004-2006 Lennart Poettering
+  Copyright 2006 Pierre Ossman <ossman@cendio.se> for Cendio AB
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published
+  by the Free Software Foundation; either version 2 of the License,
+  or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with PulseAudio; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+
+#include <asoundlib.h>
+
+#include <pulse/rtclock.h>
+#include <pulse/timeval.h>
+#include <pulse/util.h>
+#include <pulse/xmalloc.h>
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/memchunk.h>
+#include <pulsecore/sink.h>
+#include <pulsecore/modargs.h>
+#include <pulsecore/core-rtclock.h>
+#include <pulsecore/core-util.h>
+#include <pulsecore/sample-util.h>
+#include <pulsecore/log.h>
+#include <pulsecore/macro.h>
+#include <pulsecore/thread.h>
+#include <pulsecore/core-error.h>
+#include <pulsecore/thread-mq.h>
+#include <pulsecore/rtpoll.h>
+#include <pulsecore/atomic.h>
+
+#include "alsa-util.h"
+#include "module-alsa-sink-old-symdef.h"
+
+PA_MODULE_AUTHOR("Lennart Poettering & Maemo Multimedia");
+PA_MODULE_DESCRIPTION("ALSA Sink (modified by Nokia)");
+PA_MODULE_VERSION(PACKAGE_VERSION);
+PA_MODULE_LOAD_ONCE(FALSE);
+PA_MODULE_USAGE(
+        "sink_name=<name for the sink> "
+        "device=<ALSA device> "
+        "device_id=<ALSA device id> "
+        "format=<sample format> "
+        "channels=<number of channels> "
+        "rate=<sample rate> "
+        "fragments=<number of fragments> "
+        "fragment_size=<fragment size> "
+        "alt_fragments=<number of fragments> "
+        "alt_fragment_size=<fragment size> "
+        "channel_map=<channel map> "
+        "mmap=<enable memory mapping?>");
+
+#define DEFAULT_DEVICE "default"
+
+#define SINK_SWITCH_PRIMARY (0)
+#define SINK_SWITCH_ALTERNATIVE (1)
+#define PROP_BUFFERS "x-maemo.alsa_sink.buffers"
+#define PROP_BUFFERS_PRIMARY "primary"
+#define PROP_BUFFERS_ALTERNATIVE "alternative"
+
+struct userdata {
+    pa_core *core;
+    pa_module *module;
+    pa_sink *sink;
+
+    pa_thread *thread;
+    pa_thread_mq thread_mq;
+    pa_rtpoll *rtpoll;
+
+    snd_pcm_t *pcm_handle;
+
+    size_t frame_size, fragment_size, hwbuf_size;
+    snd_pcm_uframes_t period_size;
+    unsigned nfragments;
+    pa_memchunk memchunk;
+
+    size_t pri_frame_size, pri_fragment_size, pri_hwbuf_size;
+    snd_pcm_uframes_t pri_period_size;
+    unsigned pri_nfragments;
+
+    size_t alt_frame_size, alt_fragment_size, alt_hwbuf_size;
+    snd_pcm_uframes_t alt_period_size;
+    unsigned alt_nfragments;
+
+    pa_bool_t switching_enabled;
+    int switch_mode;
+
+    pa_channel_map channel_map;
+
+    pa_hook_slot *sink_proplist_changed_slot;
+
+    char *device_name;
+
+    pa_bool_t use_mmap;
+
+    pa_bool_t first;
+
+    pa_rtpoll_item *alsa_rtpoll_item;
+};
+
+static const char* const valid_modargs[] = {
+    "device",
+    "device_id",
+    "sink_name",
+    "format",
+    "channels",
+    "rate",
+    "fragments",
+    "fragment_size",
+    "alt_fragments",
+    "alt_fragment_size",
+    "channel_map",
+    "mmap",
+    NULL
+};
+
+static void switch_buffers(struct userdata *u, int switch_mode) {
+    unsigned num_inputs = 0;
+
+    pa_assert(u->sink);
+
+    if (!u->switching_enabled) {
+        pa_log_info("switch_buffers() switching disabled by config (no alt_ parameters)");
+        return;
+    }
+    if (switch_mode == u->switch_mode) {
+        pa_log_debug("switch_buffers() same mode as previously");
+        return;
+    }
+    u->switch_mode = switch_mode;
+    num_inputs = pa_sink_used_by(u->sink);
+
+    pa_log_debug("switch_buffers() got %d inputs", num_inputs);
+
+    /* Suspend is dependent on the context where switch_buffers is run.
+     * If using from thread_func, internal suspend() should be used. */
+    if (pa_sink_get_state(u->sink) != PA_SINK_SUSPENDED)
+        pa_sink_suspend(u->sink, TRUE);
+
+    if (u->switch_mode == SINK_SWITCH_PRIMARY) {
+        pa_log_info("switch to primary buffer");
+        u->frame_size = u->pri_frame_size;
+        u->fragment_size = u->pri_fragment_size;
+        u->hwbuf_size = u->pri_hwbuf_size;
+        u->nfragments = u->pri_nfragments;
+        u->period_size = u->pri_period_size;
+    } else {
+        pa_log_info("switch to alternate buffer");
+        u->frame_size = u->alt_frame_size;
+        u->fragment_size = u->alt_fragment_size;
+        u->hwbuf_size = u->alt_hwbuf_size;
+        u->nfragments = u->alt_nfragments;
+        u->period_size = u->alt_period_size;
+    }
+
+    if (num_inputs > 0)
+        pa_sink_suspend(u->sink, FALSE);
+
+    /* update buffer metrics */
+    pa_proplist_setf(u->sink->proplist,
+                     PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE,
+                     "%lu", (unsigned long) (u->period_size * u->frame_size * u->nfragments));
+    pa_proplist_setf(u->sink->proplist,
+                     PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE,
+                     "%lu", (unsigned long) (u->period_size * u->frame_size));
+}
+
+static int mmap_write(struct userdata *u) {
+    int work_done = 0;
+
+    pa_assert(u);
+    pa_sink_assert_ref(u->sink);
+
+    for (;;) {
+        pa_memchunk chunk;
+        void *p;
+        snd_pcm_sframes_t n;
+        int err;
+        const snd_pcm_channel_area_t *areas;
+        snd_pcm_uframes_t offset, frames;
+
+        if ((n = snd_pcm_avail_update(u->pcm_handle)) < 0) {
+
+            if (n == -EPIPE) {
+                pa_log_debug("snd_pcm_avail_update: Buffer underrun!");
+                u->first = TRUE;
+            }
+
+            if ((err = snd_pcm_recover(u->pcm_handle, n, 1)) == 0)
+                continue;
+
+            if (err == -EAGAIN)
+                return work_done;
+
+            pa_log("snd_pcm_avail_update: %s", snd_strerror(err));
+            return -1;
+        }
+
+        /*         pa_log("Got request for %i samples", (int) n); */
+
+        frames = n - (n % u->period_size);
+
+        if (frames <= 0)
+            return work_done;
+
+        if ((err = snd_pcm_mmap_begin(u->pcm_handle, &areas, &offset, &frames)) < 0) {
+
+            if (err == -EPIPE) {
+                pa_log_debug("snd_pcm_mmap_begin: Buffer underrun!");
+                u->first = TRUE;
+            }
+
+            if ((err = snd_pcm_recover(u->pcm_handle, err, 1)) == 0)
+                continue;
+
+            if (err == -EAGAIN)
+                return work_done;
+
+            pa_log("Failed to write data to DSP: %s", snd_strerror(err));
+            return -1;
+        }
+
+        /* Check these are multiples of 8 bit */
+        pa_assert((areas[0].first & 7) == 0);
+        pa_assert((areas[0].step & 7)== 0);
+
+        /* We assume a single interleaved memory buffer */
+        pa_assert((areas[0].first >> 3) == 0);
+        pa_assert((areas[0].step >> 3) == u->frame_size);
+
+        p = (uint8_t*) areas[0].addr + (offset * u->frame_size);
+
+        chunk.memblock = pa_memblock_new_fixed(u->core->mempool, p, frames * u->frame_size, 1);
+        chunk.length = pa_memblock_get_length(chunk.memblock);
+        chunk.index = 0;
+
+        pa_sink_render_into_full(u->sink, &chunk);
+
+        /* FIXME: Maybe we can do something to keep this memory block
+         * a little bit longer around? */
+        pa_memblock_unref_fixed(chunk.memblock);
+
+        if ((err = snd_pcm_mmap_commit(u->pcm_handle, offset, frames)) < 0) {
+
+            if (err == -EPIPE) {
+                pa_log_debug("snd_pcm_mmap_commit: Buffer underrun!");
+                u->first = TRUE;
+            }
+
+            if ((err = snd_pcm_recover(u->pcm_handle, err, 1)) == 0)
+                continue;
+
+            if (err == -EAGAIN)
+                return work_done;
+
+            pa_log("Failed to write data to DSP: %s", snd_strerror(err));
+            return -1;
+        }
+
+        work_done = 1;
+
+        if (frames >= (snd_pcm_uframes_t) n)
+            return work_done;
+
+        /*         pa_log("wrote %i samples", (int) frames); */
+    }
+}
+
+static int unix_write(struct userdata *u) {
+    snd_pcm_status_t *status;
+    int work_done = 0;
+
+    snd_pcm_status_alloca(&status);
+
+    pa_assert(u);
+    pa_sink_assert_ref(u->sink);
+
+    for (;;) {
+        void *p;
+        snd_pcm_sframes_t t;
+        ssize_t l;
+        int err;
+
+        if ((err = snd_pcm_status(u->pcm_handle, status)) < 0) {
+            pa_log("Failed to query DSP status data: %s", snd_strerror(err));
+            return -1;
+        }
+
+        if (snd_pcm_status_get_avail_max(status)*u->frame_size >= u->hwbuf_size)
+            pa_log_debug("Buffer underrun!");
+
+        l = snd_pcm_status_get_avail(status) * u->frame_size;
+
+        /*         pa_log("%u bytes to write", l); */
+
+        l = l - (l % u->fragment_size);
+
+        if (l <= 0)
+            return work_done;
+
+        if (u->memchunk.length <= 0)
+            pa_sink_render(u->sink, l, &u->memchunk);
+
+        pa_assert(u->memchunk.length > 0);
+
+        p = pa_memblock_acquire(u->memchunk.memblock);
+        t = snd_pcm_writei(u->pcm_handle, (const uint8_t*) p + u->memchunk.index, u->memchunk.length / u->frame_size);
+        pa_memblock_release(u->memchunk.memblock);
+
+        /*         pa_log("wrote %i bytes of %u (%u)", t*u->frame_size, u->memchunk.length, l); */
+
+        pa_assert(t != 0);
+
+        if (t < 0) {
+
+            if ((t = snd_pcm_recover(u->pcm_handle, t, 1)) == 0)
+                continue;
+
+            if (t == -EAGAIN) {
+                pa_log_debug("EAGAIN");
+                return work_done;
+            } else {
+                pa_log("Failed to write data to DSP: %s", snd_strerror(t));
+                return -1;
+            }
+        }
+
+        u->memchunk.index += t * u->frame_size;
+        u->memchunk.length -= t * u->frame_size;
+
+        if (u->memchunk.length <= 0) {
+            pa_memblock_unref(u->memchunk.memblock);
+            pa_memchunk_reset(&u->memchunk);
+        }
+
+        work_done = 1;
+
+        if (t * u->frame_size >= (unsigned) l)
+            return work_done;
+    }
+}
+
+static int sink_get_latency_by_timestamps(struct userdata *u, pa_usec_t *d) {
+    snd_pcm_uframes_t avail;
+    snd_htimestamp_t tstamp;
+    struct timespec ts_dma;
+    pa_usec_t buffered, elapsed;
+
+    if (snd_pcm_htimestamp(u->pcm_handle, &avail, &tstamp) < 0)
+        return -1;
+
+    ts_dma.tv_sec = tstamp.tv_sec;
+    ts_dma.tv_nsec = tstamp.tv_nsec;
+
+    buffered = pa_bytes_to_usec(u->hwbuf_size - avail * u->frame_size, &u->sink->sample_spec);
+    elapsed = pa_rtclock_now() - pa_timespec_load(&ts_dma);
+
+    *d = buffered - elapsed;
+
+    return 0;
+}
+
+static pa_usec_t sink_get_latency(struct userdata *u) {
+    pa_usec_t r = 0;
+    snd_pcm_status_t *status;
+    snd_pcm_sframes_t frames = 0;
+    int err;
+
+    snd_pcm_status_alloca(&status);
+
+    pa_assert(u);
+    pa_assert(u->pcm_handle);
+
+    if (sink_get_latency_by_timestamps(u, &r) < 0) {
+        if ((err = snd_pcm_status(u->pcm_handle, status)) < 0)
+            pa_log("Failed to get delay: %s", snd_strerror(err));
+        else
+            frames = snd_pcm_status_get_delay(status);
+
+        if (frames > 0)
+            r = pa_bytes_to_usec(frames * u->frame_size, &u->sink->sample_spec);
+    }
+
+    if (u->memchunk.memblock)
+        r += pa_bytes_to_usec(u->memchunk.length, &u->sink->sample_spec);
+
+    return r;
+}
+
+static int build_pollfd(struct userdata *u) {
+    int err;
+    struct pollfd *pollfd;
+    int n;
+
+    pa_assert(u);
+    pa_assert(u->pcm_handle);
+
+    if ((n = snd_pcm_poll_descriptors_count(u->pcm_handle)) < 0) {
+        pa_log("snd_pcm_poll_descriptors_count() failed: %s", snd_strerror(n));
+        return -1;
+    }
+
+    if (u->alsa_rtpoll_item)
+        pa_rtpoll_item_free(u->alsa_rtpoll_item);
+
+    u->alsa_rtpoll_item = pa_rtpoll_item_new(u->rtpoll, PA_RTPOLL_NEVER, n);
+    pollfd = pa_rtpoll_item_get_pollfd(u->alsa_rtpoll_item, NULL);
+
+    if ((err = snd_pcm_poll_descriptors(u->pcm_handle, pollfd, n)) < 0) {
+        pa_log("snd_pcm_poll_descriptors() failed: %s", snd_strerror(err));
+        return -1;
+    }
+
+    return 0;
+}
+
+static int suspend(struct userdata *u) {
+    pa_assert(u);
+    pa_assert(u->pcm_handle);
+
+    /* Let's suspend */
+    if (!pa_streq(u->device_name, "sink.hw1")) /* FIXME: maemo hw1 has issues draining, it takes too long */
+        snd_pcm_drain(u->pcm_handle);
+    snd_pcm_close(u->pcm_handle);
+    u->pcm_handle = NULL;
+
+    if (u->alsa_rtpoll_item) {
+        pa_rtpoll_item_free(u->alsa_rtpoll_item);
+        u->alsa_rtpoll_item = NULL;
+    }
+
+    pa_log_info("Device suspended...");
+
+    return 0;
+}
+
+static int unsuspend(struct userdata *u) {
+    pa_sample_spec ss;
+    int err;
+    pa_bool_t b, d;
+    unsigned nfrags;
+
+    pa_assert(u);
+    pa_assert(!u->pcm_handle);
+
+    pa_log_info("Trying resume...");
+
+    snd_config_update_free_global();
+    if ((err = snd_pcm_open(&u->pcm_handle, u->device_name, SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK)) < 0) {
+        pa_log("Error opening PCM device %s: %s", u->device_name, snd_strerror(err));
+        goto fail;
+    }
+
+    ss = u->sink->sample_spec;
+    nfrags = u->nfragments;
+    b = u->use_mmap;
+    d = FALSE;
+
+    if ((err = pa_alsa_set_hw_params(u->pcm_handle, &ss, &nfrags, &u->period_size, u->hwbuf_size / u->frame_size, &b, &d, TRUE)) < 0) {
+        pa_log("Failed to set hardware parameters: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if (b != u->use_mmap) {
+        pa_log_warn("Resume failed, couldn't get original access mode.");
+        goto fail;
+    }
+
+    if (!pa_sample_spec_equal(&ss, &u->sink->sample_spec)) {
+        pa_log_warn("Resume failed, couldn't restore original sample settings.");
+        goto fail;
+    }
+
+    if (nfrags != u->nfragments || u->period_size*u->frame_size != u->fragment_size) {
+        pa_log_warn("Resume failed, couldn't restore original fragment settings.");
+        goto fail;
+    }
+
+    if ((err = pa_alsa_set_sw_params(u->pcm_handle, u->period_size)) < 0) {
+        pa_log("Failed to set software parameters: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if (build_pollfd(u) < 0)
+        goto fail;
+
+    /* FIXME: We need to reload the volume somehow */
+
+    u->first = TRUE;
+
+    pa_log_info("Resumed successfully...");
+
+    return 0;
+
+ fail:
+    if (u->pcm_handle) {
+        snd_pcm_close(u->pcm_handle);
+        u->pcm_handle = NULL;
+    }
+
+    return -1;
+}
+
+static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offset, pa_memchunk *chunk) {
+    struct userdata *u = PA_SINK(o)->userdata;
+
+    switch (code) {
+
+        case PA_SINK_MESSAGE_GET_LATENCY: {
+            pa_usec_t r = 0;
+
+            if (u->pcm_handle)
+                r = sink_get_latency(u);
+
+            *((pa_usec_t*) data) = r;
+
+            return 0;
+        }
+
+        case PA_SINK_MESSAGE_SET_STATE:
+
+            switch ((pa_sink_state_t) PA_PTR_TO_UINT(data)) {
+
+                case PA_SINK_SUSPENDED:
+                    pa_assert(PA_SINK_IS_OPENED(u->sink->thread_info.state));
+
+                    if (suspend(u) < 0)
+                        return -1;
+
+                    break;
+
+                case PA_SINK_IDLE:
+                case PA_SINK_RUNNING:
+
+                    if (u->sink->thread_info.state == PA_SINK_INIT) {
+                        if (build_pollfd(u) < 0)
+                            return -1;
+                    }
+
+                    if (u->sink->thread_info.state == PA_SINK_SUSPENDED) {
+                        if (unsuspend(u) < 0)
+                            return -1;
+                    }
+
+                    break;
+
+                case PA_SINK_UNLINKED:
+                case PA_SINK_INIT:
+                    break;
+                case PA_SINK_INVALID_STATE:
+                    pa_log_error("invalid state");
+                    break;
+            }
+
+            break;
+
+        case PA_SINK_MESSAGE_ADD_INPUT:
+            break;
+        case PA_SINK_MESSAGE_REMOVE_INPUT:
+            break;
+
+        default:
+            break;
+    }
+
+    return pa_sink_process_msg(o, code, data, offset, chunk);
+}
+
+static void thread_func(void *userdata) {
+    struct userdata *u = userdata;
+
+    pa_assert(u);
+
+    pa_log_debug("Thread starting up");
+
+    if (u->core->realtime_scheduling)
+        pa_make_realtime(u->core->realtime_priority);
+
+    pa_thread_mq_install(&u->thread_mq);
+    pa_rtpoll_install(u->rtpoll);
+
+    for (;;) {
+        int ret;
+
+        /* Render some data and write it to the dsp */
+        if (PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
+            int work_done = 0;
+
+            if (u->sink->thread_info.rewind_requested)
+                pa_sink_process_rewind(u->sink, 0);
+
+            if (u->use_mmap) {
+                if ((work_done = mmap_write(u)) < 0)
+                    goto fail;
+            } else {
+                if ((work_done = unix_write(u)) < 0)
+                    goto fail;
+            }
+
+            if (work_done && u->first) {
+                pa_log_info("Starting playback.");
+                snd_pcm_start(u->pcm_handle);
+                u->first = FALSE;
+                continue;
+            }
+        }
+
+        /* Hmm, nothing to do. Let's sleep */
+        if ((ret = pa_rtpoll_run(u->rtpoll, 1)) < 0)
+            goto fail;
+
+        if (ret == 0)
+            goto finish;
+
+        /* Tell ALSA about this and process its response */
+        if (PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
+            struct pollfd *pollfd;
+            unsigned short revents = 0;
+            int err;
+            unsigned n;
+
+            pollfd = pa_rtpoll_item_get_pollfd(u->alsa_rtpoll_item, &n);
+
+            if ((err = snd_pcm_poll_descriptors_revents(u->pcm_handle, pollfd, n, &revents)) < 0) {
+                pa_log("snd_pcm_poll_descriptors_revents() failed: %s", snd_strerror(err));
+                goto fail;
+            }
+
+            if (revents & (POLLERR|POLLNVAL|POLLHUP)) {
+
+                if (revents & POLLERR)
+                    pa_log_warn("Got POLLERR from ALSA");
+                if (revents & POLLNVAL)
+                    pa_log_warn("Got POLLNVAL from ALSA");
+                if (revents & POLLHUP)
+                    pa_log_warn("Got POLLHUP from ALSA");
+
+                /* Try to recover from this error */
+
+                switch (snd_pcm_state(u->pcm_handle)) {
+
+                    case SND_PCM_STATE_XRUN:
+                        if ((err = snd_pcm_recover(u->pcm_handle, -EPIPE, 1)) != 0) {
+                            pa_log_warn("Could not recover from POLLERR|POLLNVAL|POLLHUP and XRUN: %s", snd_strerror(err));
+                            goto fail;
+                        }
+                        break;
+
+                    case SND_PCM_STATE_SUSPENDED:
+                        if ((err = snd_pcm_recover(u->pcm_handle, -ESTRPIPE, 1)) != 0) {
+                            pa_log_warn("Could not recover from POLLERR|POLLNVAL|POLLHUP and SUSPENDED: %s", snd_strerror(err));
+                            goto fail;
+                        }
+                        break;
+
+                    default:
+
+                        snd_pcm_drop(u->pcm_handle);
+
+                        if ((err = snd_pcm_prepare(u->pcm_handle)) < 0) {
+                            pa_log_warn("Could not recover from POLLERR|POLLNVAL|POLLHUP with snd_pcm_prepare(): %s", snd_strerror(err));
+                            goto fail;
+                        }
+                        break;
+                }
+            }
+        }
+    }
+
+ fail:
+    /* If this was no regular exit from the loop we have to continue
+     * processing messages until we received PA_MESSAGE_SHUTDOWN */
+    pa_asyncmsgq_post(u->thread_mq.outq, PA_MSGOBJECT(u->core), PA_CORE_MESSAGE_UNLOAD_MODULE, u->module, 0, NULL, NULL);
+    pa_asyncmsgq_wait_for(u->thread_mq.inq, PA_MESSAGE_SHUTDOWN);
+
+ finish:
+    pa_log_debug("Thread shutting down");
+}
+
+static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
+    const char *v = NULL;
+
+    if (s != u->sink) {
+        return PA_HOOK_OK;
+    }
+
+    pa_log_debug("%s: sink_proplist_changed_hook_callback", u->device_name);
+
+    pa_assert(u);
+    pa_assert(s);
+
+    v = pa_proplist_gets(s->proplist, PROP_BUFFERS);
+    if (v) {
+        if (pa_startswith(v, PROP_BUFFERS_PRIMARY)) {
+            switch_buffers(u, SINK_SWITCH_PRIMARY);
+        }
+        else if (pa_startswith(v, PROP_BUFFERS_ALTERNATIVE)) {
+            switch_buffers(u, SINK_SWITCH_ALTERNATIVE);
+        }
+    }
+
+    return PA_HOOK_OK;
+}
+
+int pa__init(pa_module*m) {
+
+    pa_modargs *ma = NULL;
+    struct userdata *u = NULL;
+    const char *dev_id;
+    pa_sample_spec ss;
+    pa_channel_map map;
+    uint32_t nfrags, frag_size;
+    uint32_t alt_nfrags, alt_frag_size;
+    snd_pcm_uframes_t period_size;
+    snd_pcm_uframes_t alt_period_size;
+    size_t frame_size;
+    size_t alt_frame_size;
+    snd_pcm_info_t *pcm_info = NULL;
+    int err;
+    char *t;
+    const char *name;
+    char *name_buf = NULL;
+    int namereg_fail;
+    pa_bool_t use_mmap = TRUE, b, d;
+    pa_sink_new_data data;
+    const pa_alsa_profile_info *profile;
+
+    snd_pcm_info_alloca(&pcm_info);
+
+    pa_assert(m);
+
+    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+        pa_log("Failed to parse module arguments");
+        goto fail;
+    }
+
+    ss = m->core->default_sample_spec;
+    if (pa_modargs_get_sample_spec_and_channel_map(ma, &ss, &map, PA_CHANNEL_MAP_ALSA) < 0) {
+        pa_log("Failed to parse sample specification and channel map");
+        goto fail;
+    }
+
+    frame_size = pa_frame_size(&ss);
+
+    nfrags = m->core->default_n_fragments;
+    frag_size = pa_usec_to_bytes(m->core->default_fragment_size_msec*1000, &ss);
+    if (frag_size <= 0)
+        frag_size = frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "fragments", &nfrags) < 0 || pa_modargs_get_value_u32(ma, "fragment_size", &frag_size) < 0) {
+        pa_log("Failed to parse buffer metrics");
+        goto fail;
+    }
+    period_size = frag_size/frame_size;
+
+    alt_frame_size = pa_frame_size(&ss);
+
+    /* 0 is default value from pa_modargs_get */
+    alt_period_size = 0;
+    alt_nfrags = 0;
+    alt_frag_size = alt_frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "alt_fragments", &alt_nfrags) < 0 || pa_modargs_get_value_u32(ma, "alt_fragment_size", &alt_frag_size) < 0) {
+        pa_log("Failed to parse alt buffer metrics");
+        goto fail;
+    }
+
+    if (alt_nfrags != 0) {
+        alt_period_size = alt_frag_size/alt_frame_size;
+    }
+
+    if (pa_modargs_get_value_boolean(ma, "mmap", &use_mmap) < 0) {
+        pa_log("Failed to parse mmap argument.");
+        goto fail;
+    }
+
+    u = pa_xnew0(struct userdata, 1);
+    u->switch_mode = SINK_SWITCH_PRIMARY;
+    if (alt_nfrags != 0)
+        u->switching_enabled = TRUE;
+    else
+        u->switching_enabled = FALSE;
+    u->core = m->core;
+    u->module = m;
+    m->userdata = u;
+    u->use_mmap = use_mmap;
+    u->first = TRUE;
+    u->rtpoll = pa_rtpoll_new();
+    pa_thread_mq_init(&u->thread_mq, m->core->mainloop, u->rtpoll);
+    u->alsa_rtpoll_item = NULL;
+
+    snd_config_update_free_global();
+
+    b = use_mmap;
+    d = FALSE; /* use_tsched */
+    profile = NULL; /* no profile specified */
+
+    if ((dev_id = pa_modargs_get_value(ma, "device_id", NULL))) {
+
+        if (!(u->pcm_handle = pa_alsa_open_by_device_id_auto(
+                      dev_id,
+                      &u->device_name,
+                      &ss, &map,
+                      SND_PCM_STREAM_PLAYBACK,
+                      &nfrags, &period_size, period_size * nfrags,
+                      &b, &d, &profile)))
+
+            goto fail;
+
+    } else {
+
+        if (!(u->pcm_handle = pa_alsa_open_by_device_string(
+                      pa_modargs_get_value(ma, "device", DEFAULT_DEVICE),
+                      &u->device_name,
+                      &ss, &map,
+                      SND_PCM_STREAM_PLAYBACK,
+                      &nfrags, &period_size, period_size * nfrags,
+                      &b, &d, FALSE)))
+            goto fail;
+
+    }
+
+    pa_assert(u->device_name);
+    pa_log_info("Successfully opened device %s.", u->device_name);
+
+    if (use_mmap && !b) {
+        pa_log_info("Device doesn't support mmap(), falling back to UNIX read/write mode.");
+        u->use_mmap = use_mmap = b;
+    }
+
+    if (u->use_mmap)
+        pa_log_info("Successfully enabled mmap() mode.");
+
+    if ((err = snd_pcm_info(u->pcm_handle, pcm_info)) < 0) {
+        pa_log("Error fetching PCM info: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if ((err = pa_alsa_set_sw_params(u->pcm_handle, period_size)) < 0) {
+        pa_log("Failed to set software parameters: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    /* ALSA might tweak the sample spec, so recalculate the frame size */
+    frame_size = pa_frame_size(&ss);
+    alt_frame_size = pa_frame_size(&ss);
+
+    if ((name = pa_modargs_get_value(ma, "sink_name", NULL)))
+        namereg_fail = 1;
+    else {
+        name = name_buf = pa_sprintf_malloc("alsa_output.%s", u->device_name);
+        namereg_fail = 0;
+    }
+
+    pa_sink_new_data_init(&data);
+    data.driver = __FILE__;
+    data.module = m;
+    pa_sink_new_data_set_name(&data, name);
+    data.namereg_fail = namereg_fail;
+    pa_sink_new_data_set_sample_spec(&data, &ss);
+    pa_sink_new_data_set_channel_map(&data, &map);
+
+    pa_alsa_init_proplist_pcm(m->core, data.proplist, u->pcm_handle, NULL);
+    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_STRING, u->device_name);
+    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE, "%lu", (unsigned long) (period_size * frame_size * nfrags));
+    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE, "%lu", (unsigned long) (period_size * frame_size));
+    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_ACCESS_MODE, (u->use_mmap ? "mmap" : "serial"));
+
+    u->sink = pa_sink_new(m->core, &data, PA_SINK_HARDWARE|PA_SINK_LATENCY);
+    pa_sink_new_data_done(&data);
+    pa_xfree(name_buf);
+
+    if (!u->sink) {
+        pa_log("Failed to create sink object");
+        goto fail;
+    }
+
+    u->sink->parent.process_msg = sink_process_msg;
+    u->sink->update_requested_latency = NULL;
+    u->sink->userdata = u;
+
+    pa_sink_set_asyncmsgq(u->sink, u->thread_mq.inq);
+    pa_sink_set_rtpoll(u->sink, u->rtpoll);
+    pa_sink_set_description(u->sink, t = pa_sprintf_malloc(
+                                    "ALSA PCM on %s (%s)%s",
+                                    u->device_name,
+                                    snd_pcm_info_get_name(pcm_info),
+                                    use_mmap ? " via DMA" : ""));
+    pa_xfree(t);
+
+    u->frame_size = frame_size;
+    u->fragment_size = frag_size = period_size * frame_size;
+    u->nfragments = nfrags;
+    u->hwbuf_size = u->fragment_size * nfrags;
+    u->period_size = period_size;
+
+    if (u->switching_enabled) {
+        u->pri_frame_size = frame_size;
+        u->pri_fragment_size = frag_size = period_size * frame_size;
+        u->pri_nfragments = nfrags;
+        u->pri_hwbuf_size = u->fragment_size * nfrags;
+        u->pri_period_size = period_size;
+
+        u->alt_frame_size = alt_frame_size;
+        u->alt_fragment_size = alt_frag_size = alt_period_size * alt_frame_size;
+        u->alt_nfragments = alt_nfrags;
+        u->alt_hwbuf_size = u->alt_fragment_size * alt_nfrags;
+        u->alt_period_size = alt_period_size;
+    }
+
+
+    pa_log_info("PRI: Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->fragment_size);
+    if (u->switching_enabled)
+        pa_log_info("ALT: Using %u fragments of size %lu bytes.", alt_nfrags, (long unsigned) u->alt_fragment_size);
+
+    pa_memchunk_reset(&u->memchunk);
+
+    u->channel_map = map;
+    if (!(u->thread = pa_thread_new(thread_func, u))) {
+        pa_log("Failed to create thread.");
+        goto fail;
+    }
+
+    pa_proplist_sets(u->sink->proplist, PROP_BUFFERS, PROP_BUFFERS_PRIMARY);
+    if (u->switching_enabled)
+        u->sink_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_PROPLIST_CHANGED],
+                                                        PA_HOOK_LATE,
+                                                        (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
+
+    pa_sink_put(u->sink);
+
+    pa_modargs_free(ma);
+
+    return 0;
+
+ fail:
+
+    if (ma)
+        pa_modargs_free(ma);
+
+    pa__done(m);
+
+    return -1;
+}
+
+void pa__done(pa_module*m) {
+    struct userdata *u;
+
+    pa_assert(m);
+
+    if (!(u = m->userdata))
+        return;
+
+    if (u->sink_proplist_changed_slot)
+        pa_hook_slot_free(u->sink_proplist_changed_slot);
+
+    if (u->sink)
+        pa_sink_unlink(u->sink);
+
+    if (u->thread) {
+        pa_asyncmsgq_send(u->thread_mq.inq, NULL, PA_MESSAGE_SHUTDOWN, NULL, 0, NULL);
+        pa_thread_free(u->thread);
+    }
+
+    pa_thread_mq_done(&u->thread_mq);
+
+    if (u->sink)
+        pa_sink_unref(u->sink);
+
+    if (u->memchunk.memblock)
+        pa_memblock_unref(u->memchunk.memblock);
+
+    if (u->alsa_rtpoll_item)
+        pa_rtpoll_item_free(u->alsa_rtpoll_item);
+
+    if (u->rtpoll)
+        pa_rtpoll_free(u->rtpoll);
+
+    if (u->pcm_handle) {
+        snd_pcm_drop(u->pcm_handle);
+        snd_pcm_close(u->pcm_handle);
+    }
+
+    pa_xfree(u->device_name);
+    pa_xfree(u);
+
+    snd_config_update_free_global();
+}
diff --git a/src/modules/alsa/module-alsa-source-old-symdef.h b/src/modules/alsa/module-alsa-source-old-symdef.h
new file mode 100644
index 0000000..033edd6
--- /dev/null
+++ b/src/modules/alsa/module-alsa-source-old-symdef.h
@@ -0,0 +1,27 @@
+#ifndef foomodulealsasourceoldsymdeffoo
+#define foomodulealsasourceoldsymdeffoo
+
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/macro.h>
+
+#define pa__init module_alsa_source_old_LTX_pa__init
+#define pa__done module_alsa_source_old_LTX_pa__done
+#define pa__get_author module_alsa_source_old_LTX_pa__get_author
+#define pa__get_description module_alsa_source_old_LTX_pa__get_description
+#define pa__get_usage module_alsa_source_old_LTX_pa__get_usage
+#define pa__get_version module_alsa_source_old_LTX_pa__get_version
+#define pa__load_once module_alsa_source_old_LTX_pa__load_once
+#define pa__get_n_used module_alsa_source_old_LTX_pa__get_n_used
+
+int pa__init(pa_module*m);
+void pa__done(pa_module*m);
+int pa__get_n_used(pa_module*m);
+
+const char* pa__get_author(void);
+const char* pa__get_description(void);
+const char* pa__get_usage(void);
+const char* pa__get_version(void);
+pa_bool_t pa__load_once(void);
+
+#endif
diff --git a/src/modules/alsa/module-alsa-source-old.c b/src/modules/alsa/module-alsa-source-old.c
new file mode 100644
index 0000000..4b229d7
--- /dev/null
+++ b/src/modules/alsa/module-alsa-source-old.c
@@ -0,0 +1,1385 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright (C) 2008-2009 Nokia Corporation and/or its subsidiary(-ies).
+  Copyright 2004-2006 Lennart Poettering
+  Copyright 2006 Pierre Ossman <ossman@cendio.se> for Cendio AB
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published
+  by the Free Software Foundation; either version 2 of the License,
+  or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with PulseAudio; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+
+#include <asoundlib.h>
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
+#include <pulse/rtclock.h>
+#include <pulse/timeval.h>
+#include <pulse/util.h>
+#include <pulse/xmalloc.h>
+
+#include <pulsecore/core-error.h>
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/memchunk.h>
+#include <pulsecore/source.h>
+#include <pulsecore/modargs.h>
+#include <pulsecore/core-rtclock.h>
+#include <pulsecore/core-util.h>
+#include <pulsecore/sample-util.h>
+#include <pulsecore/log.h>
+#include <pulsecore/macro.h>
+#include <pulsecore/thread.h>
+#include <pulsecore/core-error.h>
+#include <pulsecore/thread-mq.h>
+#include <pulsecore/rtpoll.h>
+
+#include "alsa-util.h"
+#include "module-alsa-source-old-symdef.h"
+
+PA_MODULE_AUTHOR("Lennart Poettering & Maemo Multimedia");
+PA_MODULE_DESCRIPTION("ALSA Source (modified by Nokia)");
+PA_MODULE_VERSION(PACKAGE_VERSION);
+PA_MODULE_LOAD_ONCE(FALSE);
+PA_MODULE_USAGE(
+        "source_name=<name for the source> "
+        "device=<ALSA device> "
+        "device_id=<ALSA device id> "
+        "format=<sample format> "
+        "channels=<number of channels> "
+        "rate=<sample rate> "
+        "mixer=<initial ALSA mixer> "
+        "fragments=<number of fragments> "
+        "fragment_size=<fragment size> "
+        "alt_fragments=<number of fragments> "
+        "alt_fragment_size=<fragment size> "
+        "channel_map=<channel map> "
+        "mmap=<enable memory mapping?>");
+
+#define DEFAULT_DEVICE "default"
+
+#define SOURCE_SWITCH_PRIMARY (0)
+#define SOURCE_SWITCH_ALTERNATIVE (1)
+#define PROP_BUFFERS "x-maemo.alsa_source.buffers"
+#define PROP_BUFFERS_PRIMARY "primary"
+#define PROP_BUFFERS_ALTERNATIVE "alternative"
+
+struct userdata {
+    pa_core *core;
+    pa_module *module;
+    pa_source *source;
+
+    pa_thread *thread;
+    pa_thread_mq thread_mq;
+    pa_rtpoll *rtpoll;
+
+    snd_pcm_t *pcm_handle;
+
+    pa_alsa_fdlist *mixer_fdl;
+    snd_mixer_t *mixer_handle;
+    snd_mixer_elem_t *mixer_elem;
+    long hw_volume_max, hw_volume_min;
+    long hw_dB_max, hw_dB_min;
+    pa_bool_t hw_dB_supported;
+    pa_bool_t mixer_seperate_channels;
+
+    pa_cvolume hardware_volume;
+
+    size_t frame_size, fragment_size, hwbuf_size;
+    snd_pcm_uframes_t period_size;
+    unsigned nfragments;
+
+    size_t pri_frame_size, pri_fragment_size, pri_hwbuf_size;
+    snd_pcm_uframes_t pri_period_size;
+    unsigned pri_nfragments;
+
+    size_t alt_frame_size, alt_fragment_size, alt_hwbuf_size;
+    snd_pcm_uframes_t alt_period_size;
+    unsigned alt_nfragments;
+
+    pa_bool_t switching_enabled;
+    int switch_mode;
+
+    pa_hook_slot *source_proplist_changed_slot;
+    char *mixer_name;
+    char *device_name;
+
+    pa_bool_t use_mmap;
+
+    pa_rtpoll_item *alsa_rtpoll_item;
+
+    snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
+};
+
+static const char* const valid_modargs[] = {
+    "device",
+    "device_id",
+    "source_name",
+    "channels",
+    "rate",
+    "mixer",
+    "format",
+    "fragments",
+    "fragment_size",
+    "alt_fragments",
+    "alt_fragment_size",
+    "channel_map",
+    "mmap",
+    NULL
+};
+
+
+static void switch_buffers(struct userdata *u, int switch_mode) {
+    unsigned num_outputs = 0;
+
+    pa_assert(u->source);
+
+    if (!u->switching_enabled) {
+        pa_log_info("switch_buffers() switching disabled by config (no alt_ parameters)");
+        return;
+    }
+    if (switch_mode == u->switch_mode) {
+        pa_log_debug("switch_buffers() same mode as previously");
+        return;
+    }
+    u->switch_mode = switch_mode;
+    num_outputs = pa_source_used_by(u->source);
+
+    pa_log_debug("switch_buffers() got %d outputs", num_outputs);
+
+    /* Suspend is dependent on the context where switch_buffers is run.
+     * If using from thread_func, internal suspend() should be used. */
+    if (pa_source_get_state(u->source) != PA_SOURCE_SUSPENDED)
+        pa_source_suspend(u->source, TRUE);
+
+    if (u->switch_mode == SOURCE_SWITCH_PRIMARY) {
+        pa_log_info("switch to primary buffer");
+        u->frame_size = u->pri_frame_size;
+        u->fragment_size = u->pri_fragment_size;
+        u->hwbuf_size = u->pri_hwbuf_size;
+        u->nfragments = u->pri_nfragments;
+        u->period_size = u->pri_period_size;
+    } else {
+        pa_log_info("switch to alternate buffer");
+        u->frame_size = u->alt_frame_size;
+        u->fragment_size = u->alt_fragment_size;
+        u->hwbuf_size = u->alt_hwbuf_size;
+        u->nfragments = u->alt_nfragments;
+        u->period_size = u->alt_period_size;
+    }
+
+    if (num_outputs > 0)
+        pa_source_suspend(u->source, FALSE);
+
+    pa_proplist_setf(u->source->proplist,
+                     PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE,
+                     "%lu", (unsigned long) (u->period_size * u->frame_size * u->nfragments));
+    pa_proplist_setf(u->source->proplist,
+                     PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE,
+                     "%lu", (unsigned long) (u->period_size * u->frame_size));
+}
+
+static int mmap_read(struct userdata *u) {
+    int work_done = 0;
+
+    pa_assert(u);
+    pa_source_assert_ref(u->source);
+
+    for (;;) {
+        snd_pcm_sframes_t n;
+        int err;
+        const snd_pcm_channel_area_t *areas;
+        snd_pcm_uframes_t offset, frames;
+        pa_memchunk chunk;
+        void *p;
+
+        if ((n = snd_pcm_avail_update(u->pcm_handle)) < 0) {
+
+            if (n == -EPIPE)
+                pa_log_debug("snd_pcm_avail_update: Buffer underrun!");
+
+            if ((err = snd_pcm_recover(u->pcm_handle, n, 1)) == 0)
+                continue;
+
+            if (err == -EAGAIN)
+                return work_done;
+
+            pa_log("snd_pcm_avail_update: %s", snd_strerror(err));
+            return -1;
+        }
+
+/*         pa_log("Got request for %i samples", (int) n); */
+
+        frames = n - (n % u->period_size);
+
+        if (frames <= 0)
+            return work_done;
+
+        if ((err = snd_pcm_mmap_begin(u->pcm_handle, &areas, &offset, &frames)) < 0) {
+
+            if (err == -EPIPE)
+                pa_log_debug("snd_pcm_mmap_begin: Buffer underrun!");
+
+            if ((err = snd_pcm_recover(u->pcm_handle, err, 1)) == 0)
+                continue;
+
+            if (err == -EAGAIN)
+                return work_done;
+
+            pa_log("Failed to write data to DSP: %s", snd_strerror(err));
+            return -1;
+        }
+
+        /* Check these are multiples of 8 bit */
+        pa_assert((areas[0].first & 7) == 0);
+        pa_assert((areas[0].step & 7)== 0);
+
+        /* We assume a single interleaved memory buffer */
+        pa_assert((areas[0].first >> 3) == 0);
+        pa_assert((areas[0].step >> 3) == u->frame_size);
+
+        p = (uint8_t*) areas[0].addr + (offset * u->frame_size);
+
+        chunk.memblock = pa_memblock_new_fixed(u->core->mempool, p, frames * u->frame_size, 1);
+        chunk.length = pa_memblock_get_length(chunk.memblock);
+        chunk.index = 0;
+
+        pa_source_post(u->source, &chunk);
+
+        /* FIXME: Maybe we can do something to keep this memory block
+         * a little bit longer around? */
+        pa_memblock_unref_fixed(chunk.memblock);
+
+        if ((err = snd_pcm_mmap_commit(u->pcm_handle, offset, frames)) < 0) {
+
+            if (err == -EPIPE)
+                pa_log_debug("snd_pcm_mmap_commit: Buffer underrun!");
+
+            if ((err = snd_pcm_recover(u->pcm_handle, err, 1)) == 0)
+                continue;
+
+            if (err == -EAGAIN)
+                return work_done;
+
+            pa_log("Failed to write data to DSP: %s", snd_strerror(err));
+            return -1;
+        }
+
+        work_done = 1;
+
+/*         pa_log("wrote %i samples", (int) frames); */
+    }
+}
+
+static int unix_read(struct userdata *u) {
+    snd_pcm_status_t *status;
+    int work_done = 0;
+
+    snd_pcm_status_alloca(&status);
+
+    pa_assert(u);
+    pa_source_assert_ref(u->source);
+
+    for (;;) {
+        void *p;
+        snd_pcm_sframes_t t, k;
+        ssize_t l;
+        int err;
+        pa_memchunk chunk;
+
+        if ((err = snd_pcm_status(u->pcm_handle, status)) < 0) {
+            pa_log("Failed to query DSP status data: %s", snd_strerror(err));
+            return -1;
+        }
+
+        if (snd_pcm_status_get_avail_max(status)*u->frame_size >= u->hwbuf_size)
+            pa_log_debug("Buffer overrun!");
+
+        l = snd_pcm_status_get_avail(status) * u->frame_size;
+
+        l = l - (l % u->fragment_size);
+
+        if (l <= 0)
+            return work_done;
+
+        chunk.memblock = pa_memblock_new(u->core->mempool, (size_t) -1);
+
+        k = pa_memblock_get_length(chunk.memblock);
+
+        if (k > l)
+            k = l;
+
+        k = (k/u->frame_size)*u->frame_size;
+
+        p = pa_memblock_acquire(chunk.memblock);
+        t = snd_pcm_readi(u->pcm_handle, (uint8_t*) p, k / u->frame_size);
+        pa_memblock_release(chunk.memblock);
+
+/*                     pa_log("wrote %i bytes of %u (%u)", t*u->frame_size, u->memchunk.length, l);   */
+
+        pa_assert(t != 0);
+
+        if (t < 0) {
+            pa_memblock_unref(chunk.memblock);
+
+            if ((t = snd_pcm_recover(u->pcm_handle, t, 1)) == 0)
+                continue;
+
+            if (t == -EAGAIN) {
+                pa_log_debug("EAGAIN");
+                return work_done;
+            } else {
+                pa_log("Failed to read data from DSP: %s", snd_strerror(t));
+                return -1;
+            }
+        }
+
+        chunk.index = 0;
+        chunk.length = t * u->frame_size;
+
+        pa_source_post(u->source, &chunk);
+        pa_memblock_unref(chunk.memblock);
+
+        work_done = 1;
+
+        if (t * u->frame_size >= (unsigned) l)
+            return work_done;
+    }
+}
+
+static int source_get_latency_by_timestamps(struct userdata *u, pa_usec_t *d) {
+    snd_pcm_uframes_t avail;
+    snd_htimestamp_t tstamp;
+    struct timespec ts_dma;
+    pa_usec_t buffered, elapsed;
+
+    if (snd_pcm_htimestamp(u->pcm_handle, &avail, &tstamp) < 0)
+        return -1;
+
+    ts_dma.tv_sec = tstamp.tv_sec;
+    ts_dma.tv_nsec = tstamp.tv_nsec;
+
+    buffered = pa_bytes_to_usec(avail * u->frame_size, &u->source->sample_spec);
+    elapsed = pa_rtclock_now() - pa_timespec_load(&ts_dma);
+
+    *d = /* buffered + */ elapsed;
+
+    return 0;
+}
+
+static pa_usec_t source_get_latency(struct userdata *u) {
+    pa_usec_t r = 0;
+    snd_pcm_status_t *status;
+    snd_pcm_sframes_t frames = 0;
+    int err;
+
+    snd_pcm_status_alloca(&status);
+
+    pa_assert(u);
+    pa_assert(u->pcm_handle);
+
+    if (source_get_latency_by_timestamps(u, &r) < 0) {
+        if ((err = snd_pcm_status(u->pcm_handle, status)) < 0)
+            pa_log("Failed to get delay: %s", snd_strerror(err));
+        else
+            frames = snd_pcm_status_get_delay(status);
+
+        if (frames > 0)
+            r = pa_bytes_to_usec(frames * u->frame_size, &u->source->sample_spec);
+    }
+
+    return r;
+}
+
+static int build_pollfd(struct userdata *u) {
+    int err;
+    struct pollfd *pollfd;
+    int n;
+
+    pa_assert(u);
+    pa_assert(u->pcm_handle);
+
+    if ((n = snd_pcm_poll_descriptors_count(u->pcm_handle)) < 0) {
+        pa_log("snd_pcm_poll_descriptors_count() failed: %s", snd_strerror(n));
+        return -1;
+    }
+
+    if (u->alsa_rtpoll_item)
+        pa_rtpoll_item_free(u->alsa_rtpoll_item);
+
+    u->alsa_rtpoll_item = pa_rtpoll_item_new(u->rtpoll, PA_RTPOLL_NEVER, n);
+    pollfd = pa_rtpoll_item_get_pollfd(u->alsa_rtpoll_item, NULL);
+
+    if ((err = snd_pcm_poll_descriptors(u->pcm_handle, pollfd, n)) < 0) {
+        pa_log("snd_pcm_poll_descriptors() failed: %s", snd_strerror(err));
+        return -1;
+    }
+
+    return 0;
+}
+
+static int suspend(struct userdata *u) {
+    pa_assert(u);
+    pa_assert(u->pcm_handle);
+
+    /* Let's suspend */
+    snd_pcm_close(u->pcm_handle);
+    u->pcm_handle = NULL;
+
+    if (u->alsa_rtpoll_item) {
+        pa_rtpoll_item_free(u->alsa_rtpoll_item);
+        u->alsa_rtpoll_item = NULL;
+    }
+
+    pa_log_info("Device suspended...");
+
+    return 0;
+}
+
+static int unsuspend(struct userdata *u) {
+    pa_sample_spec ss;
+    int err;
+    pa_bool_t b, d;
+    unsigned nfrags;
+    snd_pcm_uframes_t period_size;
+
+    pa_assert(u);
+    pa_assert(!u->pcm_handle);
+
+    pa_log_info("Trying resume...");
+
+    snd_config_update_free_global();
+    if ((err = snd_pcm_open(&u->pcm_handle, u->device_name, SND_PCM_STREAM_CAPTURE, SND_PCM_NONBLOCK)) < 0) {
+        pa_log("Error opening PCM device %s: %s", u->device_name, snd_strerror(err));
+        goto fail;
+    }
+
+    ss = u->source->sample_spec;
+    nfrags = u->nfragments;
+    period_size = u->fragment_size / u->frame_size;
+    b = u->use_mmap;
+    d = FALSE; /* use tsched */
+
+    if ((err = pa_alsa_set_hw_params(u->pcm_handle, &ss, &nfrags, &period_size, u->hwbuf_size / u->frame_size, &b, &d, TRUE)) < 0) {
+        pa_log("Failed to set hardware parameters: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if (b != u->use_mmap) {
+        pa_log_warn("Resume failed, couldn't get original access mode.");
+        goto fail;
+    }
+
+    if (!pa_sample_spec_equal(&ss, &u->source->sample_spec)) {
+        pa_log_warn("Resume failed, couldn't restore original sample settings.");
+        goto fail;
+    }
+
+    if (nfrags != u->nfragments || period_size*u->frame_size != u->fragment_size) {
+        pa_log_warn("Resume failed, couldn't restore original fragment settings.");
+        goto fail;
+    }
+
+    if ((err = pa_alsa_set_sw_params(u->pcm_handle, period_size)) < 0) {
+        pa_log("Failed to set software parameters: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if (build_pollfd(u) < 0)
+        goto fail;
+
+    snd_pcm_start(u->pcm_handle);
+
+    /* FIXME: We need to reload the volume somehow */
+
+    pa_log_info("Resumed successfully...");
+
+    return 0;
+
+fail:
+    if (u->pcm_handle) {
+        snd_pcm_close(u->pcm_handle);
+        u->pcm_handle = NULL;
+    }
+
+    return -1;
+}
+
+static int source_process_msg(pa_msgobject *o, int code, void *data, int64_t offset, pa_memchunk *chunk) {
+    struct userdata *u = PA_SOURCE(o)->userdata;
+
+    switch (code) {
+
+        case PA_SOURCE_MESSAGE_GET_LATENCY: {
+            pa_usec_t r = 0;
+
+            if (u->pcm_handle)
+                r = source_get_latency(u);
+
+            *((pa_usec_t*) data) = r;
+
+            return 0;
+        }
+
+        case PA_SOURCE_MESSAGE_SET_STATE:
+
+            switch ((pa_source_state_t) PA_PTR_TO_UINT(data)) {
+
+                case PA_SOURCE_SUSPENDED:
+                    pa_assert(PA_SOURCE_IS_OPENED(u->source->thread_info.state));
+
+                    if (suspend(u) < 0)
+                        return -1;
+
+                    break;
+
+                case PA_SOURCE_IDLE:
+                case PA_SOURCE_RUNNING:
+
+                    if (u->source->thread_info.state == PA_SOURCE_INIT) {
+                        if (build_pollfd(u) < 0)
+                            return -1;
+
+                        snd_pcm_start(u->pcm_handle);
+                    }
+
+                    if (u->source->thread_info.state == PA_SOURCE_SUSPENDED) {
+                        if (unsuspend(u) < 0)
+                            return -1;
+                    }
+
+                    break;
+
+                case PA_SOURCE_UNLINKED:
+                case PA_SOURCE_INIT:
+                default:
+                    break;
+            }
+
+            break;
+
+        case PA_SOURCE_MESSAGE_ADD_OUTPUT:
+        case PA_SOURCE_MESSAGE_REMOVE_OUTPUT:
+        default:
+            break;
+    }
+
+    return pa_source_process_msg(o, code, data, offset, chunk);
+}
+
+static int mixer_callback(snd_mixer_elem_t *elem, unsigned int mask) {
+    struct userdata *u = snd_mixer_elem_get_callback_private(elem);
+
+    pa_assert(u);
+    pa_assert(u->mixer_handle);
+
+    if (mask == SND_CTL_EVENT_MASK_REMOVE)
+        return 0;
+
+    if (mask & SND_CTL_EVENT_MASK_VALUE) {
+        pa_source_get_volume(u->source, TRUE);
+        pa_source_get_mute(u->source, TRUE);
+    }
+
+    return 0;
+}
+
+static pa_volume_t from_alsa_volume(struct userdata *u, long alsa_vol) {
+
+    return (pa_volume_t) round(((double) (alsa_vol - u->hw_volume_min) * PA_VOLUME_NORM) /
+                               (double) (u->hw_volume_max - u->hw_volume_min));
+}
+
+static long to_alsa_volume(struct userdata *u, pa_volume_t vol) {
+    long alsa_vol;
+
+    alsa_vol = (long) round(((double) vol * (double) (u->hw_volume_max - u->hw_volume_min))
+                            / PA_VOLUME_NORM) + u->hw_volume_min;
+
+    return PA_CLAMP_UNLIKELY(alsa_vol, u->hw_volume_min, u->hw_volume_max);
+}
+
+static void source_get_volume_cb(pa_source *s) {
+    struct userdata *u = s->userdata;
+    int err;
+    unsigned i;
+    pa_cvolume r;
+    char t[PA_CVOLUME_SNPRINT_MAX];
+
+    pa_assert(u);
+    pa_assert(u->mixer_elem);
+
+    if (u->mixer_seperate_channels) {
+
+        r.channels = s->sample_spec.channels;
+
+        for (i = 0; i < s->sample_spec.channels; i++) {
+            long alsa_vol;
+
+            if (u->hw_dB_supported) {
+
+                if ((err = snd_mixer_selem_get_capture_dB(u->mixer_elem, u->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+                r.values[i] = pa_sw_volume_from_dB((double) (alsa_vol - u->hw_dB_max) / 100.0);
+            } else {
+
+                if ((err = snd_mixer_selem_get_capture_volume(u->mixer_elem, u->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+                r.values[i] = from_alsa_volume(u, alsa_vol);
+            }
+        }
+
+    } else {
+        long alsa_vol;
+
+        if (u->hw_dB_supported) {
+
+            if ((err = snd_mixer_selem_get_capture_dB(u->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+            pa_cvolume_set(&r, s->sample_spec.channels, pa_sw_volume_from_dB((double) (alsa_vol - u->hw_dB_max) / 100.0));
+
+        } else {
+
+            if ((err = snd_mixer_selem_get_capture_volume(u->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+            pa_cvolume_set(&r, s->sample_spec.channels, from_alsa_volume(u, alsa_vol));
+        }
+    }
+
+    pa_log_debug("Read hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &r));
+
+    if (!pa_cvolume_valid(&u->hardware_volume) || !pa_cvolume_equal(&u->hardware_volume, &r)) {
+
+        s->virtual_volume = u->hardware_volume = r;
+
+        if (u->hw_dB_supported) {
+            pa_cvolume reset;
+
+            /* Hmm, so the hardware volume changed, let's reset our software volume */
+            pa_cvolume_reset(&reset, s->sample_spec.channels);
+            pa_source_set_soft_volume(s, &reset);
+        }
+    }
+
+    return;
+
+ fail:
+    pa_log_error("Unable to read volume: %s", snd_strerror(err));
+}
+
+static void source_set_volume_cb(pa_source *s) {
+    struct userdata *u = s->userdata;
+    int err;
+    unsigned i;
+    pa_cvolume r;
+
+    pa_assert(u);
+    pa_assert(u->mixer_elem);
+
+    if (u->mixer_seperate_channels) {
+
+        r.channels = s->sample_spec.channels;
+
+        for (i = 0; i < s->sample_spec.channels; i++) {
+            long alsa_vol;
+            pa_volume_t vol;
+
+            vol = s->virtual_volume.values[i];
+
+            if (u->hw_dB_supported) {
+
+                alsa_vol = (long) (pa_sw_volume_to_dB(vol) * 100);
+                alsa_vol += u->hw_dB_max;
+                alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, u->hw_dB_min, u->hw_dB_max);
+
+                if ((err = snd_mixer_selem_set_capture_dB(u->mixer_elem, u->mixer_map[i], alsa_vol, 1)) < 0)
+                    goto fail;
+
+                if ((err = snd_mixer_selem_get_capture_dB(u->mixer_elem, u->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+                r.values[i] = pa_sw_volume_from_dB((double) (alsa_vol - u->hw_dB_max) / 100.0);
+
+            } else {
+                alsa_vol = to_alsa_volume(u, vol);
+
+                if ((err = snd_mixer_selem_set_capture_volume(u->mixer_elem, u->mixer_map[i], alsa_vol)) < 0)
+                    goto fail;
+
+                if ((err = snd_mixer_selem_get_capture_volume(u->mixer_elem, u->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+                r.values[i] = from_alsa_volume(u, alsa_vol);
+            }
+        }
+
+    } else {
+        pa_volume_t vol;
+        long alsa_vol;
+
+        vol = pa_cvolume_max(&s->virtual_volume);
+
+        if (u->hw_dB_supported) {
+            alsa_vol = (long) (pa_sw_volume_to_dB(vol) * 100);
+            alsa_vol += u->hw_dB_max;
+            alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, u->hw_dB_min, u->hw_dB_max);
+
+            if ((err = snd_mixer_selem_set_capture_dB_all(u->mixer_elem, alsa_vol, 1)) < 0)
+                goto fail;
+
+            if ((err = snd_mixer_selem_get_capture_dB(u->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+            pa_cvolume_set(&r, s->sample_spec.channels, pa_sw_volume_from_dB((double) (alsa_vol - u->hw_dB_max) / 100.0));
+
+        } else {
+            alsa_vol = to_alsa_volume(u, vol);
+
+            if ((err = snd_mixer_selem_set_capture_volume_all(u->mixer_elem, alsa_vol)) < 0)
+                goto fail;
+
+            if ((err = snd_mixer_selem_get_capture_volume(u->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+            pa_cvolume_set(&r, s->sample_spec.channels, from_alsa_volume(u, alsa_vol));
+        }
+    }
+
+    u->hardware_volume = r;
+
+    if (u->hw_dB_supported) {
+        char t[PA_CVOLUME_SNPRINT_MAX];
+
+        /* Match exactly what the user requested by software */
+
+        pa_sw_cvolume_divide(&s->soft_volume, &s->virtual_volume, &u->hardware_volume);
+
+        pa_log_debug("Requested volume: %s", pa_cvolume_snprint(t, sizeof(t), &s->virtual_volume));
+        pa_log_debug("Got hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &u->hardware_volume));
+        pa_log_debug("Calculated software volume: %s", pa_cvolume_snprint(t, sizeof(t), &s->soft_volume));
+
+    } else
+
+        /* We can't match exactly what the user requested, hence let's
+         * at least tell the user about it */
+
+        s->virtual_volume = r;
+
+    return;
+
+ fail:
+    pa_log_error("Unable to set volume: %s", snd_strerror(err));
+}
+
+static void source_get_mute_cb(pa_source *s) {
+    struct userdata *u = s->userdata;
+    int err, sw;
+
+    pa_assert(u);
+    pa_assert(u->mixer_elem);
+
+    if ((err = snd_mixer_selem_get_capture_switch(u->mixer_elem, 0, &sw)) < 0) {
+        pa_log_error("Unable to get switch: %s", snd_strerror(err));
+        return;
+    }
+
+    s->muted = !sw;
+}
+
+static void source_set_mute_cb(pa_source *s) {
+    struct userdata *u = s->userdata;
+    int err;
+
+    pa_assert(u);
+    pa_assert(u->mixer_elem);
+
+    if ((err = snd_mixer_selem_set_capture_switch_all(u->mixer_elem, !s->muted)) < 0) {
+        pa_log_error("Unable to set switch: %s", snd_strerror(err));
+        return;
+    }
+}
+
+static void thread_func(void *userdata) {
+    struct userdata *u = userdata;
+
+    pa_assert(u);
+
+    pa_log_debug("Thread starting up");
+
+    if (u->core->realtime_scheduling)
+        pa_make_realtime(u->core->realtime_priority);
+
+    pa_thread_mq_install(&u->thread_mq);
+    pa_rtpoll_install(u->rtpoll);
+
+    for (;;) {
+        int ret;
+
+        /* Read some data and pass it to the sources */
+        if (PA_SOURCE_IS_OPENED(u->source->thread_info.state)) {
+
+            if (u->use_mmap) {
+                if (mmap_read(u) < 0)
+                    goto fail;
+
+            } else {
+                if (unix_read(u) < 0)
+                    goto fail;
+            }
+        }
+
+        /* Hmm, nothing to do. Let's sleep */
+        if ((ret = pa_rtpoll_run(u->rtpoll, 1)) < 0)
+            goto fail;
+
+        if (ret == 0)
+            goto finish;
+
+        /* Tell ALSA about this and process its response */
+        if (PA_SOURCE_IS_OPENED(u->source->thread_info.state)) {
+            struct pollfd *pollfd;
+            unsigned short revents = 0;
+            int err;
+            unsigned n;
+
+            pollfd = pa_rtpoll_item_get_pollfd(u->alsa_rtpoll_item, &n);
+
+            if ((err = snd_pcm_poll_descriptors_revents(u->pcm_handle, pollfd, n, &revents)) < 0) {
+                pa_log("snd_pcm_poll_descriptors_revents() failed: %s", snd_strerror(err));
+                goto fail;
+            }
+
+            if (revents & (POLLERR|POLLNVAL|POLLHUP)) {
+
+                if (revents & POLLERR)
+                    pa_log_warn("Got POLLERR from ALSA");
+                if (revents & POLLNVAL)
+                    pa_log_warn("Got POLLNVAL from ALSA");
+                if (revents & POLLHUP)
+                    pa_log_warn("Got POLLHUP from ALSA");
+
+                /* Try to recover from this error */
+
+                switch (snd_pcm_state(u->pcm_handle)) {
+
+                    case SND_PCM_STATE_XRUN:
+                        if ((err = snd_pcm_recover(u->pcm_handle, -EPIPE, 1)) != 0) {
+                            pa_log_warn("Could not recover from POLLERR|POLLNVAL|POLLHUP and XRUN: %s", snd_strerror(err));
+                            goto fail;
+                        }
+                        break;
+
+                    case SND_PCM_STATE_SUSPENDED:
+                        if ((err = snd_pcm_recover(u->pcm_handle, -ESTRPIPE, 1)) != 0) {
+                            pa_log_warn("Could not recover from POLLERR|POLLNVAL|POLLHUP and SUSPENDED: %s", snd_strerror(err));
+                            goto fail;
+                        }
+                        break;
+
+                    default:
+
+                        snd_pcm_drop(u->pcm_handle);
+
+                        if ((err = snd_pcm_prepare(u->pcm_handle)) < 0) {
+                            pa_log_warn("Could not recover from POLLERR|POLLNVAL|POLLHUP with snd_pcm_prepare(): %s", snd_strerror(err));
+                            goto fail;
+                        }
+                        break;
+                }
+            }
+        }
+    }
+
+fail:
+    /* If this was no regular exit from the loop we have to continue
+     * processing messages until we received PA_MESSAGE_SHUTDOWN */
+    pa_asyncmsgq_post(u->thread_mq.outq, PA_MSGOBJECT(u->core), PA_CORE_MESSAGE_UNLOAD_MODULE, u->module, 0, NULL, NULL);
+    pa_asyncmsgq_wait_for(u->thread_mq.inq, PA_MESSAGE_SHUTDOWN);
+
+finish:
+    pa_log_debug("Thread shutting down");
+}
+
+static pa_hook_result_t source_proplist_changed_hook_callback(pa_core *c, pa_source *s, struct userdata *u) {
+    const char *v = NULL;
+
+    pa_assert(u);
+    pa_assert(s);
+
+    v = pa_proplist_gets(s->proplist, PROP_BUFFERS);
+    if (v) {
+        if (pa_startswith(v, PROP_BUFFERS_PRIMARY)) {
+            switch_buffers(u, SOURCE_SWITCH_PRIMARY);
+        }
+        else if (pa_startswith(v, PROP_BUFFERS_ALTERNATIVE)) {
+            switch_buffers(u, SOURCE_SWITCH_ALTERNATIVE);
+        }
+    }
+
+    return PA_HOOK_OK;
+}
+
+int pa__init(pa_module*m) {
+
+    pa_modargs *ma = NULL;
+    struct userdata *u = NULL;
+    const char *dev_id;
+    pa_sample_spec ss;
+    pa_channel_map map;
+    char *alsa_mixer = NULL;
+    unsigned ii;
+    uint32_t nfrags, frag_size;
+    uint32_t alt_nfrags, alt_frag_size;
+    snd_pcm_uframes_t period_size;
+    snd_pcm_uframes_t alt_period_size;
+    size_t frame_size;
+    size_t alt_frame_size;
+    snd_pcm_info_t *pcm_info = NULL;
+    int err;
+    char *t;
+    const char *name;
+    char *name_buf = NULL;
+    int namereg_fail;
+    pa_bool_t use_mmap = TRUE, b, d, ignore_dB = FALSE;
+    pa_source_new_data data;
+    const pa_alsa_profile_info *profile;
+
+    snd_pcm_info_alloca(&pcm_info);
+
+    pa_assert(m);
+
+    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+        pa_log("Failed to parse module arguments");
+        goto fail;
+    }
+
+    ss = m->core->default_sample_spec;
+    if (pa_modargs_get_sample_spec_and_channel_map(ma, &ss, &map, PA_CHANNEL_MAP_ALSA) < 0) {
+        pa_log("Failed to parse sample specification");
+        goto fail;
+    }
+
+    alsa_mixer = pa_xstrdup(pa_modargs_get_value(ma, "mixer", "Capture"));
+    ii = 0;
+    while(alsa_mixer[ii++] != '\0') {
+        if (alsa_mixer[ii] == '_')
+            alsa_mixer[ii] = ' ';
+    }
+
+    frame_size = pa_frame_size(&ss);
+
+    nfrags = m->core->default_n_fragments;
+    frag_size = pa_usec_to_bytes(m->core->default_fragment_size_msec*1000, &ss);
+    if (frag_size <= 0)
+        frag_size = frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "fragments", &nfrags) < 0 || pa_modargs_get_value_u32(ma, "fragment_size", &frag_size) < 0) {
+        pa_log("Failed to parse buffer metrics");
+        goto fail;
+    }
+    period_size = frag_size/frame_size;
+
+    alt_frame_size = pa_frame_size(&ss);
+
+    /* 0 is default value from pa_modargs_get */
+    alt_period_size = 0;
+    alt_nfrags = 0;
+    alt_frag_size = alt_frame_size;
+
+    if (alt_frag_size <= 0)
+        alt_frag_size = alt_frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "alt_fragments", &alt_nfrags) < 0 || pa_modargs_get_value_u32(ma, "alt_fragment_size", &alt_frag_size) < 0) {
+        pa_log("Failed to parse buffer metrics");
+        goto fail;
+    }
+
+    if (alt_nfrags != 0)
+        alt_period_size = alt_frag_size/alt_frame_size;
+
+    if (pa_modargs_get_value_boolean(ma, "mmap", &use_mmap) < 0) {
+        pa_log("Failed to parse mmap argument.");
+        goto fail;
+    }
+
+    if (pa_modargs_get_value_boolean(ma, "ignore_dB", &ignore_dB) < 0) {
+        pa_log("Failed to parse ignore_dB argument.");
+        goto fail;
+    }
+
+    u = pa_xnew0(struct userdata, 1);
+    u->switch_mode = SOURCE_SWITCH_PRIMARY;
+    if (alt_nfrags != 0)
+        u->switching_enabled = TRUE;
+    else
+        u->switching_enabled = FALSE;
+    u->core = m->core;
+    u->module = m;
+    m->userdata = u;
+    u->use_mmap = use_mmap;
+    u->rtpoll = pa_rtpoll_new();
+    pa_thread_mq_init(&u->thread_mq, m->core->mainloop, u->rtpoll);
+    u->alsa_rtpoll_item = NULL;
+
+    snd_config_update_free_global();
+
+    b = use_mmap;
+    d = FALSE; /* use_tsched */
+    profile = NULL; /* no profile specified */
+
+    if ((dev_id = pa_modargs_get_value(ma, "device_id", NULL))) {
+
+        if (!(u->pcm_handle = pa_alsa_open_by_device_id_auto(
+                      dev_id,
+                      &u->device_name,
+                      &ss, &map,
+                      SND_PCM_STREAM_CAPTURE,
+                      &nfrags, &period_size, period_size * nfrags,
+                      &b, &d, &profile)))
+            goto fail;
+
+    } else {
+
+        if (!(u->pcm_handle = pa_alsa_open_by_device_string(
+                      pa_modargs_get_value(ma, "device", DEFAULT_DEVICE),
+                      &u->device_name,
+                      &ss, &map,
+                      SND_PCM_STREAM_CAPTURE,
+                      &nfrags, &period_size, period_size * nfrags,
+                      &b, &d, FALSE)))
+            goto fail;
+    }
+
+    pa_assert(u->device_name);
+    pa_log_info("Successfully opened device %s.", u->device_name);
+
+    if (use_mmap && !b) {
+        pa_log_info("Device doesn't support mmap(), falling back to UNIX read/write mode.");
+        u->use_mmap = use_mmap = b;
+    }
+
+    if (u->use_mmap)
+        pa_log_info("Successfully enabled mmap() mode.");
+
+    if ((err = snd_pcm_info(u->pcm_handle, pcm_info)) < 0) {
+        pa_log("Error fetching PCM info: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if ((err = pa_alsa_set_sw_params(u->pcm_handle, period_size)) < 0) {
+        pa_log("Failed to set software parameters: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    /* ALSA might tweak the sample spec, so recalculate the frame size */
+    frame_size = pa_frame_size(&ss);
+
+    if ((err = snd_mixer_open(&u->mixer_handle, 0)) < 0)
+        pa_log("Error opening mixer: %s", snd_strerror(err));
+    else {
+        pa_bool_t found = FALSE;
+
+        if (pa_alsa_prepare_mixer(u->mixer_handle, u->device_name) >= 0)
+            found = TRUE;
+        else {
+            char *md = pa_sprintf_malloc("hw:%s", dev_id);
+
+            if (strcmp(u->device_name, md))
+                if (pa_alsa_prepare_mixer(u->mixer_handle, md) >= 0)
+                    found = TRUE;
+
+            pa_xfree(md);
+        }
+
+        if (found)
+            if (!(u->mixer_elem = pa_alsa_find_elem(u->mixer_handle, alsa_mixer, "Mic", FALSE)))
+                found = FALSE;
+
+        if (!found) {
+            snd_mixer_close(u->mixer_handle);
+            u->mixer_handle = NULL;
+        }
+    }
+
+    if ((name = pa_modargs_get_value(ma, "source_name", NULL)))
+        namereg_fail = 1;
+    else {
+        name = name_buf = pa_sprintf_malloc("alsa_input.%s", u->device_name);
+        namereg_fail = 0;
+    }
+
+    pa_source_new_data_init(&data);
+    data.driver = __FILE__;
+    data.module = m;
+    pa_source_new_data_set_name(&data, name);
+    data.namereg_fail = namereg_fail;
+    pa_source_new_data_set_sample_spec(&data, &ss);
+    pa_source_new_data_set_channel_map(&data, &map);
+
+    pa_alsa_init_proplist_pcm(m->core, data.proplist, u->pcm_handle, NULL);
+    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_STRING, u->device_name);
+    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE, "%lu", (unsigned long) (period_size * frame_size * nfrags));
+    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE, "%lu", (unsigned long) (period_size * frame_size));
+    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_ACCESS_MODE, (u->use_mmap ? "mmap" : "serial"));
+
+    u->source = pa_source_new(m->core, &data, PA_SOURCE_HARDWARE|PA_SOURCE_LATENCY);
+    pa_source_new_data_done(&data);
+    pa_xfree(name_buf);
+
+    if (!u->source) {
+        pa_log("Failed to create source object");
+        goto fail;
+    }
+
+    u->source->parent.process_msg = source_process_msg;
+    u->source->userdata = u;
+
+    pa_source_set_asyncmsgq(u->source, u->thread_mq.inq);
+    pa_source_set_rtpoll(u->source, u->rtpoll);
+    pa_source_set_description(u->source, t = pa_sprintf_malloc(
+                                      "ALSA PCM on %s (%s)%s",
+                                      u->device_name,
+                                      snd_pcm_info_get_name(pcm_info),
+                                      use_mmap ? " via DMA" : ""));
+    pa_xfree(t);
+
+    u->source->flags = PA_SOURCE_HARDWARE|PA_SOURCE_LATENCY;
+
+    u->frame_size = frame_size;
+    u->fragment_size = frag_size = period_size * frame_size;
+    u->nfragments = nfrags;
+    u->hwbuf_size = u->fragment_size * nfrags;
+    u->period_size = period_size;
+
+    if (u->switching_enabled) {
+        u->pri_frame_size = frame_size;
+        u->pri_fragment_size = frag_size = period_size * frame_size;
+        u->pri_nfragments = nfrags;
+        u->pri_hwbuf_size = u->fragment_size * nfrags;
+        u->pri_period_size = period_size;
+
+        u->alt_frame_size = alt_frame_size;
+        u->alt_fragment_size = alt_frag_size = alt_period_size * alt_frame_size;
+        u->alt_nfragments = alt_nfrags;
+        u->alt_hwbuf_size = u->alt_fragment_size * alt_nfrags;
+        u->alt_period_size = alt_period_size;
+    }
+
+    pa_log_info("PRI: Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->pri_fragment_size);
+    if (u->switching_enabled)
+        pa_log_info("ALT: Using %u fragments of size %lu bytes.", alt_nfrags, (long unsigned) u->alt_fragment_size);
+
+    if (u->mixer_handle) {
+        pa_assert(u->mixer_elem);
+
+        if (snd_mixer_selem_has_capture_volume(u->mixer_elem)) {
+            pa_bool_t suitable = FALSE;
+
+            if (snd_mixer_selem_get_capture_volume_range(u->mixer_elem, &u->hw_volume_min, &u->hw_volume_max) < 0)
+                pa_log_info("Failed to get volume range. Falling back to software volume control.");
+            else if (u->hw_volume_min >= u->hw_volume_max)
+                pa_log_warn("Your kernel driver is broken: it reports a volume range from %li to %li which makes no sense.", u->hw_volume_min, u->hw_volume_max);
+            else {
+                pa_log_info("Volume ranges from %li to %li.", u->hw_volume_min, u->hw_volume_max);
+                suitable = TRUE;
+            }
+
+            if (suitable) {
+                if (ignore_dB || snd_mixer_selem_get_capture_dB_range(u->mixer_elem, &u->hw_dB_min, &u->hw_dB_max) < 0)
+                    pa_log_info("Mixer doesn't support dB information or data is ignored.");
+                else {
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                    VALGRIND_MAKE_MEM_DEFINED(&u->hw_dB_min, sizeof(u->hw_dB_min));
+                    VALGRIND_MAKE_MEM_DEFINED(&u->hw_dB_max, sizeof(u->hw_dB_max));
+#endif
+
+                    if (u->hw_dB_min >= u->hw_dB_max)
+                        pa_log_warn("Your kernel driver is broken: it reports a volume range from %0.2f dB to %0.2f dB which makes no sense.", (double) u->hw_dB_min/100.0, (double) u->hw_dB_max/100.0);
+                    else {
+                        pa_log_info("Volume ranges from %0.2f dB to %0.2f dB.", (double) u->hw_dB_min/100.0, (double) u->hw_dB_max/100.0);
+                        u->hw_dB_supported = TRUE;
+
+                        if (u->hw_dB_max > 0) {
+                            u->source->base_volume = pa_sw_volume_from_dB(- (double) u->hw_dB_max/100.0);
+                            pa_log_info("Fixing base volume to %0.2f dB", pa_sw_volume_to_dB(u->source->base_volume));
+                        } else
+                            pa_log_info("No particular base volume set, fixing to 0 dB");
+
+                    }
+                }
+
+                if (!u->hw_dB_supported &&
+                    u->hw_volume_max - u->hw_volume_min < 3) {
+
+                    pa_log_info("Device has less than 4 volume levels. Falling back to software volume control.");
+                    suitable = FALSE;
+                }
+            }
+
+            if (suitable) {
+                u->mixer_seperate_channels = pa_alsa_calc_mixer_map(u->mixer_elem, &map, u->mixer_map, FALSE) >= 0;
+
+                u->source->get_volume = source_get_volume_cb;
+                u->source->set_volume = source_set_volume_cb;
+                u->source->flags |= PA_SOURCE_HW_VOLUME_CTRL | (u->hw_dB_supported ? PA_SOURCE_DECIBEL_VOLUME : 0);
+                pa_log_info("Using hardware volume control. Hardware dB scale %s.", u->hw_dB_supported ? "supported" : "not supported");
+
+                if (!u->hw_dB_supported)
+                    u->source->n_volume_steps = u->hw_volume_max - u->hw_volume_min + 1;
+            } else
+                pa_log_info("Using software volume control.");
+        }
+
+        if (snd_mixer_selem_has_capture_switch(u->mixer_elem)) {
+            u->source->get_mute = source_get_mute_cb;
+            u->source->set_mute = source_set_mute_cb;
+            u->source->flags |= PA_SOURCE_HW_MUTE_CTRL;
+        } else
+            pa_log_info("Using software mute control.");
+
+        u->mixer_fdl = pa_alsa_fdlist_new();
+
+        if (pa_alsa_fdlist_set_mixer(u->mixer_fdl, u->mixer_handle, m->core->mainloop) < 0) {
+            pa_log("Failed to initialize file descriptor monitoring");
+            goto fail;
+        }
+
+        snd_mixer_elem_set_callback(u->mixer_elem, mixer_callback);
+        snd_mixer_elem_set_callback_private(u->mixer_elem, u);
+    } else
+        u->mixer_fdl = NULL;
+
+    if (!(u->thread = pa_thread_new(thread_func, u))) {
+        pa_log("Failed to create thread.");
+        goto fail;
+    }
+    /* Get initial mixer settings */
+    if (data.volume_is_set) {
+        if (u->source->set_volume)
+            u->source->set_volume(u->source);
+    } else {
+        if (u->source->get_volume)
+            u->source->get_volume(u->source);
+    }
+
+    if (data.muted_is_set) {
+        if (u->source->set_mute)
+            u->source->set_mute(u->source);
+    } else {
+        if (u->source->get_mute)
+            u->source->get_mute(u->source);
+    }
+
+    pa_proplist_sets(u->source->proplist, PROP_BUFFERS, PROP_BUFFERS_PRIMARY);
+
+    /* hook for buffer switching */
+    if (u->switching_enabled)
+        u->source_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SOURCE_PROPLIST_CHANGED],
+                                                          PA_HOOK_LATE,
+                                                          (pa_hook_cb_t)source_proplist_changed_hook_callback, u);
+
+    pa_source_put(u->source);
+
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
+    pa_modargs_free(ma);
+
+    return 0;
+
+fail:
+
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
+    if (ma)
+        pa_modargs_free(ma);
+
+    pa__done(m);
+
+    return -1;
+}
+
+void pa__done(pa_module*m) {
+    struct userdata *u;
+
+    pa_assert(m);
+
+    if (!(u = m->userdata))
+        return;
+
+    if (u->source)
+        pa_source_unlink(u->source);
+
+    if (u->thread) {
+        pa_asyncmsgq_send(u->thread_mq.inq, NULL, PA_MESSAGE_SHUTDOWN, NULL, 0, NULL);
+        pa_thread_free(u->thread);
+    }
+
+    pa_thread_mq_done(&u->thread_mq);
+
+    if (u->source)
+        pa_source_unref(u->source);
+
+    if (u->alsa_rtpoll_item)
+        pa_rtpoll_item_free(u->alsa_rtpoll_item);
+
+    if (u->rtpoll)
+        pa_rtpoll_free(u->rtpoll);
+
+    if (u->mixer_fdl)
+        pa_alsa_fdlist_free(u->mixer_fdl);
+
+    if (u->mixer_handle)
+        snd_mixer_close(u->mixer_handle);
+
+    if (u->pcm_handle) {
+        snd_pcm_drop(u->pcm_handle);
+        snd_pcm_close(u->pcm_handle);
+    }
+
+    pa_xfree(u->device_name);
+    pa_xfree(u);
+
+    snd_config_update_free_global();
+}
-- 
1.6.3.1

