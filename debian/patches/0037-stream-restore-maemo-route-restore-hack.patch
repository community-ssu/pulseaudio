From bbc00b92bbc644b394f1035d605b031245024042 Mon Sep 17 00:00:00 2001
From: =?utf-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@gmail.com>
Date: Thu, 21 May 2009 19:32:58 +0300
Subject: [PATCH 37/62] stream-restore: maemo route restore hack

---
 src/modules/module-stream-restore.c |  431 +++++++++++++++++++++++++++++++++--
 1 files changed, 416 insertions(+), 15 deletions(-)

diff --git a/src/modules/module-stream-restore.c b/src/modules/module-stream-restore.c
index 8964792..15743b6 100644
--- a/src/modules/module-stream-restore.c
+++ b/src/modules/module-stream-restore.c
@@ -79,6 +79,13 @@ static const char* const valid_modargs[] = {
     NULL
 };
 
+/* this is so annoying to have volume as unsigned, and it piss me off */
+/* remember values are in dB scale, and we do dB based computation */
+typedef struct csvolume {
+    uint8_t channels;                     /**< Number of channels */
+    int32_t values[PA_CHANNELS_MAX];      /**< Per-channel volume diff */
+} csvolume;
+
 struct userdata {
     pa_core *core;
     pa_module *module;
@@ -97,9 +104,14 @@ struct userdata {
 
     pa_native_protocol *protocol;
     pa_idxset *subscribed;
+
+    pa_hook_slot *sink_proplist_changed_slot;
+    GDBM_FILE gdbm_route_file;
+    char *route;
+    pa_cvolume route_volume;
 };
 
-#define ENTRY_VERSION 3
+#define ENTRY_VERSION 4
 
 struct entry {
     uint8_t version;
@@ -107,10 +119,17 @@ struct entry {
     pa_bool_t muted:1;
     pa_bool_t volume_is_absolute:1;
     pa_channel_map channel_map;
-    pa_cvolume volume;
+    csvolume volume;
     char device[PA_NAME_MAX];
 } PA_GCC_PACKED;
 
+#define ROUTE_ENTRY_VERSION 1
+
+struct route_entry {
+    uint8_t version;
+    pa_cvolume volume;
+} PA_GCC_PACKED;
+
 enum {
     SUBCOMMAND_TEST,
     SUBCOMMAND_READ,
@@ -120,6 +139,324 @@ enum {
     SUBCOMMAND_EVENT
 };
 
+static struct entry* read_entry(struct userdata *u, const char *name);
+static pa_bool_t entries_equal(const struct entry *a, const struct entry *b);
+static void trigger_save(struct userdata *u);
+static void apply_entry(struct userdata *u, const char *name, struct entry *e);
+
+static int _ignore_rule_hack(const char *name) {
+    pa_assert(name);
+
+    /* we only update maemo and phone volume */
+    return !(pa_streq(name, "x-maemo") || pa_streq(name, "sink-input-by-media-role:phone"));
+
+    return
+        pa_streq(name, "x-maemo-hildon-notify") ||
+        pa_streq(name, "x-maemo-touchscreen-pressed") ||
+        pa_streq(name, "sink-input-by-media-role:animation") ||
+        pa_streq(name, "x-maemo-key-pressed");
+}
+
+static int csvolume_valid(const csvolume *v) {
+    pa_assert(v);
+
+    if (v->channels <= 0 || v->channels > PA_CHANNELS_MAX)
+        return 0;
+
+    return 1;
+}
+
+static csvolume* csvolume_init(csvolume *v) {
+    unsigned c;
+
+    pa_assert(v);
+
+    v->channels = 0;
+
+    for (c = 0; c < PA_CHANNELS_MAX; c++)
+        v->values[c] = 0;
+
+    return v;
+}
+
+static pa_cvolume* csvolume_to_cvolume(const csvolume *a, pa_cvolume *r) {
+    int i;
+
+    pa_assert(a);
+    pa_assert(r);
+
+    pa_cvolume_init(r);
+    pa_return_val_if_fail(csvolume_valid(a), NULL);
+
+    r->channels = a->channels;
+    for (i = 0; i < a->channels; ++i)
+        r->values[i] = PA_CLAMP_UNLIKELY(a->values[i], (int32_t)PA_VOLUME_MUTED, (int32_t)PA_VOLUME_NORM);
+
+    return r;
+}
+
+static csvolume* csvolume_from_cvolume(csvolume *a, const pa_cvolume *v) {
+    int i;
+
+    pa_assert(a);
+    pa_assert(v);
+
+    csvolume_init(a);
+    pa_return_val_if_fail(pa_cvolume_valid(v), NULL);
+
+    a->channels = v->channels;
+    for (i = 0; i < a->channels; ++i)
+        a->values[i] = (int32_t)v->values[i];
+
+    return a;
+}
+
+static csvolume* csvolume_set(csvolume *a, unsigned channels, int32_t v) {
+    int i;
+
+    pa_assert(a);
+    pa_assert(channels > 0);
+    pa_assert(channels <= PA_CHANNELS_MAX);
+
+    a->channels = (uint8_t) channels;
+
+    for (i = 0; i < a->channels; i++)
+        a->values[i] = v;
+
+    return a;
+}
+
+static int csvolume_substract_cvolume(csvolume *d, const pa_cvolume *a, const pa_cvolume *b) {
+    int i;
+    pa_assert(a);
+    pa_assert(b);
+    pa_assert(d);
+
+    pa_return_val_if_fail(pa_cvolume_valid(a), 0);
+    pa_return_val_if_fail(pa_cvolume_valid(b), 0);
+
+    csvolume_init(d);
+    d->channels = PA_MAX(a->channels, b->channels);
+
+    for (i = 0; i < PA_MIN(a->channels, b->channels); ++i)
+        d->values[i] = (int32_t)a->values[i] - (int32_t)b->values[i];
+
+    return 1;
+}
+
+static csvolume* csvolume_add(csvolume *a, const csvolume *b) {
+    int i;
+    pa_assert(a);
+    pa_assert(b);
+
+    pa_return_val_if_fail(csvolume_valid(a), NULL);
+    pa_return_val_if_fail(csvolume_valid(b), NULL);
+
+    for (i = PA_MIN(a->channels, b->channels); i > 0 ; ) {
+        --i;
+        a->values[i] += b->values[i];
+    }
+
+    return a;
+}
+
+static int csvolume_equal(const csvolume *a, const csvolume *b) {
+    int i;
+    pa_assert(a);
+    pa_assert(b);
+
+    pa_return_val_if_fail(csvolume_valid(a), FALSE);
+    pa_return_val_if_fail(csvolume_valid(b), FALSE);
+
+    if (a->channels != b->channels)
+        return FALSE;
+
+    for (i = 0; i < a->channels ; ++i)
+        if (a->values[i] != b->values[i])
+            return FALSE;
+
+    return TRUE;
+}
+
+static int csvolume_compatible_with_channel_map(const csvolume *v, const pa_channel_map *m) {
+    pa_cvolume c;
+
+    csvolume_to_cvolume(v, &c);
+    return pa_cvolume_compatible_with_channel_map(&c, m);
+}
+
+static struct route_entry* read_route_entry(struct userdata *u, const char *route) {
+    datum key, data;
+    struct route_entry *e;
+
+    pa_assert(u);
+    pa_assert(route);
+
+    key.dptr = (char*) route;
+    key.dsize = (int) strlen(route);
+
+    data = gdbm_fetch(u->gdbm_route_file, key);
+
+    if (!data.dptr)
+        goto fail;
+
+    if (data.dsize != sizeof(struct route_entry)) {
+        /* This is probably just a database upgrade, hence let's not
+         * consider this more than a debug message */
+        pa_log_debug("Database contains entry for route %s of wrong size %lu != %lu. Probably due to uprade, ignoring.", route, (unsigned long) data.dsize, (unsigned long) sizeof(struct route_entry));
+        goto fail;
+    }
+
+    e = (struct route_entry*) data.dptr;
+
+    if (e->version != ROUTE_ENTRY_VERSION) {
+        pa_log_debug("Version of database entry for route %s doesn't match our version. Probably due to upgrade, ignoring.", route);
+        goto fail;
+    }
+
+    if (!pa_cvolume_valid(&e->volume)) {
+        pa_log_warn("Invalid volume stored in database for route %s", route);
+        goto fail;
+    }
+
+    return e;
+
+fail:
+
+    pa_xfree(data.dptr);
+    return NULL;
+}
+
+static int get_max_volume(struct userdata *u, pa_cvolume *max) {
+    datum key;
+    csvolume v;
+
+    pa_assert(max);
+
+    csvolume_init(&v);
+    key = gdbm_firstkey(u->gdbm_file);
+    while (key.dptr) {
+        datum next_key;
+        struct entry *e;
+        char *name;
+        unsigned i;
+
+        next_key = gdbm_nextkey(u->gdbm_file, key);
+
+        name = pa_xstrndup(key.dptr, key.dsize);
+        pa_xfree(key.dptr);
+
+        if (!_ignore_rule_hack(name)
+            && (e = read_entry(u, name))) {
+            if (!e->volume_valid)
+                goto skip;
+            for (i = 0; i < v.channels; ++i)
+                if (e->volume.values[i] > v.values[i])
+                    v.values[i] = e->volume.values[i];
+            if (e->volume.channels > v.channels)
+                v.channels = e->volume.channels;
+            for (; i < v.channels; ++i)
+                v.values[i] = e->volume.values[i];
+        skip:
+            pa_xfree(e);
+        }
+
+        pa_xfree(name);
+
+        key = next_key;
+    }
+
+    csvolume_to_cvolume(&v, max);
+    return 1;
+}
+
+static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
+    struct route_entry* e;
+    const char *route;
+    char t[256];
+    csvolume d;
+
+    pa_assert(u);
+    pa_assert(s);
+
+    route = pa_proplist_gets(s->proplist, "x-maemo.mode");
+    if (!route || (u->route && pa_streq(route, u->route)))
+        return PA_HOOK_OK;
+
+    pa_xfree(u->route);
+    u->route = pa_xstrdup(route);
+
+    e = read_route_entry(u, u->route);
+    if (!e || !pa_cvolume_valid(&e->volume))
+        goto end;
+
+    if (!pa_cvolume_valid(&u->route_volume)) {
+        /* get current route volume */
+        get_max_volume(u, &u->route_volume);
+        if (!pa_cvolume_valid(&u->route_volume))
+            goto end;
+    }
+
+    /* scale stream-restore rules: d is amount of volume change to apply on all rules */
+    csvolume_substract_cvolume(&d, &e->volume, &u->route_volume);
+    u->route_volume = e->volume;
+    pa_log_debug("Updated route volume=%s (diff %d)", pa_cvolume_snprint(t, sizeof(t), &u->route_volume), d.values[0]);
+
+    {
+        datum key;
+        pa_cvolume v;
+
+        pa_cvolume_init(&v);
+        key = gdbm_firstkey(u->gdbm_file);
+        while (key.dptr) {
+            datum next_key;
+            struct entry entry, *old;
+            char *name;
+
+            next_key = gdbm_nextkey(u->gdbm_file, key);
+
+            name = pa_xstrndup(key.dptr, key.dsize);
+            pa_xfree(key.dptr);
+
+            old = NULL;
+            if (!_ignore_rule_hack(name) &&
+                (old = read_entry(u, name))) {
+                entry = *old;
+
+                if (!csvolume_valid(&entry.volume))
+                    goto skip;
+
+                /* now do update the volume for this rule */
+                csvolume_add(&entry.volume, &d);
+
+                if (!entries_equal(old, &entry)) {
+                    datum data;
+
+                    key.dptr = name;
+                    key.dsize = (int) strlen(name);
+
+                    data.dptr = (void*) &entry;
+                    data.dsize = sizeof(entry);
+                    if (gdbm_store(u->gdbm_file, key, data, GDBM_REPLACE) == 0)
+                        apply_entry(u, name, &entry);
+                }
+            }
+
+        skip:
+            pa_xfree(old);
+            pa_xfree(name);
+            key = next_key;
+        }
+
+        trigger_save(u);
+    }
+
+end:
+    if (e)
+        pa_xfree(e);
+    return PA_HOOK_OK;
+}
+
 static void save_time_callback(pa_mainloop_api*a, pa_time_event* e, pa_usec_t t, void *userdata) {
     struct userdata *u = userdata;
 
@@ -132,6 +469,8 @@ static void save_time_callback(pa_mainloop_api*a, pa_time_event* e, pa_usec_t t,
     u->save_time_event = NULL;
 
     gdbm_sync(u->gdbm_file);
+    gdbm_sync(u->gdbm_route_file);
+
     pa_log_info("Synced.");
 }
 
@@ -204,7 +543,7 @@ static struct entry* read_entry(struct userdata *u, const char *name) {
         goto fail;
     }
 
-    if (e->volume_valid && (!pa_cvolume_valid(&e->volume) || !pa_cvolume_compatible_with_channel_map(&e->volume, &e->channel_map))) {
+    if (e->volume_valid && (!csvolume_valid(&e->volume) || !csvolume_compatible_with_channel_map(&e->volume, &e->channel_map))) {
         pa_log_warn("Invalid volume stored in database for stream %s", name);
         goto fail;
     }
@@ -220,6 +559,7 @@ fail:
 static void trigger_save(struct userdata *u) {
     pa_native_connection *c;
     uint32_t idx;
+    pa_cvolume v;
 
     for (c = pa_idxset_first(u->subscribed, &idx); c; c = pa_idxset_next(u->subscribed, &idx)) {
         pa_tagstruct *t;
@@ -234,6 +574,34 @@ static void trigger_save(struct userdata *u) {
         pa_pstream_send_tagstruct(pa_native_connection_get_pstream(c), t);
     }
 
+    if (!u->route)
+        goto end;
+
+    get_max_volume(u, &v);
+    if (!pa_cvolume_valid(&v))
+        goto end;
+
+    if (!pa_cvolume_valid(&u->route_volume) ||
+        !pa_cvolume_equal(&v, &u->route_volume)) {
+        struct route_entry entry;
+        datum key, data;
+        char t[256];
+
+        u->route_volume = v;
+        memset(&entry, 0, sizeof(entry));
+        entry.version = ROUTE_ENTRY_VERSION;
+        entry.volume = u->route_volume;
+        pa_log_debug("Route volume=%s", pa_cvolume_snprint(t, sizeof(t), &u->route_volume));
+        key.dptr = (void*) u->route;
+        key.dsize = (int) strlen(u->route);
+
+        data.dptr = (void*) &entry;
+        data.dsize = sizeof(entry);
+
+        gdbm_store(u->gdbm_route_file, key, data, GDBM_REPLACE);
+    }
+
+end:
     if (u->save_time_event)
         return;
 
@@ -241,7 +609,6 @@ static void trigger_save(struct userdata *u) {
 }
 
 static pa_bool_t entries_equal(const struct entry *a, const struct entry *b) {
-    pa_cvolume t;
 
     pa_assert(a);
     pa_assert(b);
@@ -258,9 +625,10 @@ static pa_bool_t entries_equal(const struct entry *a, const struct entry *b) {
         (a->volume_is_absolute_valid && (a->volume_is_absolute != b->volume_is_absolute)))
         return FALSE;
 
-    t = b->volume;
-    if (a->volume_valid != b->volume_valid ||
-        (a->volume_valid && !pa_cvolume_equal(pa_cvolume_remap(&t, &b->channel_map, &a->channel_map), &a->volume)))
+    if (a->volume_valid != b->volume_valid)
+        return FALSE;
+
+    if (a->volume_valid && !csvolume_equal(&a->volume, &b->volume))
         return FALSE;
 
     return TRUE;
@@ -297,8 +665,10 @@ static void subscribe_callback(pa_core *c, pa_subscription_event_type_t t, uint3
             entry = *old;
 
         if (sink_input->save_volume) {
+            pa_cvolume v;
             entry.channel_map = sink_input->channel_map;
-            pa_sink_input_get_volume(sink_input, &entry.volume, entry.volume_is_absolute);
+            pa_sink_input_get_volume(sink_input, &v, entry.volume_is_absolute);
+            csvolume_from_cvolume(&entry.volume, &v);
             entry.volume_valid = TRUE;
         }
 
@@ -413,7 +783,7 @@ static pa_hook_result_t sink_input_fixate_hook_callback(pa_core *c, pa_sink_inpu
                 pa_cvolume v;
 
                 pa_log_info("Restoring volume for sink input %s.", name);
-                v = e->volume;
+                csvolume_to_cvolume(&e->volume, &v);
                 pa_cvolume_remap(&v, &e->channel_map, &new_data->channel_map);
                 pa_sink_input_new_data_set_volume(new_data, &v);
 
@@ -550,7 +920,7 @@ static int fill_db(struct userdata *u, const char *filename) {
             memset(&e, 0, sizeof(e));
             e.version = ENTRY_VERSION;
             e.volume_valid = TRUE;
-            pa_cvolume_set(&e.volume, 1, pa_sw_volume_from_dB(db));
+            csvolume_set(&e.volume, 1, pa_sw_volume_from_dB(db));
             pa_channel_map_init_mono(&e.channel_map);
             e.volume_is_absolute = TRUE;
             e.volume_is_absolute_valid = TRUE;
@@ -606,9 +976,8 @@ static void apply_entry(struct userdata *u, const char *name, struct entry *e) {
         if (u->restore_volume && e->volume_valid) {
             pa_cvolume v;
 
-            v = e->volume;
             pa_log_info("Restoring volume for sink input %s.", name);
-            pa_sink_input_set_volume(si, pa_cvolume_remap(&v, &e->channel_map, &si->channel_map), TRUE, e->volume_is_absolute);
+            pa_sink_input_set_volume(si, pa_cvolume_remap(csvolume_to_cvolume(&e->volume, &v), &e->channel_map, &si->channel_map), TRUE, e->volume_is_absolute);
         }
 
         if (u->restore_muted && e->muted_valid) {
@@ -731,7 +1100,7 @@ static int extension_cb(pa_native_protocol *p, pa_module *m, pa_native_connectio
 
                     pa_tagstruct_puts(reply, name);
                     pa_tagstruct_put_channel_map(reply, e->volume_valid ? &e->channel_map : pa_channel_map_init(&cm));
-                    pa_tagstruct_put_cvolume(reply, e->volume_valid ? &e->volume : pa_cvolume_init(&r));
+                    pa_tagstruct_put_cvolume(reply, e->volume_valid ? csvolume_to_cvolume(&e->volume, &r) : pa_cvolume_init(&r));
                     pa_tagstruct_puts(reply, e->device_valid ? e->device : NULL);
                     pa_tagstruct_put_boolean(reply, e->muted_valid ? e->muted : FALSE);
                     if (pa_native_connection_extension_supported(c, "stream-restore-2"))
@@ -769,6 +1138,7 @@ static int extension_cb(pa_native_protocol *p, pa_module *m, pa_native_connectio
                 pa_bool_t muted, volume_is_absolute;
                 struct entry entry;
                 datum key, data;
+                pa_cvolume r;
                 int k;
 
                 memset(&entry, 0, sizeof(entry));
@@ -776,11 +1146,13 @@ static int extension_cb(pa_native_protocol *p, pa_module *m, pa_native_connectio
 
                 if (pa_tagstruct_gets(t, &name) < 0 ||
                     pa_tagstruct_get_channel_map(t, &entry.channel_map) ||
-                    pa_tagstruct_get_cvolume(t, &entry.volume) < 0 ||
+                    pa_tagstruct_get_cvolume(t, &r) < 0 ||
                     pa_tagstruct_gets(t, &device) < 0 ||
                     pa_tagstruct_get_boolean(t, &muted) < 0)
                     goto fail;
 
+                csvolume_from_cvolume(&entry.volume, &r);
+
                 if (pa_native_connection_extension_supported(c, "stream-restore-2")) {
                     if (pa_tagstruct_get_boolean(t, &volume_is_absolute) < 0)
                         goto fail;
@@ -795,7 +1167,7 @@ static int extension_cb(pa_native_protocol *p, pa_module *m, pa_native_connectio
                 entry.volume_valid = entry.volume.channels > 0;
 
                 if (entry.volume_valid)
-                    if (!pa_cvolume_compatible_with_channel_map(&entry.volume, &entry.channel_map))
+                    if (!pa_cvolume_compatible_with_channel_map(&r, &entry.channel_map))
                         goto fail;
 
                 entry.muted = muted;
@@ -937,6 +1309,9 @@ int pa__init(pa_module*m) {
     if (restore_volume || restore_muted)
         u->sink_input_fixate_hook_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_INPUT_FIXATE], PA_HOOK_EARLY, (pa_hook_cb_t) sink_input_fixate_hook_callback, u);
 
+    u->sink_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_PROPLIST_CHANGED], PA_HOOK_LATE, (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
+    u->route = NULL;
+
     /* We include the host identifier in the file name because gdbm
      * files are CPU dependant, and we don't want things to go wrong
      * if we are on a multiarch system. */
@@ -964,6 +1339,26 @@ int pa__init(pa_module*m) {
     if (fill_db(u, pa_modargs_get_value(ma, "fallback_table", NULL)) < 0)
         goto fail;
 
+    fn = pa_sprintf_malloc("x-maemo-route-volumes."CANONICAL_HOST".gdbm");
+    fname = pa_state_path(fn, TRUE);
+    pa_xfree(fn);
+
+    if (!fname)
+        goto fail;
+
+    if (!(u->gdbm_route_file = gdbm_open(fname, 0, GDBM_WRCREAT|GDBM_NOLOCK, 0600, NULL))) {
+        pa_log("Failed to open volume database '%s': %s", fname, gdbm_strerror(gdbm_errno));
+        pa_xfree(fname);
+        goto fail;
+    }
+
+    /* By default the cache of gdbm is rather large, let's reduce it a bit to save memory */
+    gdbm_cache_size = 10;
+    gdbm_setopt(u->gdbm_route_file, GDBM_CACHESIZE, &gdbm_cache_size, sizeof(gdbm_cache_size));
+
+    pa_log_info("Sucessfully opened database file '%s'.", fname);
+    pa_xfree(fname);
+
     for (si = pa_idxset_first(m->core->sink_inputs, &idx); si; si = pa_idxset_next(m->core->sink_inputs, &idx))
         subscribe_callback(m->core, PA_SUBSCRIPTION_EVENT_SINK_INPUT|PA_SUBSCRIPTION_EVENT_NEW|PA_SUBSCRIPTION_EVENT_CHANGE, si->index, u);
 
@@ -999,6 +1394,8 @@ void pa__done(pa_module*m) {
         pa_hook_slot_free(u->sink_input_fixate_hook_slot);
     if (u->source_output_new_hook_slot)
         pa_hook_slot_free(u->source_output_new_hook_slot);
+    if (u->sink_proplist_changed_slot)
+        pa_hook_slot_free(u->sink_proplist_changed_slot);
 
     if (u->connection_unlink_hook_slot)
         pa_hook_slot_free(u->connection_unlink_hook_slot);
@@ -1009,6 +1406,9 @@ void pa__done(pa_module*m) {
     if (u->gdbm_file)
         gdbm_close(u->gdbm_file);
 
+    if (u->gdbm_route_file)
+        gdbm_close(u->gdbm_route_file);
+
     if (u->protocol) {
         pa_native_protocol_remove_ext(u->protocol, m);
         pa_native_protocol_unref(u->protocol);
@@ -1017,5 +1417,6 @@ void pa__done(pa_module*m) {
     if (u->subscribed)
         pa_idxset_free(u->subscribed, NULL, NULL);
 
+    pa_xfree(u->route);
     pa_xfree(u);
 }
-- 
1.6.3.1

