From 15399f32400e2a21124da713a07c9f3e9faecad5 Mon Sep 17 00:00:00 2001
From: Juho Hamalainen <ext-juho.hamalainen@nokia.com>
Date: Fri, 6 Mar 2009 11:47:26 +0200
Subject: [PATCH 22/49] alsa-sink-volume: - update sw volume based on hw request and get.
                   - bug fixing and cleaning

---
 src/modules/alsa/module-alsa-sink-volume.c |  174 +++++++++++++++-------------
 1 files changed, 93 insertions(+), 81 deletions(-)

diff --git a/src/modules/alsa/module-alsa-sink-volume.c b/src/modules/alsa/module-alsa-sink-volume.c
index e884740..63b7322 100644
--- a/src/modules/alsa/module-alsa-sink-volume.c
+++ b/src/modules/alsa/module-alsa-sink-volume.c
@@ -69,13 +69,6 @@ PA_MODULE_USAGE(
         "ignore_dB=<ignore dB info from ALSA>");
 
 
-struct gain_step_t {
-    int step;
-    pa_bool_t enabled;
-    pa_volume_t volume;
-    PA_LLIST_FIELDS(struct gain_step_t);
-};
-
 struct mixer_control_t {
     char *name;
     pa_alsa_fdlist *mixer_fdl;
@@ -91,7 +84,8 @@ struct mixer_control_t {
     pa_bool_t mixer_separate_channels;
     pa_cvolume hardware_volume;
 
-    PA_LLIST_HEAD(struct gain_step_t, gain_step);
+    long *gain_step;
+    int gain_step_count;
     struct mixer_control_t **slaves;
     pa_bool_t slave;
 
@@ -102,6 +96,9 @@ struct mixer_control_t {
     PA_LLIST_FIELDS(struct mixer_control_t);
 };
 
+#define MAX_VALUE_STEPS (256)
+#define MAX_MIXER_COUNT (16)
+
 struct userdata {
     pa_core *core;
     pa_module *module;
@@ -120,6 +117,10 @@ struct userdata {
     PA_LLIST_HEAD(struct mixer_control_t, mixer_list);
     struct mixer_control_t *active_mixer;
 
+    /* gain step cache */
+    pa_bool_t gain_step_enabled;
+    int gain_step_pos;
+
     /* store mixer volumes */
     GDBM_FILE gdbm_file;
     pa_bool_t cache_volumes;
@@ -269,28 +270,27 @@ static void sink_get_volume_cb(pa_sink *s) {
 }
 
 
-static long update_alsa_volume(struct mixer_control_t *m, long alsa_vol) {
+static long update_alsa_volume(struct userdata *u, struct mixer_control_t *m, long alsa_vol) {
 
-    struct gain_step_t *g;
     long vol = alsa_vol;
     int step = 0;
     int i;
-    int step_count = 0;
 
-    for (g = m->gain_step; g; g = g->next)
-        step_count++;
+    pa_log("update alsa volume for mixer %s, step count %d", m->name, m->gain_step_count);
 
-    pa_log("update alsa volume for mixer %s, step count %d", m->name, step_count);
+    if (u->gain_step_pos >= 0)
+        goto ready;
 
     if (m->hw_dB_supported) {
-    pa_log("min %d max %d alsa_vol %ld", m->hw_dB_min, m->hw_dB_max, alsa_vol);
-        step = ((-m->hw_dB_max) + (-m->hw_dB_min)) / step_count;
+        pa_log("min %ld max %ld alsa_vol %ld", m->hw_dB_min, m->hw_dB_max, alsa_vol);
+        step = ((-m->hw_dB_max) + (-m->hw_dB_min)) / m->gain_step_count;
         step = (-alsa_vol)/step;
         if (step < 0)
             step = -step;
+        step = m->gain_step_count - step;
 
     } else {
-        step = (m->hw_volume_max - m->hw_volume_min) / step_count;
+        step = (m->hw_volume_max - m->hw_volume_min) / m->gain_step_count;
         step = alsa_vol/step;
     }
 
@@ -298,21 +298,14 @@ static long update_alsa_volume(struct mixer_control_t *m, long alsa_vol) {
 
     if (step < 0)
         step = 0;
-    if (step >= step_count)
-        step = step_count-1;
-
-    if (step == 0)
-        vol = m->gain_step->volume;
-    else {
-        i = 1;
-        for (g = m->gain_step->next; g; g = g->next) {
-            if (step == i) {
-                vol = g->volume;
-                break;
-            }
-            i++;
-        }
-    }
+    if (step >= m->gain_step_count)
+        step = m->gain_step_count-1;
+
+    if (u->gain_step_pos < 0)
+        u->gain_step_pos = step;
+
+ready:
+    vol = m->gain_step[u->gain_step_pos];
 
     pa_log("update alsa vol from %ld to %ld", alsa_vol, vol);
 
@@ -321,10 +314,15 @@ static long update_alsa_volume(struct mixer_control_t *m, long alsa_vol) {
     return 0;
 }
 
-static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m, pa_cvolume *vv) {
+static int set_alsa_mixer_volumes(struct userdata *u,
+                                  struct mixer_control_t *m,
+                                  pa_cvolume *vv,
+                                  const pa_bool_t update_sw_volume,
+                                  const pa_bool_t enable_vol_update) {
     int err;
     unsigned i;
     pa_cvolume r;
+    pa_cvolume fixed;
 
     pa_assert(u);
     pa_assert(m->mixer_elem);
@@ -332,6 +330,7 @@ static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m,
     if (m->mixer_separate_channels) {
 
         r.channels = u->sink->sample_spec.channels;
+        fixed.channels = u->sink->sample_spec.channels;
 
         for (i = 0; i < u->sink->sample_spec.channels; i++) {
             long alsa_vol;
@@ -345,8 +344,10 @@ static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m,
                 alsa_vol += m->hw_dB_max;
                 alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, m->hw_dB_min, m->hw_dB_max);
 
-                if (m->gain_step)
-                    alsa_vol = update_alsa_volume(m, alsa_vol);
+                if (m->gain_step && enable_vol_update) {
+                    alsa_vol = update_alsa_volume(u, m, alsa_vol);
+                    fixed.values[i] = pa_sw_volume_from_dB((double) (alsa_vol - m->hw_dB_max) / 100.0);
+                }
 
                 if ((err = snd_mixer_selem_set_playback_dB(m->mixer_elem, m->mixer_map[i], alsa_vol, 1)) < 0)
                     goto fail;
@@ -363,8 +364,8 @@ static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m,
             } else {
                 alsa_vol = to_alsa_volume(u, vol);
 
-                if (m->gain_step)
-                    alsa_vol = update_alsa_volume(m, alsa_vol);
+                if (m->gain_step && enable_vol_update)
+                    alsa_vol = update_alsa_volume(u, m, alsa_vol);
 
                 if ((err = snd_mixer_selem_set_playback_volume(m->mixer_elem, m->mixer_map[i], alsa_vol)) < 0)
                     goto fail;
@@ -387,8 +388,10 @@ static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m,
             alsa_vol += m->hw_dB_max;
             alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, m->hw_dB_min, m->hw_dB_max);
 
-            if (m->gain_step)
-                alsa_vol = update_alsa_volume(m, alsa_vol);
+            if (m->gain_step && enable_vol_update) {
+                alsa_vol = update_alsa_volume(u, m, alsa_vol);
+                pa_cvolume_set(&fixed, u->sink->sample_spec.channels, pa_sw_volume_from_dB((double) (alsa_vol - m->hw_dB_max) / 100.0));
+            }
 
             if ((err = snd_mixer_selem_set_playback_dB_all(m->mixer_elem, alsa_vol, 1)) < 0)
                 goto fail;
@@ -405,8 +408,8 @@ static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m,
         } else {
             alsa_vol = to_alsa_volume(u, vol);
 
-            if (m->gain_step)
-                alsa_vol = update_alsa_volume(m, alsa_vol);
+            if (m->gain_step && enable_vol_update)
+                alsa_vol = update_alsa_volume(u, m, alsa_vol);
 
             if ((err = snd_mixer_selem_set_playback_volume_all(m->mixer_elem, alsa_vol)) < 0)
                 goto fail;
@@ -423,12 +426,22 @@ static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m,
     if (m->hw_dB_supported) {
         char t[PA_CVOLUME_SNPRINT_MAX];
 
-        /* Match exactly what the user requested by software */
-        pa_sw_cvolume_divide(&u->sink->soft_volume, vv, &m->hardware_volume);
+        if (update_sw_volume) {
+            /* Match exactly what the user requested by software */
+            if (m->gain_step && enable_vol_update)
+                pa_sw_cvolume_divide(&u->sink->soft_volume, &fixed, &m->hardware_volume);
+            else
+                pa_sw_cvolume_divide(&u->sink->soft_volume, vv, &m->hardware_volume);
+        }
 
         pa_log_debug("Requested volume: %s", pa_cvolume_snprint(t, sizeof(t), vv));
+        if (m->gain_step && enable_vol_update)
+            pa_log_debug("Fixed requested volume: %s", pa_cvolume_snprint(t, sizeof(t), &fixed));
         pa_log_debug("Got hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &m->hardware_volume));
-        pa_log_debug("Calculated software volume: %s", pa_cvolume_snprint(t, sizeof(t), &u->sink->soft_volume));
+        if (update_sw_volume)
+            pa_log_debug("Calculated software volume: %s", pa_cvolume_snprint(t, sizeof(t), &u->sink->soft_volume));
+        else
+            pa_log_debug("Skip software volume calculation");
 
     } else
 
@@ -454,17 +467,20 @@ static void sink_set_volume_cb(pa_sink *s) {
         return;
     }
 
+    /* reset cached gain step position */
+    u->gain_step_pos = -1;
+
     if (u->active_mixer->slaves) {
         int i;
         pa_log("SET SLAVE VOLUMES");
         for (i = 0; u->active_mixer->slaves[i]; i++) {
             pa_log("slave %s", u->active_mixer->slaves[i]->name);
-            set_alsa_mixer_volumes(u, u->active_mixer->slaves[i], &s->virtual_volume);
+            set_alsa_mixer_volumes(u, u->active_mixer->slaves[i], &s->virtual_volume, FALSE, TRUE);
         }
     }
 
     pa_log("control volumes %s", u->active_mixer->name);
-    if (set_alsa_mixer_volumes(u, u->active_mixer, &s->virtual_volume)) {
+    if (set_alsa_mixer_volumes(u, u->active_mixer, &s->virtual_volume, TRUE, TRUE)) {
         s->get_volume = NULL;
         s->set_volume = NULL;
     }
@@ -700,14 +716,11 @@ static int get_mixer_elements(struct userdata *u, const char *mixer_list) {
 }
 
 static void clear_gain_steps(struct mixer_control_t *m) {
-    struct gain_step_t *g;
     pa_log("clear_gain_steps");
-    while ((g = m->gain_step)) {
-        pa_log("free");
-        PA_LLIST_REMOVE(struct gain_step_t, m->gain_step, g);
-        pa_xfree(g);
+    if (m->gain_step) {
+        pa_xfree(m->gain_step);
+        m->gain_step = NULL;
     }
-    pa_log("done");
 }
 
 static void free_mixer_element(struct mixer_control_t *m) {
@@ -748,7 +761,6 @@ static void my_split(const char *src, const char *separator, char **left, char *
     }
 }
 
-#define MAX_MIXER_COUNT (16)
 static int mixers_from_str(struct userdata *u, struct mixer_control_t **mixers, const char *list_str) {
     struct mixer_control_t *m;
     const char *state = NULL;
@@ -770,9 +782,7 @@ static int mixers_from_str(struct userdata *u, struct mixer_control_t **mixers,
     return mixer_count;
 }
 
-static int levels(struct userdata *u, struct mixer_control_t **mixers, const char *mixer_values) {
-    struct gain_step_t *g;
-    struct gain_step_t *last = NULL;
+static int single_mixer_levels(struct userdata *u, struct mixer_control_t **mixers, const char *mixer_values, const int step) {
     const char *state = NULL;
     int ret = 0;
     char *str;
@@ -782,25 +792,19 @@ static int levels(struct userdata *u, struct mixer_control_t **mixers, const cha
     pa_log("LEVELS %s", mixer_values);
 
     for (i = 0; mixers[i]; i++) {
-        if (!last)
-            last = mixers[i]->gain_step;
         str = pa_split(mixer_values, ",", &state);
         pa_log("STR: %s", str);
-        g = pa_xnew0(struct gain_step_t, 1);
-        PA_LLIST_INIT(struct gain_step_t, g);
-        g->enabled = FALSE;
-//        PA_LLIST_INSERT_AFTER(struct gain_step_t, mixers[i]->gain_step, last, g);
-//        last = g;
-        PA_LLIST_PREPEND(struct gain_step_t, mixers[i]->gain_step, g);
 
         if (str) {
             if (pa_atoi(str, &vol) == 0) {
-                g->enabled = TRUE;
-                g->volume = (pa_volume_t)vol;
-                pa_log("%s set %d: %ld", mixers[i]->name, i, vol);
+                mixers[i]->gain_step[step] = vol;
+                pa_log("%s set %d: %d", mixers[i]->name, i, vol);
             }
 
             pa_xfree(str);
+        } else {
+            if (step > 0)
+                mixers[i]->gain_step[step] = mixers[i]->gain_step[step-1];
         }
     }
 
@@ -811,50 +815,58 @@ static int mixer_levels_from_str(struct userdata *u, struct mixer_control_t **mi
     const char *state = NULL;
     int ret = 0;
     char *str;
+    int step = 0;
     int i;
 
     pa_log("mixer levels from str %s", mixer_values);
 
     while ((str = pa_split(mixer_values, "|", &state))) {
         if (str) {
-            levels(u, mixers, str);
+            single_mixer_levels(u, mixers, str, step);
             pa_xfree(str);
+            step++;
         }
+        if (step == MAX_VALUE_STEPS)
+            break;
     }
 
+    for (i = 0; mixers[i]; i++)
+        mixers[i]->gain_step_count = step;
+
     return ret;
 }
 
 static int update_mixer_gain_steps(struct userdata *u, const char *step_list) {
+    struct mixer_control_t *m;
     struct mixer_control_t **mixers;
-    struct gain_step_t *g;
     const char *state = NULL;
     char *str;
     char *mixer_list = NULL;
     char *mixer_values = NULL;
     int mixer_count = 0;
+    int i;
 
     my_split(step_list, "#", &mixer_list, &mixer_values);
 
     if (mixer_list && mixer_values) {
+        /* clear all previous steps from all mixers */
+        for (m = u->mixer_list; m; m = m->next)
+            clear_gain_steps(m);
+
         mixers = pa_xmalloc0(sizeof(struct mixer_control_t*) * (MAX_MIXER_COUNT+1));
         mixer_count = mixers_from_str(u, mixers, mixer_list);
 
-        if (mixers[0] != NULL) {
-            int i;
-            for (i = 0; mixers[i]; i++) {
-                pa_log("mixer[%d] %s", i, mixers[i]->name);
-
-                clear_gain_steps(mixers[i]);
-            }
+        for (i = 0; mixers[i]; i++) {
+            pa_log("mixer[%d] %s", i, mixers[i]->name);
+            mixers[i]->gain_step = pa_xmalloc0(sizeof(long)*(MAX_VALUE_STEPS+1));
         }
 
         if (mixer_count > 0) {
             mixer_levels_from_str(u, mixers, mixer_values);
         }
-    }
 
-    pa_xfree(mixers);
+        pa_xfree(mixers);
+    }
 
     return mixer_count;
 }
@@ -891,7 +903,7 @@ static int set_mixer_value(struct userdata *u, const char *value_str) {
                     set_vol(&vol, u->sink->channel_map.channels, pa_sw_volume_from_dB(m->hw_dB_min));
                 else
                     set_vol(&vol, u->sink->channel_map.channels, from_alsa_volume(u, m->hw_volume_min));
-                set_alsa_mixer_volumes(u, m, &vol);
+                set_alsa_mixer_volumes(u, m, &vol, FALSE, FALSE);
             }
         } else if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_MAX) == 0) {
             m = get_mixer_elem_by_name(u, mixer);
@@ -902,7 +914,7 @@ static int set_mixer_value(struct userdata *u, const char *value_str) {
                     set_vol(&vol, u->sink->channel_map.channels, pa_sw_volume_from_dB(- m->hw_dB_max/100.0));
                 else
                     set_vol(&vol, u->sink->channel_map.channels, from_alsa_volume(u, m->hw_volume_max));
-                set_alsa_mixer_volumes(u, m, &vol);
+                set_alsa_mixer_volumes(u, m, &vol, FALSE, FALSE);
             }
         } else if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_CONTROL) == 0) {
             pa_log_info("%s: set mixer %s active", u->device_name, mixer);
@@ -1237,7 +1249,7 @@ static void store_mixer_volumes(struct userdata *u) {
         } else {
             /* set mixer levels to cache levels */
             set_mixer_elem_by_name(u, m->name);
-            set_alsa_mixer_volumes(u, m, &m->cache_volume);
+            set_alsa_mixer_volumes(u, m, &m->cache_volume, FALSE, FALSE);
         }
     }
 
-- 
1.6.2.rc1.13.gfd76c.dirty

