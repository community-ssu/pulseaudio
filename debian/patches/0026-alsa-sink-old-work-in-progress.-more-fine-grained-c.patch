From 0ce081cbad8face06aadd11ffbc48180bdda0fde Mon Sep 17 00:00:00 2001
From: Juho Hamalainen <ext-juho.hamalainen@nokia.com>
Date: Tue, 3 Mar 2009 13:58:09 +0200
Subject: [PATCH 26/30] alsa-sink-old: work in progress. more fine-grained control of mixer states from proplist.

---
 src/modules/alsa/module-alsa-sink-old.c |  232 ++++++++++++++++++++++++-------
 src/modules/alsa/module-alsa-sink-old.h |   15 ++-
 2 files changed, 197 insertions(+), 50 deletions(-)

diff --git a/src/modules/alsa/module-alsa-sink-old.c b/src/modules/alsa/module-alsa-sink-old.c
index 452b2d9..a48649c 100644
--- a/src/modules/alsa/module-alsa-sink-old.c
+++ b/src/modules/alsa/module-alsa-sink-old.c
@@ -1037,67 +1037,71 @@ static void mute_all_mixers(struct userdata *u) {
     }
 }
 
-static int set_mixer_elem_by_name(struct userdata *u, const char *mixer) {
-    pa_bool_t found = FALSE;
+static struct mixer_control_t* get_mixer_elem_by_name(struct userdata *u, const char *mixer) {
     struct mixer_control_t *m = NULL;
 
     for (m = u->mixer_list; m; m = m->next) {
-        if (strcmp(mixer, m->name) == 0) {
+        if (strcmp(mixer, m->name) == 0)
+            return m;
+    }
 
-            if (m == u->active_mixer) {
-                pa_log_debug("%s: requested mixer already active.", u->device_name);
-                found = TRUE;
-                break;
-            }
+    return NULL;
+}
 
-            pa_log_info("%s: setting active mixer to %s", u->device_name, m->name);
+static int set_mixer_elem_by_name(struct userdata *u, const char *mixer) {
+    pa_bool_t found = FALSE;
+    struct mixer_control_t *m = NULL;
 
-            u->sink->flags = SINK_DEFAULT_FLAGS;
+    m = get_mixer_elem_by_name(u, mixer);
 
-            if (m->hw_volume_control) {
-                if (m->hw_dB_supported) {
-                    if (m->hw_dB_max > 0) {
-                        u->sink->base_volume = pa_sw_volume_from_dB(- (double) m->hw_dB_max/100.0);
-                        pa_log_info("Fixing base volume to %0.2f dB", pa_sw_volume_to_dB(u->sink->base_volume));
-                    } else
-                        pa_log_info("No particular base volume set, fixing to 0 dB");
-                }
-                u->sink->get_volume = sink_get_volume_cb;
-                u->sink->set_volume = sink_set_volume_cb;
+    if (!m) {
+        pa_log_info("%s: no preloaded mixer %s found", u->device_name, mixer);
+        return 1;
+    }
 
-                u->sink->flags |= PA_SINK_HW_VOLUME_CTRL | (m->hw_dB_supported ? PA_SINK_DECIBEL_VOLUME : 0);
-                pa_log_info("Using hardware volume control. Hardware dB scale %s.", m->hw_dB_supported ? "supported" : "not supported");
+    if (m == u->active_mixer) {
+        pa_log_debug("%s: requested mixer already active.", u->device_name);
+        return 0;
+    }
 
-                if (!m->hw_dB_supported)
-                    u->sink->n_volume_steps = m->hw_volume_max - m->hw_volume_min + 1;
-            } else {
-                u->sink->get_volume = NULL;
-                u->sink->set_volume = NULL;
-                pa_log_info("Using software volume control.");
-            }
+    pa_log_info("%s: setting active mixer to %s", u->device_name, m->name);
 
-        if (snd_mixer_selem_has_playback_switch(m->mixer_elem)) {
-            u->sink->get_mute = sink_get_mute_cb;
-            u->sink->set_mute = sink_set_mute_cb;
-            u->sink->flags |= PA_SINK_HW_MUTE_CTRL;
-        } else {
-            u->sink->get_mute = NULL;
-            u->sink->set_mute = NULL;
-            pa_log_info("Using software mute control.");
-        }
+    u->sink->flags = SINK_DEFAULT_FLAGS;
 
-            u->active_mixer = m;
-            found = TRUE;
-            break;
+    if (m->hw_volume_control) {
+        if (m->hw_dB_supported) {
+            if (m->hw_dB_max > 0) {
+                u->sink->base_volume = pa_sw_volume_from_dB(- (double) m->hw_dB_max/100.0);
+                pa_log_info("Fixing base volume to %0.2f dB", pa_sw_volume_to_dB(u->sink->base_volume));
+            } else
+                pa_log_info("No particular base volume set, fixing to 0 dB");
         }
+        u->sink->get_volume = sink_get_volume_cb;
+        u->sink->set_volume = sink_set_volume_cb;
+
+        u->sink->flags |= PA_SINK_HW_VOLUME_CTRL | (m->hw_dB_supported ? PA_SINK_DECIBEL_VOLUME : 0);
+        pa_log_info("Using hardware volume control. Hardware dB scale %s.", m->hw_dB_supported ? "supported" : "not supported");
+
+        if (!m->hw_dB_supported)
+            u->sink->n_volume_steps = m->hw_volume_max - m->hw_volume_min + 1;
+    } else {
+        u->sink->get_volume = NULL;
+        u->sink->set_volume = NULL;
+        pa_log_info("Using software volume control.");
     }
 
-    if (found) {
-        return 0;
+    if (snd_mixer_selem_has_playback_switch(m->mixer_elem)) {
+        u->sink->get_mute = sink_get_mute_cb;
+        u->sink->set_mute = sink_set_mute_cb;
+        u->sink->flags |= PA_SINK_HW_MUTE_CTRL;
     } else {
-        pa_log_info("%s: no preloaded mixer %s found", u->device_name, mixer);
-        return 1;
+        u->sink->get_mute = NULL;
+        u->sink->set_mute = NULL;
+        pa_log_info("Using software mute control.");
     }
+
+    u->active_mixer = m;
+    return 0;
 }
 
 
@@ -1308,6 +1312,7 @@ static int update_mixer_gain_steps(struct userdata *u,
     return 1;
 }
 
+#if 0 /* DELETE */
 static int switch_mixer(struct userdata *u, const char *mixer_str) {
     struct mixer_control_t *prev_mixer = NULL;
     int ret = 0;
@@ -1363,6 +1368,124 @@ static int switch_mixer(struct userdata *u, const char *mixer_str) {
 
     return ret;
 }
+#endif
+
+static void set_vol(pa_cvolume *vol, const int channels, pa_volume_t value) {
+    int ii;
+    vol->channels = channels;
+    for (ii = 0; ii < channels; ii++) {
+        vol->values[ii] = value;
+    }
+}
+
+static int set_mixer_value(struct userdata *u, const char *value_str) {
+    int ret = 1;
+    struct mixer_control_t *m = NULL;
+    const char *state = NULL;
+    char *str;
+    char *mixer = NULL;
+    char *value = NULL;
+    pa_cvolume vol;
+    pa_bool_t muted;
+
+    while ((str = pa_split(value_str, ":", &state))) {
+        if (str) {
+            if (!mixer)
+                mixer = pa_xstrdup(str);
+            else if (!value)
+                value = pa_xstrdup(str);
+            pa_xfree(str);
+        }
+    }
+
+    if (mixer && value) {
+        pa_log("%s: mixer %s", u->device_name, mixer);
+        pa_log("%s: value %s", u->device_name, value);
+
+        if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_OFF) == 0) {
+            pa_log("set to off");
+            m = get_mixer_elem_by_name(u, mixer);
+            if (m) {
+                if (m->hw_dB_supported)
+                    set_vol(&vol, u->sink->channel_map.channels, pa_sw_volume_from_dB(m->hw_dB_min));
+                else
+                    set_vol(&vol, u->sink->channel_map.channels, from_alsa_volume(u, m->hw_volume_min));
+                set_alsa_mixer_volumes(u, m, &vol);
+            }
+        } else if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_MAX) == 0) {
+            pa_log("set to max");
+            m = get_mixer_elem_by_name(u, mixer);
+            if (m) {
+                if (m->hw_dB_supported)
+                    set_vol(&vol, u->sink->channel_map.channels, pa_sw_volume_from_dB(m->hw_dB_max));
+                else
+                    set_vol(&vol, u->sink->channel_map.channels, from_alsa_volume(u, m->hw_volume_max));
+
+                set_alsa_mixer_volumes(u, m, &vol);
+            }
+        } else if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_CONTROL) == 0) {
+            pa_log("set to active_mixer");
+            if (set_mixer_elem_by_name(u, mixer)) {
+                /* couldn't select mixer, try to load that mixer element */
+                if (get_mixer_elements(u, mixer) > 0) {
+                    /* new mixer element loaded, try selecting again */
+                    if (set_mixer_elem_by_name(u, mixer)) {
+                        pa_log_error("%s: cannot load new mixer control %s", u->device_name, mixer);
+
+                        ret = 1;
+                    }
+                }
+            }
+
+        } /* eo strcmp*/
+
+        ret = 0;
+    }
+
+    if (mixer)
+        pa_xfree(mixer);
+    if (value)
+        pa_xfree(value);
+
+    return ret;
+}
+
+static int set_mixer_values(struct userdata *u, const char *value_list) {
+    int ret = 0;
+    const char *state = NULL;
+
+    unsigned i = 0;
+    char *value;
+    unsigned num;
+
+    /* store volumes from currently active mixer */
+    if (u->active_mixer) {
+        u->active_mixer->cache_volume = *pa_sink_get_volume(u->sink, TRUE);
+        u->active_mixer->cache_muted = pa_sink_get_mute(u->sink, TRUE);
+    }
+
+    while ((value = pa_split(value_list, ",", &state))) {
+        if (value) {
+            pa_log("%s: set_mixer_values %s", u->device_name, value);
+            set_mixer_value(u, value);
+            pa_xfree(value);
+        }
+    }
+
+    /* update previously stored volumes to sink */
+    if (u->active_mixer && u->active_mixer->cache_volume.channels > 0) {
+        pa_log("%s: update previously stored volumes", u->device_name);
+        pa_sink_set_volume(u->sink, &u->active_mixer->cache_volume, TRUE, TRUE);
+        pa_sink_set_mute(u->sink, u->active_mixer->cache_muted);
+    } else {
+        /* no previously stored volumes, update volume from hw */
+        pa_log("%s: no previously stored volumes, update volume from hw", u->device_name);
+        pa_sink_get_volume(u->sink, TRUE);
+        pa_sink_get_mute(u->sink, TRUE);
+    }
+
+    return ret;
+}
 
 static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
     const char *v = NULL;
@@ -1391,6 +1514,7 @@ static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink
         }
     }
 
+#if 0  /* DELETE */
     v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_MIXER);
     if (v) {
         if (switch_mixer(u, v)) {
@@ -1399,6 +1523,13 @@ static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink
                 pa_proplist_sets(s->proplist, PA_ALSA_SINK_PROP_MIXER, u->active_mixer->name);
         }
     }
+#endif
+
+    v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_MIXER);
+    if (v) {
+        pa_log("%s: set static mixer values", u->device_name);
+        set_mixer_values(u, v);
+    }
 
     if (u->active_mixer) {
         v = pa_proplist_gets(s->proplist, u->active_mixer->prop_mixer_gain_step_count);
@@ -1581,11 +1712,14 @@ static void load_default_mixer_volumes(struct userdata *u) {
     pa_assert(u->cache_volumes);
 
     /* set all mixers to default level */
-    pa_log_info("%s: set hw_volume_max to all mixers", u->device_name);
+    pa_log_info("%s: set hw_volume_max*0.95 to all mixers", u->device_name);
     for (m = u->mixer_list; m; m = m->next) {
         m->cache_volume.channels = u->sink->channel_map.channels;
         for (ii = 0; ii < m->cache_volume.channels; ii++)
-            m->cache_volume.values[ii] = from_alsa_volume(u, m->hw_volume_max*0.95);
+            if (m->hw_dB_supported)
+                m->cache_volume.values[ii] = pa_sw_volume_from_dB(m->hw_dB_max);
+            else
+                m->cache_volume.values[ii] = from_alsa_volume(u, m->hw_volume_max*0.95);
         m->cache_muted = FALSE;
     }
 }
@@ -1936,12 +2070,14 @@ int pa__init(pa_module*m) {
 #endif
 
     if (mixer_count > 0) {
-        if (load_mixer_volumes(u) == 0)
+        if (load_mixer_volumes(u) == 0 && u->cache_volumes)
             load_default_mixer_volumes(u);
     }
 
+    /* DELETE
     if (mixer_count > 0 && u->mixer_off_volume.channels > 0)
         mute_all_mixers(u);
+    */
 
     set_mixer_elem_by_name(u, alsa_mixer);
 
diff --git a/src/modules/alsa/module-alsa-sink-old.h b/src/modules/alsa/module-alsa-sink-old.h
index c230680..57fd7d1 100644
--- a/src/modules/alsa/module-alsa-sink-old.h
+++ b/src/modules/alsa/module-alsa-sink-old.h
@@ -1,8 +1,19 @@
 #ifndef foomodulealsasinkoldfoo
 #define foomodulealsasinkoldfoo
 
-/* Name of mixer control, PCM/Master/etc */
-#define PA_ALSA_SINK_PROP_MIXER   "x-maemo.alsa_sink.mixer"
+/* Update mixer states,
+ * max       0dB
+ * off       mute
+ * control   sink volume controlled
+ *
+ * eg. "HP DAC:max,Headphone:off,Earphone:control"
+ */
+#define PA_ALSA_SINK_PROP_MIXER         "x-maemo.alsa_sink.mixer_control"
+
+#define PA_ALSA_SINK_PROP_MIXER_OFF     "off"
+#define PA_ALSA_SINK_PROP_MIXER_MAX     "max"
+#define PA_ALSA_SINK_PROP_MIXER_CONTROL "control"
+
 /* String of comma separated numbers defining alsa volumes */
 #define PA_ALSA_SINK_PROP_MIXER_GAIN_STEP "x-maemo.alsa_sink.mixer.%s.gain_step"
 /* String containing gain step count number */
-- 
1.6.2.rc1.13.gfd76c.dirty

