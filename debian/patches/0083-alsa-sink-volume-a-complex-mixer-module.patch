From 3476436264879e2ddd0ad5914e46e3038f155a9d Mon Sep 17 00:00:00 2001
From: Maemo Multimedia <multimedia@maemo.org>
Date: Fri, 17 Apr 2009 17:09:01 +0300
Subject: [PATCH 83/85] alsa: sink-volume, a complex mixer module

volume: update delay

Revert "alsa-old: remove -30dB from HP hack"

This reverts commit 6fc36ed7865964f5ef6798e41c6eda4912f4a0b2.

volume: tune the delay a little to fix 114849

alsa-volume: Fix crash in bug #125511 pulseaudio crash

alsa-volume: plug some mem-leak and minor style change

alsa-volume: Take sync volume patch into use and clean up.

alsa-volume: Re-apply a change that was lost from 2b30bb29 in merge
---
 src/Makefile.am                                   |    9 +
 src/modules/alsa/module-alsa-sink-volume-symdef.h |   27 +
 src/modules/alsa/module-alsa-sink-volume.c        | 1461 +++++++++++++++++++++
 3 files changed, 1497 insertions(+), 0 deletions(-)
 create mode 100644 src/modules/alsa/module-alsa-sink-volume-symdef.h
 create mode 100644 src/modules/alsa/module-alsa-sink-volume.c

diff --git a/src/Makefile.am b/src/Makefile.am
index 6721335..3c8a7f5 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1003,6 +1003,9 @@ pulselibexec_PROGRAMS =
 if HAVE_ALSA
 modlibexec_LTLIBRARIES += \
 		libalsa-util.la \
+		module-alsa-sink-volume.la
+
+modlibexec_LTLIBRARIES += \
 		module-alsa-sink.la \
 		module-alsa-source.la \
 		module-alsa-card.la
@@ -1118,6 +1121,7 @@ SYMDEF_FILES = \
 		modules/module-x11-cork-request-symdef.h \
 		modules/oss/module-oss-symdef.h \
 		modules/alsa/module-alsa-sink-symdef.h \
+		modules/alsa/module-alsa-sink-volume-symdef.h \
 		modules/alsa/module-alsa-source-symdef.h \
 		modules/alsa/module-alsa-card-symdef.h \
 		modules/module-solaris-symdef.h \
@@ -1353,6 +1357,11 @@ module_alsa_sink_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_alsa_sink_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
 module_alsa_sink_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
 
+module_alsa_sink_volume_la_SOURCES = modules/alsa/module-alsa-sink-volume.c
+module_alsa_sink_volume_la_LDFLAGS = $(MODULE_LDFLAGS)
+module_alsa_sink_volume_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
+module_alsa_sink_volume_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
+
 module_alsa_source_la_SOURCES = modules/alsa/module-alsa-source.c
 module_alsa_source_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_alsa_source_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
diff --git a/src/modules/alsa/module-alsa-sink-volume-symdef.h b/src/modules/alsa/module-alsa-sink-volume-symdef.h
new file mode 100644
index 0000000..30c44c1
--- /dev/null
+++ b/src/modules/alsa/module-alsa-sink-volume-symdef.h
@@ -0,0 +1,27 @@
+#ifndef foomodulealsasinkvolumesymdeffoo
+#define foomodulealsasinkvolumesymdeffoo
+
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/macro.h>
+
+#define pa__init module_alsa_sink_volume_LTX_pa__init
+#define pa__done module_alsa_sink_volume_LTX_pa__done
+#define pa__get_author module_alsa_sink_volume_LTX_pa__get_author
+#define pa__get_description module_alsa_sink_volume_LTX_pa__get_description
+#define pa__get_usage module_alsa_sink_volume_LTX_pa__get_usage
+#define pa__get_version module_alsa_sink_volume_LTX_pa__get_version
+#define pa__load_once module_alsa_sink_volume_LTX_pa__load_once
+#define pa__get_n_used module_alsa_sink_volume_LTX_pa__get_n_used
+
+int pa__init(pa_module*m);
+void pa__done(pa_module*m);
+int pa__get_n_used(pa_module*m);
+
+const char* pa__get_author(void);
+const char* pa__get_description(void);
+const char* pa__get_usage(void);
+const char* pa__get_version(void);
+pa_bool_t pa__load_once(void);
+
+#endif
diff --git a/src/modules/alsa/module-alsa-sink-volume.c b/src/modules/alsa/module-alsa-sink-volume.c
new file mode 100644
index 0000000..7084a9f
--- /dev/null
+++ b/src/modules/alsa/module-alsa-sink-volume.c
@@ -0,0 +1,1461 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright (C) 2008-2009 Nokia Corporation and/or its subsidiary(-ies).
+  Copyright 2004-2006 Lennart Poettering
+  Copyright 2006 Pierre Ossman <ossman@cendio.se> for Cendio AB
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published
+  by the Free Software Foundation; either version 2 of the License,
+  or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with PulseAudio; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <gdbm.h>
+
+#include <asoundlib.h>
+
+#include <pulse/xmalloc.h>
+#include <pulse/util.h>
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/memchunk.h>
+#include <pulsecore/sink.h>
+#include <pulsecore/modargs.h>
+#include <pulsecore/core-util.h>
+#include <pulsecore/sample-util.h>
+#include <pulsecore/log.h>
+#include <pulsecore/macro.h>
+#include <pulsecore/thread.h>
+#include <pulsecore/core-error.h>
+#include <pulsecore/thread-mq.h>
+#include <pulsecore/rtpoll.h>
+#include <pulsecore/atomic.h>
+#include <pulsecore/namereg.h>
+#include <pulsecore/semaphore.h>
+#include <pulsecore/mutex.h>
+#include <pulse/rtclock.h>
+
+#include "alsa-util.h"
+#include "module-alsa-sink-volume-symdef.h"
+
+PA_MODULE_AUTHOR("Juho Hamalainen & Jyri Sarha");
+PA_MODULE_DESCRIPTION("ALSA Mixer Control from Nokia");
+PA_MODULE_VERSION(PACKAGE_VERSION);
+PA_MODULE_LOAD_ONCE(FALSE);
+PA_MODULE_USAGE(
+        "sink_name=<name of the sink to connect> "
+        "device=<ALSA device> "
+        "default_volume=<default volume dB to set to mixer without previous value> "
+        "software_volume=<use software volume compensation, true/false (default true)> "
+        "mixer=<initial ALSA mixer> "
+        "mixer_load=<load mixer controls in startup> ");
+
+static const char* const valid_modargs[] = {
+    "device",
+    "sink_name",
+    "default_volume",
+    "mixer",
+    "mixer_load",
+    NULL
+};
+
+/* Update mixer states,
+ * max       0dB
+ * off       mute
+ * control   sink volume controlled
+ *
+ * eg. "HP DAC:max,Headphone:off,Earphone:control"
+ */
+#define PROP_MIXER         "x-maemo.alsa_sink.mixer_control"
+#define PROP_MIXER_OFF     "off"
+#define PROP_MIXER_MAX     "max"
+#define PROP_MIXER_CONTROL "control"
+#define PROP_MIXER_SLAVE   "slave"
+
+/* String of comma separated integer pairs defining alsa volumes,
+ * where the first value is HW register value and the second value
+ * is the corresponding millibel value. The register values should
+ * be in increasing order, first HW value is lowest allowed volume and the last
+ * is the hightest.
+ * If values are not defined for each HW register value, missing
+ * millibel values between specified end points are interpolated.
+ *
+ * If values are not defined at all, steps are interpolated using
+ * mixer minimum and maximum dB values.
+ *
+ * MIXER=(HW REGISTER VALUE:mB VALUE,)+
+ * eg. "HP DAC=1:-5850,31:-4350,63:-2750,118:0"
+ */
+const char *PROP_MIXER_TUNING[2] = {
+    "x-maemo.alsa_sink.mixer_tuning",
+    "x-maemo.alsa_sink.alt_mixer_tuning"
+};
+
+/* String with single integer defining which mixer
+ * tuning table is used. Currently only two different tables
+ * can be defined.
+ */
+#define PROP_MIXER_TUNING_MODE "x-maemo.alsa_sink.mixer_tuning_mode"
+#define PROP_MIXER_TUNING_PRI (0)
+#define PROP_MIXER_TUNING_ALT (1)
+
+#define MAX_TUNING_TABLES (2)
+
+/* from Nokia modules */
+#define XMAEMO_MODE "x-maemo.mode"
+
+#ifdef SPAM_ALSA_SINK_VOLUME
+#define log_spam(args...) pa_log_debug(args)
+#else
+#define log_spam(args...)
+#endif
+
+
+struct slave_mixer_t;
+typedef struct slave_mixer_t slave_mixer_t;
+
+typedef struct tuning_data_t {
+    pa_bool_t tuning_table_filled;
+    long *tuning_table;
+    int tuning_table_allocated_length;
+    int tuning_table_max;
+    long tuned_volume_max, tuned_volume_min;
+} tuning_data_t;
+
+typedef struct mixer_control_t {
+    char *name;
+    pa_alsa_fdlist *mixer_fdl;
+    snd_mixer_elem_t *mixer_elem;
+    snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
+    unsigned channels;
+
+    long hw_volume_max, hw_volume_min;
+    long hw_dB_max, hw_dB_min;
+    pa_bool_t hw_dB_supported;
+    pa_bool_t mixer_separate_channels;
+    pa_bool_t has_hw_mute;
+
+    pa_cvolume hardware_volume;
+
+    enum { MM_UNUSED=0, MM_CONTROL, MM_STATIC, MM_SLAVE } mode;
+    tuning_data_t tuning_data[MAX_TUNING_TABLES];
+
+    struct slave_mixer_t **slaves;
+
+    PA_LLIST_FIELDS(struct mixer_control_t);
+} mixer_control_t;
+
+struct slave_mixer_t {
+    struct mixer_control_t *mixer;
+    long *tuning_table;
+};
+
+struct delayed_mixer_ctrl_args_t {
+    struct mixer_control_t *m;
+    pa_cvolume *vv;
+    long hw_vol_current;
+    pa_usec_t time;
+};
+
+#define DEFAULT_MIXER_DB_VALUE_ON_FIRST_BOOT (-12)
+#define MAX_VALUE_STEPS (1024)
+#define MAX_MIXER_COUNT (16)
+
+struct userdata {
+    pa_core *core;
+    pa_module *module;
+
+    /* controlled sink and properties */
+    pa_sink *sink;
+    pa_sink_flags_t original_flags;
+    void (*original_get_volume)(pa_sink *s);
+    void (*original_set_volume)(pa_sink *s);
+    void (*original_write_volume)(pa_sink *s);
+    void (*original_get_mute)(pa_sink *s);
+    void (*original_set_mute)(pa_sink *s);
+
+    char *device_name;
+
+    snd_mixer_t *mixer_handle;
+
+    /* store for all loaded mixers */
+    PA_LLIST_HEAD(struct mixer_control_t, mixer_list);
+    struct mixer_control_t *active_mixer;
+
+    pa_bool_t sw_vol_compensation;
+
+    struct mixer_lock {
+        pa_mutex *mutex;
+        pa_semaphore *reinitialize;
+        pa_atomic_t mixer_initialized;
+        pa_atomic_t usecount;
+    } lock;
+
+    /* current audio mode */
+    char *audio_mode;
+    /* primary/alternative tuning for mixer */
+    int active_tuning;
+
+    pa_hook_slot *sink_proplist_changed_slot;
+    pa_hook_slot *sink_unlink_slot;
+
+    struct delayed_mixer_ctrl_args_t delayed_mixer_ctrl;
+};
+
+static struct userdata *global_userdata = NULL;
+
+static void init_mixer_lock(struct mixer_lock *lock) {
+    pa_assert(lock);
+    lock->mutex = pa_mutex_new(FALSE, FALSE);
+    lock->reinitialize = pa_semaphore_new(0);
+    pa_atomic_store(&lock->mixer_initialized, TRUE);
+    pa_atomic_store(&lock->usecount, 0);
+}
+
+static void free_mixer_lock(struct mixer_lock *lock) {
+    pa_assert(lock);
+    pa_mutex_free(lock->mutex);
+    pa_semaphore_free(lock->reinitialize);
+}
+
+/* Multi thread and multiple call safe */
+static pa_bool_t enter_callback(struct userdata *u) {
+    struct mixer_lock *lock = &u->lock;
+    pa_assert(u);
+    pa_mutex_lock(lock->mutex);
+    if (!pa_atomic_load(&lock->mixer_initialized)) {
+        pa_mutex_unlock(lock->mutex);
+        pa_log_debug("Mixer was not initalized");
+        return FALSE;
+    }
+    pa_atomic_store(&lock->usecount, pa_atomic_load(&lock->usecount)+1);
+    pa_mutex_unlock(lock->mutex);
+    return TRUE;
+}
+
+static void leave_callback(struct userdata *u) {
+    struct mixer_lock *lock = &u->lock;
+    int usecount;
+    pa_assert(u);
+    pa_mutex_lock(lock->mutex);
+    usecount = pa_atomic_load(&lock->usecount)-1;
+    pa_assert(usecount >= 0);
+    pa_atomic_store(&lock->usecount, usecount);
+    if (usecount == 0 && !pa_atomic_load(&lock->mixer_initialized)) {
+        pa_log_debug("Let the reinitializaion start");
+        pa_semaphore_post(lock->reinitialize);
+        pa_assert(0 == pa_atomic_load(&lock->usecount));
+    }
+    pa_mutex_unlock(lock->mutex);
+}
+
+/* Can only hadle one caller */
+static void enter_initialization(struct userdata *u) {
+    struct mixer_lock *lock = &u->lock;
+    int usecount;
+    pa_assert(u);
+    pa_mutex_lock(lock->mutex);
+    pa_atomic_store(&lock->mixer_initialized, FALSE);
+    usecount = pa_atomic_load(&lock->usecount);
+    pa_mutex_unlock(lock->mutex);
+    if (usecount > 0) {
+        pa_log_debug("Waiting for all callback to exit");
+        pa_semaphore_wait(lock->reinitialize);
+        pa_log_debug("Continue with the initialization");
+    }
+}
+
+static void leave_initialization(struct userdata *u) {
+    struct mixer_lock *lock = &u->lock;
+    pa_assert(u);
+    pa_mutex_lock(lock->mutex);
+    pa_atomic_store(&lock->mixer_initialized, TRUE);
+    pa_assert(0 == pa_atomic_load(&lock->usecount));
+    pa_mutex_unlock(lock->mutex);
+}
+
+static int mixer_callback(snd_mixer_elem_t *elem, unsigned int mask) {
+    struct userdata *u = snd_mixer_elem_get_callback_private(elem);
+
+    pa_assert(u);
+    pa_assert(u->mixer_handle);
+
+    if (mask == SND_CTL_EVENT_MASK_REMOVE)
+        return 0;
+
+    if (mask & SND_CTL_EVENT_MASK_VALUE) {
+        if (!u->sink) {
+            return 0;
+        }
+
+        pa_sink_get_volume(u->sink, TRUE, FALSE);
+        pa_sink_get_mute(u->sink, TRUE);
+    }
+
+    return 0;
+}
+
+static size_t mB_to_hw_mixer_find(mixer_control_t *m, const int table, long mB, size_t l, size_t h) {
+
+    if (l + 1 == h)
+        return l;
+
+    if (mB > m->tuning_data[table].tuning_table[(l+h)/2])
+        return mB_to_hw_mixer_find(m, table, mB, (l+h)/2, h);
+    else
+        return mB_to_hw_mixer_find(m, table, mB, l, (l+h)/2);
+}
+
+static long mB_to_hw_mixer_value(mixer_control_t *m, const int table, long mB) {
+    int element;
+    long ret;
+    tuning_data_t *td = &m->tuning_data[table];
+    pa_assert(m);
+    pa_assert(td->tuning_table_filled);
+
+    if (mB <= td->tuning_table[0])
+        return td->tuned_volume_min;
+
+    if (mB >= td->tuning_table[td->tuning_table_max])
+        return td->tuned_volume_max;
+
+    element = mB_to_hw_mixer_find(m, table, mB, 0, td->tuning_table_max);
+
+    if ((mB - td->tuning_table[element]) < (td->tuning_table[element+1] - mB))
+        ret = element + td->tuned_volume_min;
+    else
+        ret = element + 1 + td->tuned_volume_min;
+
+    return ret;
+}
+
+static long hw_mixer_to_mB_value(mixer_control_t *m, const int table, long hw_vol) {
+    pa_assert(m);
+    pa_assert(m->tuning_data[table].tuning_table_filled);
+
+    return m->tuning_data[table].tuning_table[hw_vol - m->tuning_data[table].tuned_volume_min];
+}
+
+static void sink_get_volume_cb(pa_sink *s) {
+    struct userdata *u = global_userdata;
+    struct mixer_control_t *m = NULL;
+    int err;
+    unsigned i;
+    pa_cvolume r;
+    const int active_tuning = u->active_tuning;
+
+    pa_assert(u);
+    if (!enter_callback(u))
+        return;
+    pa_assert(u->active_mixer);
+    pa_assert(u->active_mixer->mixer_elem);
+
+    if (!u->sink) {
+        pa_log_debug("This sink does not exist any more, go away.");
+        return;
+    }
+
+    if (s != u->sink) {
+        pa_log_error("This in not my sink, what to do?");
+        return;
+    }
+
+    m = u->active_mixer;
+
+    if (m->mixer_separate_channels) {
+
+        r.channels = u->sink->sample_spec.channels;
+
+        for (i = 0; i < u->sink->sample_spec.channels; i++) {
+            long hw_vol;
+            long mB;
+
+            if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, m->mixer_map[i], &hw_vol)) < 0)
+                goto fail;
+
+            log_spam("Got hw volume %s ch %d: %ld", m->name, i, hw_vol);
+
+            mB = hw_mixer_to_mB_value(m, active_tuning, hw_vol);
+
+            r.values[i] = pa_sw_volume_from_dB((double) mB / 100.0);
+
+            log_spam("Alsa %ld hw = tuned mB %ld = %d PA volume", hw_vol, mB, r.values[i]);
+        }
+
+    } else {
+        long hw_vol;
+        long mB;
+        pa_volume_t pa_vol;
+        if ((err = snd_mixer_selem_get_playback_volume(u->active_mixer->mixer_elem, SND_MIXER_SCHN_MONO, &hw_vol)) < 0)
+            goto fail;
+
+        log_spam("Got mono alsa volume %s: %ld", m->name, hw_vol);
+
+        mB = hw_mixer_to_mB_value(m, active_tuning, hw_vol);
+
+        pa_vol = pa_sw_volume_from_dB((double) mB / 100.0);
+
+        log_spam("Alsa %ld hw = tuned mB %ld = %d PA volume", hw_vol, mB, pa_vol);
+
+        pa_cvolume_set(&r, u->sink->sample_spec.channels, pa_vol);
+    }
+
+#ifdef SPAM_ALSA_SINK_VOLUME
+    {
+        char t[PA_CVOLUME_SNPRINT_MAX];
+        log_spam("Read hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &r));
+    }
+#endif
+
+    if (!pa_cvolume_equal(&u->active_mixer->hardware_volume, &r)) {
+        pa_cvolume reset;
+
+        log_spam("Active mixer value has changed, updating sink value");
+
+        s->virtual_volume = u->active_mixer->hardware_volume = r;
+
+        /* Hmm, so the hardware volume changed, let's reset our software volume */
+        pa_cvolume_reset(&reset, u->sink->sample_spec.channels);
+    }
+
+    leave_callback(u);
+    return;
+
+ fail:
+    pa_log_error("Unable to read volume: %s", snd_strerror(err));
+    leave_callback(u);
+}
+
+static pa_volume_t calculate_alsa_mixer_value(struct mixer_control_t *m, const int table, pa_volume_t pa_vol, long *hw_vol) {
+    long mB_vol;
+    long real_mB_vol;
+    pa_volume_t real_pa_vol;
+    pa_assert(m);
+    pa_assert(hw_vol);
+
+    mB_vol = (long) (pa_sw_volume_to_dB(pa_vol) * 100);
+    *hw_vol = mB_to_hw_mixer_value(m, table, mB_vol);
+    real_mB_vol = hw_mixer_to_mB_value(m, table, *hw_vol);
+    real_pa_vol = pa_sw_volume_from_dB((double) real_mB_vol / 100.0);
+
+    log_spam("Setting pa vol %d = %ld mB -> %s: %ld = %ld mB = %d pa vol",
+                 pa_vol, mB_vol, m->name, *hw_vol, real_mB_vol, real_pa_vol);
+
+    return real_pa_vol;
+}
+
+static int write_alsa_mixer_volumes(struct userdata *u,
+                                    struct mixer_control_t *m,
+                                    pa_cvolume *vv)  {
+    int err;
+    unsigned i;
+    pa_cvolume r;
+#ifdef SPAM_ALSA_SINK_VOLUME
+    char t[PA_CVOLUME_SNPRINT_MAX];
+#endif
+
+    tuning_data_t *td = &m->tuning_data[u->active_tuning];
+    const int active_tuning = u->active_tuning;
+
+    pa_assert(u);
+    pa_assert(m->mixer_elem);
+    pa_assert(td->tuning_table);
+    pa_assert(td->tuning_table_filled);
+
+    if (m->mixer_separate_channels) {
+
+        r.channels = u->sink->sample_spec.channels;
+
+        for (i = 0; i < u->sink->sample_spec.channels; i++) {
+            long hw_vol, real_hw_vol;
+            pa_volume_t real_pa_vol = calculate_alsa_mixer_value(m, active_tuning, vv->values[i], &hw_vol);
+
+            if ((err = snd_mixer_selem_set_playback_volume(m->mixer_elem, m->mixer_map[i], hw_vol)) < 0)
+                goto fail;
+#if 1       /* Maybe I could check alsa mixer value once more ... */
+            if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, m->mixer_map[i], &real_hw_vol)) < 0)
+                goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&real_hw_vol, sizeof(real_hw_vol));
+#endif
+            if (hw_vol != real_hw_vol) {
+                pa_log_warn("Can not set tuned hw vol %s ch %d to %ld, hw value is %ld",
+                            m->name, i, hw_vol, real_hw_vol);
+            }
+#endif
+
+            r.values[i] = real_pa_vol;
+        }
+    } else {
+        long hw_vol, real_hw_vol;
+        pa_volume_t real_pa_vol = calculate_alsa_mixer_value(m, active_tuning, pa_cvolume_max(vv), &hw_vol);
+
+        if ((err = snd_mixer_selem_set_playback_volume_all(m->mixer_elem, hw_vol)) < 0)
+            goto fail;
+
+#if 1   /* Maybe I could check alsa mixer value once more ... */
+        if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, SND_MIXER_SCHN_MONO, &real_hw_vol)) < 0)
+            goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&real_hw_vol, sizeof(real_hw_vol));
+#endif
+        if (hw_vol != real_hw_vol) {
+            pa_log_warn("Can not set tuned mono hw vol %s to %ld, hw value is %ld",
+                        m->name, hw_vol, real_hw_vol);
+        }
+#endif
+
+        pa_cvolume_set(&r, u->sink->sample_spec.channels, real_pa_vol);
+    }
+
+    return 0;
+
+ fail:
+    pa_log_error("Unable to set volume: %s", snd_strerror(err));
+
+    return 1;
+}
+
+static int set_alsa_mixer_volumes(struct userdata *u,
+                                  struct mixer_control_t *m,
+                                  pa_cvolume *vv) {
+    unsigned i;
+    pa_cvolume r;
+#ifdef SPAM_ALSA_SINK_VOLUME
+    char t[PA_CVOLUME_SNPRINT_MAX];
+#endif
+
+    tuning_data_t *td = &m->tuning_data[u->active_tuning];
+    const int active_tuning = u->active_tuning;
+
+    pa_assert(u);
+    pa_assert(m->mixer_elem);
+    pa_assert(td->tuning_table);
+    pa_assert(td->tuning_table_filled);
+
+    if (m->mixer_separate_channels) {
+
+        r.channels = u->sink->sample_spec.channels;
+
+        for (i = 0; i < u->sink->sample_spec.channels; i++) {
+            long hw_vol;
+            pa_volume_t real_pa_vol = calculate_alsa_mixer_value(m, active_tuning, vv->values[i], &hw_vol);
+
+            r.values[i] = real_pa_vol;
+        }
+    } else {
+        long hw_vol;
+        pa_volume_t real_pa_vol = calculate_alsa_mixer_value(m, active_tuning, pa_cvolume_max(vv), &hw_vol);
+
+        pa_cvolume_set(&r, u->sink->sample_spec.channels, real_pa_vol);
+    }
+
+    m->hardware_volume = r;
+
+    log_spam("Requested volume: %s", pa_cvolume_snprint(t, sizeof(t), vv));
+    log_spam("Got hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &m->hardware_volume));
+
+    if (u->sw_vol_compensation)  {
+        /* Match exactly what the user requested by software */
+        pa_sw_cvolume_divide(&u->sink->soft_volume, vv, &m->hardware_volume);
+        log_spam("Calculated software volume: %s", pa_cvolume_snprint(t, sizeof(t), &u->sink->soft_volume));
+    } else {
+        /* We can't match exactly what the user requested, hence let's
+         * at least tell the user about it */
+            log_spam("Skip software volume calculation");
+        *vv = r;
+    }
+
+    return 0;
+}
+
+static void sink_set_volume_cb(pa_sink *s) {
+    struct userdata *u = global_userdata;
+
+    pa_assert(u);
+    if (!enter_callback(u))
+        return;
+    pa_assert(u->active_mixer);
+
+    if (s != u->sink) {
+        pa_log_error("This in not my sink, what to do?");
+        goto leave;
+    }
+
+    if (!u->sink) {
+        pa_log_debug("This sink does not exist any more, go away.");
+        goto leave;
+    }
+
+    log_spam("set volume to active mixer %s", u->active_mixer->name);
+
+    set_alsa_mixer_volumes(u, u->active_mixer, &s->virtual_volume);
+leave:
+    leave_callback(u);
+}
+
+static void sink_write_volume_cb(pa_sink *s) {
+    struct userdata *u = global_userdata;
+
+    pa_assert(u);
+    if (!enter_callback(u))
+        return;
+    pa_assert(u->active_mixer);
+
+    if (s != u->sink) {
+        pa_log_debug("This in not my sink, what to do?");
+        goto leave;
+    }
+
+    if (!u->sink) {
+        pa_log_debug("This sink does not exist any more, go away.");
+        goto leave;
+   }
+
+    log_spam("set volume to active mixer %s", u->active_mixer->name);
+
+    write_alsa_mixer_volumes(u, u->active_mixer, &s->thread_info.current_hw_volume);
+leave:
+    leave_callback(u);
+}
+
+static void sink_get_mute_cb(pa_sink *s) {
+    struct userdata *u = global_userdata;
+    int sw;
+    int err;
+
+    pa_assert(u);
+    if (!enter_callback(u))
+        return;
+    pa_assert(u->active_mixer);
+    pa_assert(u->active_mixer->mixer_elem);
+
+    if ((err = snd_mixer_selem_get_playback_switch(u->active_mixer->mixer_elem, 0, &sw)) < 0)
+        pa_log_error("Unable to get switch: %s", snd_strerror(err));
+    else
+        s->muted = !sw;
+
+    leave_callback(u);
+}
+
+static void sink_set_mute_cb(pa_sink *s) {
+    struct userdata *u = global_userdata;
+    int err;
+
+    pa_assert(u);
+    if (!enter_callback(u))
+        return;
+    pa_assert(u->active_mixer);
+    pa_assert(u->active_mixer->mixer_elem);
+
+    if ((err = snd_mixer_selem_set_playback_switch_all(u->active_mixer->mixer_elem, !s->muted)) < 0)
+        pa_log_error("Unable to set switch: %s", snd_strerror(err));
+
+    leave_callback(u);
+}
+
+static pa_hook_result_t sink_unlink_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
+    if (s != u->sink)
+        return PA_HOOK_OK;
+
+    u->sink = NULL;
+
+    return PA_HOOK_OK;
+}
+
+/* Functions only called from sink_proplist_changed_hook_callback() start from here */
+static void fill_tuning_table_range(struct mixer_control_t *m, const int table, size_t start, size_t end,
+                                   long mBstart, long mBend) {
+    double mB_step;
+    int i;
+    pa_assert(m);
+    pa_assert(end > start);
+    mB_step  = (double)(mBend-mBstart)/(double)(end-start);
+
+    for (i = 0; i <= (int)(end - start); i++)
+        m->tuning_data[table].tuning_table[start + i] = lrint((double)mBstart + mB_step*i);
+}
+
+#if 0
+static void print_tuning_table(struct mixer_control_t *m, const int table) {
+    int i;
+    pa_assert(m);
+    pa_assert(m->tuning_data[table].tuning_table);
+
+    for(i=0; i<= m->tuning_data[table].tuning_table_max; i++)
+        pa_log_debug("%ld:%ld", i+m->tuning_data[table].tuned_volume_min, m->tuning_data[table].tuning_table[i]);
+}
+#endif
+
+static void fill_tuning_table_from_dB_info(struct mixer_control_t *m, const int table) {
+    tuning_data_t *td = &m->tuning_data[table];
+    pa_assert(m);
+    pa_assert(td->tuning_table);
+
+    td->tuned_volume_min = m->hw_volume_min;
+    td->tuned_volume_max = m->hw_volume_max;
+    td->tuning_table_max = td->tuning_table_allocated_length-1;
+    fill_tuning_table_range(m, table, 0, td->tuning_table_max, m->hw_dB_min - m->hw_dB_max, 0);
+    td->tuning_table_filled  = TRUE;
+}
+
+static void fill_mixer_tuning(struct userdata *u, struct mixer_control_t *m, const int table) {
+    tuning_data_t *td;
+    pa_assert(u);
+    pa_assert(m);
+    td = &m->tuning_data[table];
+
+    if (m->hw_dB_supported) {
+        pa_log_info("Using ALSA dB info to fill tuning table for %s mixer", m->name);
+        fill_tuning_table_from_dB_info(m, table);
+        td->tuning_table_filled = TRUE;
+    } else {
+        pa_log_warn("No tuning table or ALSA dB info for %s, this is bad (assuming 0 - -60dB range)",
+                m->name);
+        td->tuning_table_max = td->tuning_table_allocated_length-1;
+        fill_tuning_table_range(m, table, 0, td->tuning_table_max, -6000, 0);
+        td->tuning_table_filled = TRUE;
+        u->sink->n_volume_steps = td->tuning_table_max+1;
+    }
+}
+
+static struct mixer_control_t* get_mixer_elem_by_name(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
+
+    for (m = u->mixer_list; m; m = m->next) {
+        if (strcmp(mixer, m->name) == 0)
+            return m;
+    }
+
+    return NULL;
+}
+
+static void my_split(const char *src, const char *separator, const char **left, const char **right) {
+    const char *state = NULL;
+    char *str;
+
+    while ((str = pa_split(src, separator, &state))) {
+        if (str) {
+            if (!*left)
+                *left = str;
+            else if (!*right)
+                *right = str;
+            else
+                pa_xfree(str);
+        }
+    }
+}
+
+static int load_mixer_tuning(struct userdata *u, struct mixer_control_t *m, const int tuning_mode) {
+    const char *tuning = NULL;
+    char *element = NULL;
+    char *mixer_name = NULL;
+    const char *element_state = NULL;
+    uint element_count = 0;
+    const char *error = NULL;
+    /* Gcc is not clever enough to see these are initialized before use. */
+    long prev_hw_vol = -1;
+    long prev_mB_vol = -1;
+    long hw_vol = -1;
+    long mB_vol = -1;
+    tuning_data_t *td = &m->tuning_data[tuning_mode];
+    pa_assert(u);
+    pa_assert(m);
+
+    td->tuning_table_filled = FALSE;
+
+    tuning = pa_proplist_gets(u->sink->proplist, PROP_MIXER_TUNING[tuning_mode]);
+    if (!tuning && PROP_MIXER_TUNING_ALT == tuning_mode) {
+        pa_log_debug("Could not find alternate tuning, loading primary instead");
+        tuning = pa_proplist_gets(u->sink->proplist, PROP_MIXER_TUNING[PROP_MIXER_TUNING_PRI]);
+    }
+    if (!tuning) {
+        pa_log_debug("Could not find mixer tuning");
+        return -1;
+    }
+
+    log_spam("Parsing mixer tuning: %s", tuning);
+
+    /* The mixer tuning should look like this "HP DAC=5:-6000,50:-3000,110:0" where the
+       first value in ":" separated pair is HW register value and the second value
+       is the corresponding millibel value. The register valued should be in
+       increasing order. First HW value is lowes allowed volume and the last is the
+       highest. The millibel values between specified end points are interpolated. */
+    if ((mixer_name = pa_split(tuning, "=" , &element_state))) {
+        if (strcmp(mixer_name, m->name) != 0) {
+            pa_log_info("Found tuning table is not for this mixer %s != %s", mixer_name, m->name);
+            pa_xfree(mixer_name);
+            return -1;
+        }
+        pa_xfree(mixer_name);
+    } else {
+        pa_log_info("Can not extract mixer name from tuning, assuming it is for %s", m->name);
+        element_state = NULL;
+    }
+
+    while ((element = pa_split(tuning, "," , &element_state))) {
+        char *value = NULL;
+        const char *value_state = NULL;
+        enum { FIELD_HW_VOL = 0, FIELD_MB_VOL, FIELD_END } field = FIELD_HW_VOL;
+        int hw = -1, mB = -1;
+
+        element_count++;
+        while ((value = pa_split(element, ":" , &value_state))) {
+            switch (field) {
+            case FIELD_HW_VOL:
+                if (pa_atoi(value, &hw))
+                    error = value;
+                break;
+            case FIELD_MB_VOL:
+                if (pa_atoi(value, (int*)&mB))
+                    error = value;
+                break;
+                /* Add more fileds to implement slave mixers */
+            default:
+                pa_log_warn("Too many fields in element %d of mixer tuning: %s (ignoring)", element_count, element);
+            }
+            if (error)
+                break;
+            pa_xfree(value);
+            field++;
+        }
+        if (error) {
+            pa_log_error("Can't parse \"%s\" in field %d of element %d in: %s", error, field, element_count, tuning);
+            pa_xfree(error);
+            pa_xfree(element);
+            return -1;
+        }
+
+        hw_vol = (long)hw;
+        mB_vol = (long)mB;
+
+        if (hw_vol < m->hw_volume_min || hw_vol > m->hw_volume_max) {
+            pa_log_error("Bad hw vol value %ld in element %d", hw_vol, element_count);
+            pa_xfree(element);
+            return -1;
+        }
+
+        if (element_count == 1) {
+            td->tuned_volume_min = hw_vol;
+        } else {
+            if (prev_hw_vol > hw_vol || prev_mB_vol > mB_vol) {
+                pa_log_error("The tuning values should be in increasing order, problem with element %d of %s",
+                             element_count, tuning);
+                pa_xfree(element);
+                return -1;
+            }
+            fill_tuning_table_range(m, tuning_mode, prev_hw_vol - td->tuned_volume_min, hw_vol - td->tuned_volume_min,
+                                    prev_mB_vol, mB_vol);
+        }
+        prev_hw_vol = hw_vol;
+        prev_mB_vol = mB_vol;
+        pa_xfree(element);
+    }
+
+    if (element_count < 2) {
+        pa_log_error("Too few element in tuning table %s", tuning);
+        return -1;
+    }
+
+    td->tuned_volume_max = hw_vol;
+    td->tuning_table_max = td->tuned_volume_max - td->tuned_volume_min;
+    td->tuning_table_filled = TRUE;
+
+    return 0;
+}
+
+static int set_control_mixer_elem(struct userdata *u, struct mixer_control_t *m, const int active_tuning) {
+    tuning_data_t *td = NULL;
+    pa_assert(u);
+    pa_assert(m);
+
+    pa_log_info("%s: setting active mixer to %s", u->device_name, m->name);
+    load_mixer_tuning(u, m, active_tuning);
+    td = &m->tuning_data[active_tuning];
+
+    if (!td->tuning_table_filled) {
+        pa_log_info("No tuning table filled for %s mixer", m->name);
+        fill_mixer_tuning(u, m, active_tuning);
+    }
+
+    log_spam("%s--> tuning %d filled %d", m->name, active_tuning, td->tuning_table_filled);
+
+    u->active_mixer = m;
+    return 0;
+}
+
+/** Set mixer state using colon separated MIXER:STATE pair.
+ */
+static int set_mixer_state(struct userdata *u, const char *value_str) {
+    int ret = 0;
+    struct mixer_control_t *m = NULL;
+    const char *mode = NULL;
+    const char *mixer = NULL;
+
+    my_split(value_str, ":", &mixer, &mode);
+
+    if (mixer && mode && (m = get_mixer_elem_by_name(u, mixer))) {
+
+        if (strcmp(mode, PROP_MIXER_CONTROL) == 0) {
+            if (set_control_mixer_elem(u, m, PROP_MIXER_TUNING_PRI) ||
+                set_control_mixer_elem(u, m, PROP_MIXER_TUNING_ALT) ) {
+                pa_log_error("%s: Setting control mixer %s failed", u->device_name, mixer);
+                ret = -1;
+            }
+        } else if (FALSE && strcmp(mode, PROP_MIXER_SLAVE) == 0) {
+            /* Implement slave mode here */
+        } else {
+            int err;
+            /* By default mute all mixers. */
+            int hw_volume = (long)m->hw_volume_min;
+            pa_bool_t mute_state = FALSE; // no reason to mute hw mixers
+            m->mode = MM_UNUSED;
+
+            if (strcmp(mode, PROP_MIXER_SLAVE) == 0) {
+                pa_log_error("%s: set mixer %s slave: slave mode unimplemented (muting)", u->device_name, mixer);
+                ret = 1;
+            } else if (strcmp(mode, PROP_MIXER_OFF) == 0) {
+                log_spam("%s: set mixer %s off", u->device_name, mixer);
+                m->mode = MM_STATIC;
+            } else if (strcmp(mode, PROP_MIXER_MAX) == 0) {
+                log_spam("%s: set mixer %s to max", u->device_name, mixer);
+                m->mode = MM_STATIC;
+                mute_state = FALSE;
+                hw_volume = m->hw_volume_max;
+            } else {
+                if (pa_atoi(mode, &hw_volume) == 0 &&
+                    hw_volume >= m->hw_volume_min && hw_volume <= m->hw_volume_max) {
+                    log_spam("%s: set mixer %s to %d", u->device_name, mixer, hw_volume);
+                }
+                else {
+                    pa_log_error("%s: Bad mode for mixer %s: %s (muting)", u->device_name, mixer, mode);
+                    ret = 1;
+                }
+            }
+
+            if (snd_mixer_selem_has_playback_switch(m->mixer_elem))  {
+                if ((err = snd_mixer_selem_set_playback_switch_all(m->mixer_elem, !mute_state)) < 0) {
+                    pa_log_error("%s: Setting mute state of %s to %d failed: %s",
+                                 u->device_name, mixer, mute_state, snd_strerror(err));
+                }
+            }
+
+            if ((err = snd_mixer_selem_set_playback_volume_all(m->mixer_elem, (long)hw_volume)) < 0) {
+                pa_log_error("%s: Setting volume of %s to %d failed: %s",
+                             u->device_name, mixer, hw_volume, snd_strerror(err));
+            }
+        }
+    } else {
+        pa_log_error("%s: Bad mixer mode entry %s", u->device_name, value_str);
+    }
+
+    if (mixer)
+        pa_xfree((void*)mixer);
+    if (mode)
+        pa_xfree((void*)mode);
+
+    return ret;
+}
+
+/** Parse mixer control list.
+ *
+ * Parses comma separated list of MIXER:STATE pairs.
+ */
+static int update_mixer_setup(struct userdata *u, const char *value_list) {
+    int ret = 0;
+    const pa_cvolume *vol;
+    pa_cvolume volume;
+    const char *state = NULL;
+    char *value;
+
+    pa_assert(u);
+    pa_assert(u->sink);
+
+    vol = pa_sink_get_volume(u->sink, FALSE, FALSE);
+    pa_return_val_if_fail (vol, 1);
+    volume = *vol;
+
+    while ((value = pa_split(value_list, ",", &state))) {
+        int err = set_mixer_state(u, value);
+        pa_xfree(value);
+        if (err < 0) {
+            ret = err;
+            break;
+        }
+        ret += err;
+    }
+
+    if (ret > 0)
+        pa_log_warn("Setting mixer state for %d mixers failed", ret);
+
+    if (u->active_mixer) {
+        if (u->active_mixer->has_hw_mute) {
+            u->sink->get_mute = sink_get_mute_cb;
+            u->sink->set_mute = sink_set_mute_cb;
+            u->sink->flags |= PA_SINK_HW_MUTE_CTRL;
+        } else {
+            pa_log_info("Using software mute control for mixer %s.", u->active_mixer->name);
+            u->sink->flags &= ~PA_SINK_HW_MUTE_CTRL;
+            u->sink->get_mute = NULL;
+            u->sink->set_mute = NULL;
+        }
+
+        u->sink->flags |= PA_SINK_HW_VOLUME_CTRL | PA_SINK_DECIBEL_VOLUME | PA_SINK_SYNC_VOLUME;
+        u->sink->get_volume = sink_get_volume_cb;
+        u->sink->set_volume = sink_set_volume_cb;
+        u->sink->write_volume = sink_write_volume_cb
+        log_spam("%s setting new volume callbacks", u->device_name);
+
+        log_spam("update mixer volume (vol was %d) sink->refresh_volume %d", vol->values[0], u->sink->refresh_volume);
+    }
+    else {
+        /* No active mixer, set all call backs to NULL */
+        u->sink->flags &= ~(PA_SINK_HW_MUTE_CTRL | PA_SINK_HW_VOLUME_CTRL | PA_SINK_SYNC_VOLUME);
+        u->sink->get_volume = NULL;
+        u->sink->set_volume = NULL;
+        u->sink->write_volume = NULL;
+        u->sink->get_mute = NULL;
+        u->sink->set_mute = NULL;
+    }
+
+    return ret;
+}
+
+static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
+    const char *v = NULL;
+    int tmp;
+    pa_bool_t full_update = TRUE;
+    pa_bool_t update_volume = FALSE;
+
+    if (s != u->sink) {
+        return PA_HOOK_OK;
+    }
+
+    pa_assert(u);
+    pa_assert(s);
+
+    v = pa_proplist_gets(s->proplist, XMAEMO_MODE);
+    if (v) {
+        if (u->audio_mode) {
+            if (strcmp(v, u->audio_mode) == 0) {
+                /* same mode as previously, so
+                 * we don't really need to reread
+                 * mixer tunings right now */
+                full_update = FALSE;
+            } else {
+                pa_xfree(u->audio_mode);
+                u->audio_mode = NULL;
+            }
+        }
+
+        if (!u->audio_mode)
+            u->audio_mode = pa_xstrdup(v);
+    }
+
+    v = pa_proplist_gets(s->proplist, PROP_MIXER_TUNING_MODE);
+    if (v) {
+        if (!pa_atoi(v, &tmp)) {
+            if (u->active_tuning != tmp) {
+                u->active_tuning = tmp;
+                log_spam("change tuning mode to %d", tmp);
+                update_volume = TRUE;
+            }
+        }
+    }
+
+    if (full_update) {
+        enter_initialization(u);
+        v = pa_proplist_gets(s->proplist, PROP_MIXER);
+        if (v) {
+            update_mixer_setup(u, v);
+        }
+        update_volume = FALSE;
+        pa_sink_set_mute(u->sink, u->sink->muted);
+        pa_sink_set_volume(u->sink, &u->sink->virtual_volume, FALSE, TRUE, FALSE);
+        leave_initialization(u);
+    }
+
+    if (update_volume)
+        pa_sink_set_volume(u->sink, &u->sink->virtual_volume, FALSE, TRUE, FALSE);
+
+    return PA_HOOK_OK;
+}
+
+/* Functions only called from init and unload start from here */
+static struct mixer_control_t* get_mixer_element(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
+    snd_mixer_elem_t *mixer_elem;
+    tuning_data_t *td = NULL;
+    unsigned i;
+    pa_channel_map map;
+    pa_assert(u);
+    pa_assert(u->sink);
+
+    if (u->mixer_handle) {
+        /* Try using mixer as both primary and fallback mixer, to ensure mixer selection
+         * even when mixer doesn't have both volume and mute switches */
+        if (!(mixer_elem = pa_alsa_find_elem(u->mixer_handle, mixer, mixer, TRUE))) {
+            pa_log_error("%s: could not select mixer %s at all", u->device_name, mixer);
+            goto fail;
+        }
+    } else {
+        pa_log_error("%s: No mixer handle.", u->device_name);
+        goto fail;
+    }
+
+    m = pa_xnew0(struct mixer_control_t, 1);
+    PA_LLIST_INIT(struct mixer_control_t, m);
+
+    m->name = pa_xstrdup(mixer);
+    m->mixer_elem = mixer_elem;
+
+    if (!snd_mixer_selem_has_playback_volume(m->mixer_elem)) {
+        pa_log_error("%s: Mixer %s has no playback volume", u->device_name, mixer);
+        goto fail;
+    }
+
+    if (snd_mixer_selem_get_playback_volume_range(m->mixer_elem, &m->hw_volume_min, &m->hw_volume_max) < 0) {
+        pa_log_info("Failed to get volume range. Falling back to software volume control.");
+        goto fail;
+    }
+
+    if (m->hw_volume_min >= m->hw_volume_max) {
+        pa_log_warn("Bad mixer range: %ld - %ld.", m->hw_volume_min, m->hw_volume_max);
+        goto fail;
+    }
+
+    if (snd_mixer_selem_get_playback_dB_range(m->mixer_elem, &m->hw_dB_min, &m->hw_dB_max) < 0) {
+        pa_log_info("Mixer doesn't not have dB information.");
+    }
+    else {
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+        VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_min, sizeof(m->hw_dB_min));
+        VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_max, sizeof(m->hw_dB_max));
+#endif
+        if (m->hw_dB_min >= m->hw_dB_max)
+            pa_log_warn("Bad dB range: %0.2f dB - %0.2f dB.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
+        else {
+            pa_log_info("Volume dB range: %0.2f dB - %0.2f dB.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
+            m->hw_dB_supported = TRUE;
+        }
+    }
+
+    map = u->sink->channel_map;
+    m->mixer_separate_channels = (pa_alsa_calc_mixer_map(m->mixer_elem, &map, m->mixer_map, TRUE) >= 0);
+    m->has_hw_mute = snd_mixer_selem_has_playback_switch(m->mixer_elem);
+
+    /* Initalize some sane values to hardware_volume */
+    pa_cvolume_set(&m->hardware_volume, u->sink->sample_spec.channels, PA_VOLUME_MUTED);
+
+    m->mixer_fdl = pa_alsa_fdlist_new();
+
+    if (pa_alsa_fdlist_set_mixer(m->mixer_fdl, u->mixer_handle, u->core->mainloop) < 0) {
+        pa_log_error("Failed to initialize file descriptor monitoring");
+        goto fail;
+    }
+
+    for (i = 0; i < MAX_TUNING_TABLES; i++) {
+        td = &m->tuning_data[i];
+        td->tuning_table_filled = FALSE;
+        td->tuning_table_allocated_length = m->hw_volume_max - m->hw_volume_min + 1;
+        if (td->tuning_table_allocated_length > MAX_VALUE_STEPS) {
+            pa_log_error("Too many mixer steps: %ld - %ld", m->hw_volume_max, m->hw_volume_min);
+            goto fail;
+        }
+
+        td->tuning_table_max = 0;
+        td->tuning_table = pa_xmalloc0(td->tuning_table_allocated_length * sizeof(long));
+        pa_assert(td->tuning_table);
+    }
+
+    snd_mixer_elem_set_callback(m->mixer_elem, mixer_callback);
+    snd_mixer_elem_set_callback_private(m->mixer_elem, u);
+
+    pa_log_info("%s: new mixer accepted: %s", u->device_name, m->name);
+    pa_log_debug("%s: mixer %s hw range %ld - %ld, alsa mB range %ld - %ld", u->device_name, m->name,
+                 m->hw_volume_min, m->hw_volume_max, m->hw_dB_min, m->hw_dB_max);
+
+    return m;
+ fail:
+    if (m) {
+        if (m->name)
+            pa_xfree(m->name);
+
+        if (m->mixer_fdl) {
+            pa_alsa_fdlist_free(m->mixer_fdl);
+            m->mixer_fdl = NULL;
+        }
+
+        pa_xfree(m);
+    }
+
+    return NULL;
+}
+
+/** Load mixers using comma separated string list.
+ *
+ * return number of successfully loaded mixer elements
+ */
+static int get_mixer_elements(struct userdata *u, const char *mixer_list) {
+    const char *state = NULL;
+    struct mixer_control_t *m = NULL;
+    int count = 0;
+    char *mixer;
+    pa_assert(u);
+    pa_assert(mixer_list);
+
+    while ((mixer = pa_split(mixer_list, ",", &state))) {
+        m = get_mixer_element(u, mixer);
+        if (m) {
+            PA_LLIST_PREPEND(struct mixer_control_t, u->mixer_list, m);
+            count++;
+        }
+        pa_xfree(mixer);
+    }
+
+    return count;
+}
+
+static void free_mixer_element(struct mixer_control_t *m) {
+    unsigned i;
+    pa_xfree(m->name);
+    pa_alsa_fdlist_free(m->mixer_fdl);
+    m->mixer_elem = NULL;
+
+    for (i = 0; i < MAX_TUNING_TABLES; i++) {
+        if (m->tuning_data[i].tuning_table) {
+            pa_xfree(m->tuning_data[i].tuning_table);
+            m->tuning_data[i].tuning_table = NULL;
+        }
+    }
+
+    pa_xfree(m);
+}
+
+static void free_mixer_elements(struct userdata *u) {
+    struct mixer_control_t *m;
+    log_spam("free mixer elements");
+
+    u->active_mixer = NULL;
+
+    while ((m = u->mixer_list)) {
+        PA_LLIST_REMOVE(struct mixer_control_t, u->mixer_list, m);
+        free_mixer_element(m);
+    }
+}
+
+static void replace_chars(char *str, const char c, const char new_c) {
+    int ii = -1;
+    pa_assert(str);
+    while(str[++ii] != '\0') {
+        if (str[ii] == c)
+            str[ii] = new_c;
+    }
+}
+
+int pa__init(pa_module*m) {
+
+    pa_sink *hw_sink = NULL;
+    pa_modargs *ma = NULL;
+    struct userdata *u = NULL;
+    char *alsa_mixer = NULL;
+    char *mixer_load = NULL;
+    int err;
+    const char *sink_name;
+
+    pa_assert(m);
+
+    if (global_userdata != NULL)  {
+        pa_log_error("There can only be one instance of module: %s", m->name);
+        pa_log_info("The existing instace is connected to: %s", global_userdata->sink->name);
+        goto fail;
+    }
+
+    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+        pa_log_error("Failed to parse module arguments");
+        goto fail;
+    }
+
+    sink_name = pa_modargs_get_value(ma, "sink_name", NULL);
+    if (!sink_name) {
+        pa_log_error("No sink_name defined.");
+        goto fail;
+    }
+
+    hw_sink = pa_namereg_get(m->core, sink_name, PA_NAMEREG_SINK);
+    if (!hw_sink) {
+        pa_log_error("Couldn't get sink with name %s", sink_name);
+        goto fail;
+    }
+
+    alsa_mixer = pa_xstrdup(pa_modargs_get_value(ma, "mixer", "Master"));
+    replace_chars(alsa_mixer, '_', ' ');
+
+    if (pa_modargs_get_value(ma, "mixer_load", NULL)) {
+        mixer_load = pa_xstrdup(pa_modargs_get_value(ma, "mixer_load", NULL));
+        replace_chars(mixer_load, '_', ' ');
+        pa_log_info("preload mixers %s", mixer_load);
+    } else {
+        /* Default to loading alsa_mixer, if mixer_load is not defined. */
+        mixer_load = pa_xstrdup(alsa_mixer);
+    }
+
+
+    u = pa_xnew0(struct userdata, 1);
+    u->core = m->core;
+    u->module = m;
+    m->userdata = u;
+
+    global_userdata = u;
+
+    init_mixer_lock(&u->lock);
+    u->sink = hw_sink;
+    u->active_tuning = PROP_MIXER_TUNING_PRI;
+
+    /* get orignal variable values from sink */
+    u->original_flags = u->sink->flags;
+    u->original_get_volume = u->sink->get_volume;
+    u->original_set_volume = u->sink->set_volume;
+    u->original_write_volume = u->sink->write_volume;
+    u->original_get_mute = u->sink->get_mute;
+    u->original_set_mute = u->sink->set_mute;
+
+    if (pa_modargs_get_value(ma, "device", NULL))
+        u->device_name = pa_xstrdup(pa_modargs_get_value(ma, "device", NULL));
+    else if (pa_proplist_gets(u->sink->proplist, PA_PROP_DEVICE_STRING))
+        u->device_name = pa_xstrdup(pa_proplist_gets(u->sink->proplist, PA_PROP_DEVICE_STRING));
+
+    if (!u->device_name) {
+        pa_log_error("No device name defined or detected from sink");
+        goto fail;
+    }
+
+    if ((err = snd_mixer_open(&u->mixer_handle, 0)) < 0) {
+        pa_log_error("Error opening mixer: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if (pa_alsa_prepare_mixer(u->mixer_handle, u->device_name) < 0) {
+        pa_log_error("couldn't prepare mixer with %s", u->device_name);
+        snd_mixer_close(u->mixer_handle);
+        u->mixer_handle = NULL;
+        goto fail;
+    }
+
+    if (get_mixer_elements(u, mixer_load) <= 0) {
+        pa_log_error("No suitable mixer elements found, no point to continue");
+        goto fail;
+    }
+
+    /* TODO: Read from parameters? */
+    u->sw_vol_compensation = TRUE;
+    if (pa_modargs_get_value(ma, "software_volume", NULL)) {
+        if (pa_parse_boolean(pa_modargs_get_value(ma, "software_volume", NULL)) == 0)
+            u->sw_vol_compensation = FALSE;
+    }
+
+    /* hook in case the sink is unloaded */
+    u->sink_unlink_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_UNLINK],
+                                          PA_HOOK_LATE,
+                                          (pa_hook_cb_t)sink_unlink_hook_callback, u);
+
+    /* hook for mixer switching */
+    u->sink_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_PROPLIST_CHANGED],
+                                                    PA_HOOK_LATE,
+                                                    (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
+    /* Try to load the initial mixer settings. */
+    (void)sink_proplist_changed_hook_callback(u->core, u->sink, u);
+
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
+    if (mixer_load)
+        pa_xfree(mixer_load);
+
+    pa_modargs_free(ma);
+
+    return 0;
+
+ fail:
+
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
+    if (mixer_load)
+        pa_xfree(mixer_load);
+
+    if (ma)
+        pa_modargs_free(ma);
+
+    pa__done(m);
+
+    return -1;
+}
+
+void pa__done(pa_module*m) {
+    struct userdata *u;
+
+    pa_assert(m);
+
+    if (!(u = m->userdata))
+        return;
+
+    enter_initialization(u);
+    free_mixer_lock(&u->lock);
+
+    if (u->sink_proplist_changed_slot)
+        pa_hook_slot_free(u->sink_proplist_changed_slot);
+    if (u->sink_unlink_slot)
+        pa_hook_slot_free(u->sink_unlink_slot);
+
+    if (u->mixer_list)
+        free_mixer_elements(u);
+
+    if (u->audio_mode)
+        pa_xfree(u->audio_mode);
+
+    if (u->mixer_handle)
+        snd_mixer_close(u->mixer_handle);
+
+    /* Restore original volume controls, if the sink is still there */
+    if (u->sink) {
+        u->sink->flags = u->original_flags;
+        u->sink->get_volume = u->original_get_volume;
+        u->sink->set_volume = u->original_set_volume;
+        u->sink->write_volume = u->original_write_volume;
+        u->sink->get_mute = u->original_get_mute;
+        u->sink->set_mute = u->original_set_mute;
+        pa_sink_get_volume(u->sink, TRUE, FALSE);
+        pa_sink_get_mute(u->sink, TRUE);
+    }
+
+    global_userdata = NULL;
+
+    pa_xfree(u->device_name);
+    pa_xfree(u);
+
+    snd_config_update_free_global();
+}
-- 
1.6.3.3

