From 54387b8de81a749f2a65faca7e0ae27eccc603e6 Mon Sep 17 00:00:00 2001
From: Juho Hamalainen <ext-juho.hamalainen@nokia.com>
Date: Mon, 17 Nov 2008 19:50:30 +0200
Subject: [PATCH] alsa-old: dynamic switching of buffer metrics (Nokia specific)

Controlled with dbus.
---
 src/Makefile.am                      |   26 ++--
 src/modules/module-alsa-sink-old.c   |  320 +++++++++++++++++++++++++++++++++-
 src/modules/module-alsa-source-old.c |  321 +++++++++++++++++++++++++++++++++-
 3 files changed, 649 insertions(+), 18 deletions(-)

diff --git a/src/Makefile.am b/src/Makefile.am
index 7766c2e..c88c223 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1122,14 +1122,23 @@ modlibexec_LTLIBRARIES += \
 		module-oss.la
 endif
 
+if HAVE_DBUS
+modlibexec_LTLIBRARIES += \
+		libdbus-util.la \
+		module-console-kit.la
+endif
+
 if HAVE_ALSA
 modlibexec_LTLIBRARIES += \
 		libalsa-util.la \
 		module-alsa-sink.la \
+		module-alsa-source.la
+if HAVE_DBUS
+modlibexec_LTLIBRARIES += \
 		module-alsa-sink-old.la \
-		module-alsa-source.la \
 		module-alsa-source-old.la
 endif
+endif
 
 if HAVE_SOLARIS
 modlibexec_LTLIBRARIES += \
@@ -1179,12 +1188,6 @@ modlibexec_LTLIBRARIES += \
 		module-hal-detect.la
 endif
 
-if HAVE_DBUS
-modlibexec_LTLIBRARIES += \
-		libdbus-util.la \
-		module-console-kit.la
-endif
-
 if HAVE_BLUEZ
 modlibexec_LTLIBRARIES += \
 		module-bluetooth-proximity.la \
@@ -1446,7 +1449,6 @@ module_oss_la_LDFLAGS = -module -avoid-version
 module_oss_la_LIBADD = $(AM_LIBADD) libiochannel.la liboss-util.la libpulsecore.la
 
 # ALSA
-
 libalsa_util_la_SOURCES = modules/alsa-util.c modules/alsa-util.h
 libalsa_util_la_LDFLAGS = -avoid-version
 libalsa_util_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libpulsecore.la
@@ -1459,8 +1461,8 @@ module_alsa_sink_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
 
 module_alsa_sink_old_la_SOURCES = modules/module-alsa-sink-old.c
 module_alsa_sink_old_la_LDFLAGS = -module -avoid-version
-module_alsa_sink_old_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore.la
-module_alsa_sink_old_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
+module_alsa_sink_old_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) $(DBUS_LIBS) libalsa-util.la libpulsecore.la libdbus-util.la
+module_alsa_sink_old_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS) $(DBUS_CFLAGS)
 
 module_alsa_source_la_SOURCES = modules/module-alsa-source.c
 module_alsa_source_la_LDFLAGS = -module -avoid-version
@@ -1469,8 +1471,8 @@ module_alsa_source_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
 
 module_alsa_source_old_la_SOURCES = modules/module-alsa-source-old.c
 module_alsa_source_old_la_LDFLAGS = -module -avoid-version
-module_alsa_source_old_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore.la
-module_alsa_source_old_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
+module_alsa_source_old_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) $(DBUS_LIBS) libalsa-util.la libpulsecore.la libdbus-util.la
+module_alsa_source_old_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS) $(DBUS_CFLAGS)
 
 # Solaris
 
diff --git a/src/modules/module-alsa-sink-old.c b/src/modules/module-alsa-sink-old.c
index 9578dac..e3c0493 100644
--- a/src/modules/module-alsa-sink-old.c
+++ b/src/modules/module-alsa-sink-old.c
@@ -47,6 +47,12 @@
 #include <pulsecore/thread-mq.h>
 #include <pulsecore/rtpoll.h>
 
+// dbus
+#include <poll.h>
+#include <string.h>
+#include <dbus/dbus.h>
+#include <dbus-util.h>
+
 #include "alsa-util.h"
 #include "module-alsa-sink-old-symdef.h"
 
@@ -63,8 +69,11 @@ PA_MODULE_USAGE(
         "rate=<sample rate> "
         "fragments=<number of fragments> "
         "fragment_size=<fragment size> "
+        "alt_fragments=<number of fragments> "
+        "alt_fragment_size=<fragment size> "
         "channel_map=<channel map> "
-        "mmap=<enable memory mapping?>");
+        "mmap=<enable memory mapping?> "
+        "dbus_type=<session/system>");
 
 #define DEFAULT_DEVICE "default"
 
@@ -89,6 +98,17 @@ struct userdata {
     unsigned nfragments;
     pa_memchunk memchunk;
 
+    size_t pri_frame_size, pri_fragment_size, pri_hwbuf_size;
+    snd_pcm_uframes_t pri_period_size;
+    unsigned pri_nfragments;
+    
+    size_t alt_frame_size, alt_fragment_size, alt_hwbuf_size;
+    snd_pcm_uframes_t alt_period_size;
+    unsigned alt_nfragments;
+
+    int switch_mode;
+    pa_bool_t switch_done;
+
     char *device_name;
 
     pa_bool_t use_mmap;
@@ -98,6 +118,12 @@ struct userdata {
     pa_rtpoll_item *alsa_rtpoll_item;
 
     snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
+
+    struct alsa_switch_event_forwarder {
+        DBusBusType dbus_type;
+        pa_dbus_connection *dbus_conn;
+        char *dbus_match_rules[32];
+    } event_forwarder;
 };
 
 static const char* const valid_modargs[] = {
@@ -109,11 +135,231 @@ static const char* const valid_modargs[] = {
     "rate",
     "fragments",
     "fragment_size",
+    "alt_fragments",
+    "alt_fragment_size",
     "channel_map",
     "mmap",
+    "dbus_type",
     NULL
 };
 
+/** DBUS STUFF */
+
+static void switch_buffers(struct userdata *u, int switch_mode);
+static int alsa_switch_init_event_forwarder(struct userdata *u, char *dbus_type);
+static void alsa_switch_unload_event_forwarder(struct userdata *u);
+static int add_dbus_match(struct alsa_switch_event_forwarder *e, DBusConnection *dbusconn, char *match);
+static void clear_dbus_matches(struct alsa_switch_event_forwarder *e, DBusConnection *dbusconn);
+
+static DBusHandlerResult alsa_switch_dbus_filter(DBusConnection *conn, DBusMessage *msg, void *arg);
+
+#define DBUS_ALSA_SWITCH_IF    "com.nokia.alsaswitch"
+#define DBUS_ALSA_SWITCH_SIG   "sink"
+#define DBUS_CSCALL_STATUS_IF  "com.nokia.csd.Call"
+#define DBUS_CSCALL_STATUS_SIG "ServerStatus"
+
+#define SWITCH_PRIMARY (0)
+#define SWITCH_ALTERNATIVE (1)
+
+static DBusHandlerResult alsa_switch_dbus_filter(DBusConnection *conn, DBusMessage *msg, void *arg) { 
+    struct userdata *u = arg;
+    pa_assert(u);
+
+    DBusError dbus_error;
+    dbus_error_init(&dbus_error);
+    int rateswitch = 0;
+    DBusMessageIter args;
+    int type;
+
+    if (dbus_message_is_signal(msg, DBUS_ALSA_SWITCH_IF, DBUS_ALSA_SWITCH_SIG)) {
+    
+        dbus_message_get_args(msg, &dbus_error,
+                              DBUS_TYPE_INT32, &rateswitch,
+                              DBUS_TYPE_INVALID);
+
+        if (dbus_error_is_set(&dbus_error) != TRUE) { 
+            pa_log_info("received rate switch request %d", rateswitch);
+        } else {
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        }       
+
+        if (u->switch_mode == rateswitch)
+        {       
+            pa_log_info("same rate as previously");
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        }       
+
+        switch_buffers(u, rateswitch);
+         
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    } else if (dbus_message_is_signal(msg, DBUS_CSCALL_STATUS_IF, DBUS_CSCALL_STATUS_SIG)) {
+        pa_log_debug("Received ServerStatus");
+
+        if (dbus_message_iter_init(msg, &args) == TRUE) { 
+            type = dbus_message_iter_get_arg_type(&args);
+            dbus_bool_t val;
+            if (type == DBUS_TYPE_BOOLEAN) {
+                dbus_message_iter_get_basic(&args, &val);
+            }       
+
+            pa_log_debug("Set ServerStatus to %d.", val == TRUE);
+
+            if (u->switch_mode == (val == TRUE)) {
+                pa_log_info("same rate as previously");
+                return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+            }
+            switch_buffers(u, val == TRUE);
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+        } else {
+            pa_log_warn("Bad parameters.");
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        }
+    } else {
+        pa_log_debug("Not our signal.");
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }
+}
+
+static int alsa_switch_init_event_forwarder(struct userdata *u, char *dbus_type)
+{
+    struct alsa_switch_event_forwarder *e = &u->event_forwarder;
+    DBusConnection          *dbusconn;
+    DBusError                error;
+    char                     rule[512];
+
+    if (0 == strcasecmp(dbus_type, "system"))
+    e->dbus_type = DBUS_BUS_SYSTEM;
+    else
+    e->dbus_type = DBUS_BUS_SESSION;
+
+#define STRBUSTYPE(DBusType) ((DBusType) == DBUS_BUS_SYSTEM ? "system" : "session")
+
+    pa_log_info("DBus connection to %s bus.", STRBUSTYPE(e->dbus_type));
+
+    dbus_error_init(&error);
+    e->dbus_conn = pa_dbus_bus_get(u->core, e->dbus_type, &error);
+
+    if (e->dbus_conn == NULL || dbus_error_is_set(&error)) {
+        pa_log_error("Failed to get %s Bus: %s: %s", STRBUSTYPE(e->dbus_type), error.name, error.message);
+        goto fail;
+    }
+
+    memset(&e->dbus_match_rules, 0, sizeof(e->dbus_match_rules));
+    dbusconn = pa_dbus_connection_get(e->dbus_conn);
+
+    if (!dbus_connection_add_filter(dbusconn, alsa_switch_dbus_filter, u, NULL)) {
+        pa_log("failed to add filter function");
+        goto fail;
+    }
+
+
+    snprintf(rule, sizeof(rule), "type='signal',interface='%s'", DBUS_ALSA_SWITCH_IF);
+    if (add_dbus_match(e, dbusconn, rule)) {
+        goto fail;
+    }
+
+    snprintf(rule, sizeof(rule), "type='signal',interface='%s'", DBUS_CSCALL_STATUS_IF);
+    if (add_dbus_match(e, dbusconn, rule)) {
+        goto fail;
+    }
+
+
+    return 0;
+
+ fail:
+    alsa_switch_unload_event_forwarder(u);
+    dbus_error_free(&error);
+    return 1;
+}
+
+static void alsa_switch_unload_event_forwarder(struct userdata *u)
+{
+    struct alsa_switch_event_forwarder *e = &u->event_forwarder;
+
+    if (e->dbus_conn) {
+    DBusConnection *dbusconn = pa_dbus_connection_get(e->dbus_conn);
+
+    dbus_connection_remove_filter(dbusconn, alsa_switch_dbus_filter, u);
+
+    clear_dbus_matches(e, dbusconn);
+
+    pa_dbus_connection_unref(e->dbus_conn);
+    }
+}
+
+
+static int add_dbus_match(struct alsa_switch_event_forwarder *e, DBusConnection *dbusconn, char *match)
+{
+    DBusError error;
+    int i;
+
+    dbus_error_init(&error);
+
+    for(i = 0; i < PA_ELEMENTSOF(e->dbus_match_rules) && e->dbus_match_rules[i] != NULL; i++);
+
+    pa_return_val_if_fail (i < PA_ELEMENTSOF(e->dbus_match_rules), -1);
+
+    dbus_bus_add_match(dbusconn, match, &error);
+    if (dbus_error_is_set(&error)) {
+        pa_log_error("Unable to add dbus match:\"%s\": %s: %s", match, error.name, error.message);
+        return -1;;
+    }
+
+    e->dbus_match_rules[i] = pa_xstrdup(match);
+    pa_log_debug("added dbus match \"%s\"", match);
+
+    return 0;
+}
+
+static void clear_dbus_matches(struct alsa_switch_event_forwarder *e, DBusConnection *dbusconn)
+{
+    int i;
+
+    for(i = PA_ELEMENTSOF(e->dbus_match_rules) - 1; i >= 0; i--) {
+        if (e->dbus_match_rules[i] == NULL)
+            continue;
+
+        dbus_bus_remove_match(dbusconn, e->dbus_match_rules[i], NULL);
+        pa_log_debug("removed dbus match \"%s\"", e->dbus_match_rules[i]);
+        pa_xfree(e->dbus_match_rules[i]);
+        e->dbus_match_rules[i] = NULL;
+    }
+}
+
+static void switch_buffers(struct userdata *u, int switch_mode) {
+    u->switch_mode = switch_mode;
+
+    pa_assert(u->sink);
+    unsigned int num_inputs = pa_idxset_size(u->sink->inputs);
+    pa_log_debug("switch_buffers()  got %d inputs", num_inputs);
+
+    pa_sink_suspend(u->sink, TRUE);
+
+    if (u->switch_mode == SWITCH_PRIMARY) {
+        pa_log_info("switch to primary buffer");
+        u->frame_size = u->pri_frame_size;
+        u->fragment_size = u->pri_fragment_size;
+        u->hwbuf_size = u->pri_hwbuf_size;
+        u->nfragments = u->pri_nfragments;
+        u->period_size = u->pri_period_size;
+    } else {
+        pa_log_info("switch to alternate buffer");
+        u->frame_size = u->alt_frame_size;
+        u->fragment_size = u->alt_fragment_size;
+        u->hwbuf_size = u->alt_hwbuf_size;
+        u->nfragments = u->alt_nfragments;
+        u->period_size = u->alt_period_size;
+    }
+
+    if (num_inputs > 0) {
+        pa_sink_suspend(u->sink, FALSE);
+    }
+
+    u->switch_done = FALSE;
+}
+
 static int mmap_write(struct userdata *u) {
     int work_done = 0;
 
@@ -476,6 +722,33 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
             }
 
             break;
+
+        case PA_SINK_MESSAGE_ADD_INPUT:
+            if (!u->switch_done) {
+                if (u->switch_mode == SWITCH_PRIMARY) {
+                    pa_log_info("switch to primary buffer");
+                    suspend(u);
+                    u->frame_size = u->pri_frame_size;
+                    u->fragment_size = u->pri_fragment_size;
+                    u->hwbuf_size = u->pri_hwbuf_size;
+                    u->nfragments = u->pri_nfragments;
+                    u->period_size = u->pri_period_size;
+                    unsuspend(u);
+                } else {
+                    pa_log_info("switch to alternate buffer");
+                    suspend(u); 
+                    u->frame_size = u->alt_frame_size;
+                    u->fragment_size = u->alt_fragment_size;
+                    u->hwbuf_size = u->alt_hwbuf_size;
+                    u->nfragments = u->alt_nfragments;
+                    u->period_size = u->alt_period_size;
+                    unsuspend(u);
+                }
+                u->switch_done = TRUE;
+            }
+            break;
+        case PA_SINK_MESSAGE_REMOVE_INPUT:
+            break;
     }
 
     return pa_sink_process_msg(o, code, data, offset, chunk);
@@ -723,8 +996,11 @@ int pa__init(pa_module*m) {
     pa_sample_spec ss;
     pa_channel_map map;
     uint32_t nfrags, frag_size;
+    uint32_t alt_nfrags, alt_frag_size;
     snd_pcm_uframes_t period_size;
+    snd_pcm_uframes_t alt_period_size;
     size_t frame_size;
+    size_t alt_frame_size;
     snd_pcm_info_t *pcm_info = NULL;
     int err;
     char *t;
@@ -732,6 +1008,7 @@ int pa__init(pa_module*m) {
     char *name_buf = NULL;
     int namereg_fail;
     pa_bool_t use_mmap = TRUE, b, d;
+    const char *dbus_type;
     pa_sink_new_data data;
 
     snd_pcm_info_alloca(&pcm_info);
@@ -743,6 +1020,8 @@ int pa__init(pa_module*m) {
         goto fail;
     }
 
+    dbus_type = pa_modargs_get_value(ma, "dbus_type", "session");
+
     ss = m->core->default_sample_spec;
     if (pa_modargs_get_sample_spec_and_channel_map(ma, &ss, &map, PA_CHANNEL_MAP_ALSA) < 0) {
         pa_log("Failed to parse sample specification and channel map");
@@ -761,6 +1040,19 @@ int pa__init(pa_module*m) {
         goto fail;
     }
     period_size = frag_size/frame_size;
+    
+    alt_frame_size = pa_frame_size(&ss);
+
+    alt_nfrags = m->core->default_n_fragments;
+    alt_frag_size = pa_usec_to_bytes(m->core->default_fragment_size_msec*1000, &ss);
+    if (alt_frag_size <= 0)
+        alt_frag_size = alt_frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "alt_fragments", &alt_nfrags) < 0 || pa_modargs_get_value_u32(ma, "alt_fragment_size", &alt_frag_size) < 0) {
+        pa_log("Failed to parse alt buffer metrics");
+        goto fail;
+    }
+    alt_period_size = alt_frag_size/alt_frame_size;
 
     if (pa_modargs_get_value_boolean(ma, "mmap", &use_mmap) < 0) {
         pa_log("Failed to parse mmap argument.");
@@ -768,6 +1060,8 @@ int pa__init(pa_module*m) {
     }
 
     u = pa_xnew0(struct userdata, 1);
+    u->switch_mode = SWITCH_PRIMARY;
+    u->switch_done = TRUE;
     u->core = m->core;
     u->module = m;
     m->userdata = u;
@@ -830,6 +1124,7 @@ int pa__init(pa_module*m) {
 
     /* ALSA might tweak the sample spec, so recalculate the frame size */
     frame_size = pa_frame_size(&ss);
+    alt_frame_size = pa_frame_size(&ss);
 
     if ((err = snd_mixer_open(&u->mixer_handle, 0)) < 0)
         pa_log_warn("Error opening mixer: %s", snd_strerror(err));
@@ -908,8 +1203,21 @@ int pa__init(pa_module*m) {
     u->nfragments = nfrags;
     u->hwbuf_size = u->fragment_size * nfrags;
     u->period_size = period_size;
-
-    pa_log_info("Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->fragment_size);
+    
+    u->pri_frame_size = frame_size;
+    u->pri_fragment_size = frag_size = period_size * frame_size;
+    u->pri_nfragments = nfrags;
+    u->pri_hwbuf_size = u->fragment_size * nfrags;
+    u->pri_period_size = period_size;
+    
+    u->alt_frame_size = alt_frame_size;
+    u->alt_fragment_size = alt_frag_size = alt_period_size * alt_frame_size;
+    u->alt_nfragments = alt_nfrags;
+    u->alt_hwbuf_size = u->alt_fragment_size * alt_nfrags;
+    u->alt_period_size = alt_period_size;
+
+    pa_log_info("PRI: Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->fragment_size);
+    pa_log_info("ALT: Using %u fragments of size %lu bytes.", alt_nfrags, (long unsigned) u->alt_fragment_size);
 
     pa_memchunk_reset(&u->memchunk);
 
@@ -955,6 +1263,10 @@ int pa__init(pa_module*m) {
 
     pa_sink_put(u->sink);
 
+    if (alsa_switch_init_event_forwarder(u, dbus_type)) {
+        goto fail;
+    }
+
     pa_modargs_free(ma);
 
     return 0;
@@ -977,6 +1289,8 @@ void pa__done(pa_module*m) {
     if (!(u = m->userdata))
         return;
 
+    alsa_switch_unload_event_forwarder(u);
+
     if (u->sink)
         pa_sink_unlink(u->sink);
 
diff --git a/src/modules/module-alsa-source-old.c b/src/modules/module-alsa-source-old.c
index 63850f2..1c65ccb 100644
--- a/src/modules/module-alsa-source-old.c
+++ b/src/modules/module-alsa-source-old.c
@@ -48,6 +48,12 @@
 #include <pulsecore/thread-mq.h>
 #include <pulsecore/rtpoll.h>
 
+// dbus
+#include <poll.h>
+#include <string.h>
+#include <dbus/dbus.h>
+#include <dbus-util.h>
+
 #include "alsa-util.h"
 #include "module-alsa-source-old-symdef.h"
 
@@ -64,8 +70,11 @@ PA_MODULE_USAGE(
         "rate=<sample rate> "
         "fragments=<number of fragments> "
         "fragment_size=<fragment size> "
+        "alt_fragments=<number of fragments> "
+        "alt_fragment_size=<fragment size> "
         "channel_map=<channel map> "
-        "mmap=<enable memory mapping?>");
+        "mmap=<enable memory mapping?> "
+        "dbus_type=<system/session>");
 
 #define DEFAULT_DEVICE "default"
 
@@ -89,6 +98,19 @@ struct userdata {
     snd_pcm_uframes_t period_size;
     unsigned nfragments;
 
+    size_t pri_frame_size, pri_fragment_size, pri_hwbuf_size;
+    snd_pcm_uframes_t pri_period_size;
+    unsigned pri_nfragments;
+    
+    size_t alt_frame_size, alt_fragment_size, alt_hwbuf_size;
+    snd_pcm_uframes_t alt_period_size;
+    unsigned alt_nfragments;
+    
+    int switch_mode;
+    pa_bool_t switch_done;
+    long ref;
+    pa_bool_t init_done;
+
     char *device_name;
 
     pa_bool_t use_mmap;
@@ -96,6 +118,12 @@ struct userdata {
     pa_rtpoll_item *alsa_rtpoll_item;
 
     snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
+
+    struct alsa_switch_event_forwarder {
+        DBusBusType dbus_type;
+        pa_dbus_connection *dbus_conn;
+        char *dbus_match_rules[32];
+    } event_forwarder;
 };
 
 static const char* const valid_modargs[] = {
@@ -107,11 +135,235 @@ static const char* const valid_modargs[] = {
     "format",
     "fragments",
     "fragment_size",
+    "alt_fragments",
+    "alt_fragment_size",
     "channel_map",
     "mmap",
+    "dbus_type",
     NULL
 };
 
+#define SWITCH_PRIMARY (0)
+#define SWITCH_ALTERNATIVE (1)
+static void switch_buffers(struct userdata *u, int switch_mode);
+
+/** DBUS STUFF */
+static int alsa_switch_init_event_forwarder(struct userdata *u, char *dbus_type);
+static void alsa_switch_unload_event_forwarder(struct userdata *u);
+static int add_dbus_match(struct alsa_switch_event_forwarder *e, DBusConnection *dbusconn, char *match);
+static void clear_dbus_matches(struct alsa_switch_event_forwarder *e, DBusConnection *dbusconn);
+static DBusHandlerResult alsa_switch_dbus_filter(DBusConnection *conn, DBusMessage *msg, void *arg);
+
+#define DBUS_ALSA_SWITCH_IF    "com.nokia.alsaswitch"
+#define DBUS_ALSA_SWITCH_SIG   "src"
+#define DBUS_CSCALL_STATUS_IF  "com.nokia.csd.Call"
+#define DBUS_CSCALL_STATUS_SIG "ServerStatus"
+
+static DBusHandlerResult alsa_switch_dbus_filter(DBusConnection *conn, DBusMessage *msg, void *arg) {
+    struct userdata *u = arg; 
+    pa_assert(u);
+
+    DBusError dbus_error;
+    dbus_error_init(&dbus_error);
+    int rateswitch = 0;
+    DBusMessageIter args;
+    int type;
+
+    if (dbus_message_is_signal(msg, DBUS_ALSA_SWITCH_IF, DBUS_ALSA_SWITCH_SIG)) {
+    
+        dbus_message_get_args(msg, &dbus_error,
+                              DBUS_TYPE_INT32, &rateswitch,
+                              DBUS_TYPE_INVALID);
+
+        if (dbus_error_is_set(&dbus_error) != TRUE) {
+            pa_log_info("received rate switch request %d", rateswitch);
+        } else {
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        }    
+
+        if (u->switch_mode == rateswitch)
+        {
+            pa_log_info("same rate as previously");
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        }        
+
+        switch_buffers(u, rateswitch);
+     
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+    } else if (dbus_message_is_signal(msg, DBUS_CSCALL_STATUS_IF, DBUS_CSCALL_STATUS_SIG)) {
+        pa_log_debug("Received ServerStatus");
+
+        if (dbus_message_iter_init(msg, &args) == TRUE) {
+            type = dbus_message_iter_get_arg_type(&args);
+            dbus_bool_t val;
+            if (type == DBUS_TYPE_BOOLEAN) {
+                dbus_message_iter_get_basic(&args, &val);
+            }    
+
+            pa_log_debug("Set ServerStatus to %d.", val == TRUE);
+
+            if (u->switch_mode == (val == TRUE)) {
+                pa_log_info("same rate as previously");
+                return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+            }        
+            switch_buffers(u, val == TRUE);
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+
+        } else { 
+            pa_log_warn("Bad parameters.");
+            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+        }        
+    } else {     
+        pa_log_debug("Not our signal.");
+        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+    }        
+}
+
+static int alsa_switch_init_event_forwarder(struct userdata *u, char *dbus_type)
+{
+    struct alsa_switch_event_forwarder *e = &u->event_forwarder;
+    DBusConnection          *dbusconn;
+    DBusError                error;
+    char                     rule[512];
+
+    if (0 == strcasecmp(dbus_type, "system"))
+    e->dbus_type = DBUS_BUS_SYSTEM;
+    else
+    e->dbus_type = DBUS_BUS_SESSION;
+
+#define STRBUSTYPE(DBusType) ((DBusType) == DBUS_BUS_SYSTEM ? "system" : "session")
+
+    pa_log_info("DBus connection to %s bus.", STRBUSTYPE(e->dbus_type));
+
+    dbus_error_init(&error);
+    e->dbus_conn = pa_dbus_bus_get(u->core, e->dbus_type, &error);
+
+    if (e->dbus_conn == NULL || dbus_error_is_set(&error)) {
+        pa_log_error("Failed to get %s Bus: %s: %s", STRBUSTYPE(e->dbus_type), error.name, error.message);
+        goto fail;
+    }
+
+    memset(&e->dbus_match_rules, 0, sizeof(e->dbus_match_rules));
+    dbusconn = pa_dbus_connection_get(e->dbus_conn);
+
+    if (!dbus_connection_add_filter(dbusconn, alsa_switch_dbus_filter, u, NULL)) {
+        pa_log("failed to add filter function");
+        goto fail;
+    }
+
+
+    snprintf(rule, sizeof(rule), "type='signal',interface='%s'", DBUS_ALSA_SWITCH_IF);
+    if (add_dbus_match(e, dbusconn, rule)) {
+        goto fail;
+    }
+
+    snprintf(rule, sizeof(rule), "type='signal',interface='%s'", DBUS_CSCALL_STATUS_IF);
+    if (add_dbus_match(e, dbusconn, rule)) {
+        goto fail;
+    }
+
+
+    return 0;
+
+ fail:
+    alsa_switch_unload_event_forwarder(u);
+    dbus_error_free(&error);
+    return 1;
+}
+
+static void alsa_switch_unload_event_forwarder(struct userdata *u)
+{
+    struct alsa_switch_event_forwarder *e = &u->event_forwarder;
+
+    if (e->dbus_conn) {
+    DBusConnection *dbusconn = pa_dbus_connection_get(e->dbus_conn);
+
+    dbus_connection_remove_filter(dbusconn, alsa_switch_dbus_filter, u);
+
+    clear_dbus_matches(e, dbusconn);
+
+    pa_dbus_connection_unref(e->dbus_conn);
+    }
+}
+
+static int add_dbus_match(struct alsa_switch_event_forwarder *e, DBusConnection *dbusconn, char *match)
+{
+    DBusError error;
+    int i;
+
+    dbus_error_init(&error);
+
+    for(i = 0; i < PA_ELEMENTSOF(e->dbus_match_rules) && e->dbus_match_rules[i] != NULL; i++);
+
+    pa_return_val_if_fail (i < PA_ELEMENTSOF(e->dbus_match_rules), -1);
+
+    dbus_bus_add_match(dbusconn, match, &error);
+    if (dbus_error_is_set(&error)) {
+        pa_log_error("Unable to add dbus match:\"%s\": %s: %s", match, error.name, error.message);
+        return -1;;
+    }
+
+    e->dbus_match_rules[i] = pa_xstrdup(match);
+    pa_log_debug("added dbus match \"%s\"", match);
+
+    return 0;
+}
+
+static void clear_dbus_matches(struct alsa_switch_event_forwarder *e, DBusConnection *dbusconn)
+{
+    int i;
+
+    for(i = PA_ELEMENTSOF(e->dbus_match_rules) - 1; i >= 0; i--) {
+        if (e->dbus_match_rules[i] == NULL)
+            continue;
+
+        dbus_bus_remove_match(dbusconn, e->dbus_match_rules[i], NULL);
+        pa_log_debug("removed dbus match \"%s\"", e->dbus_match_rules[i]);
+        pa_xfree(e->dbus_match_rules[i]);
+        e->dbus_match_rules[i] = NULL;
+    }
+}
+
+
+/*** DBUS STUFF ENDS
+ */
+
+static void switch_buffers(struct userdata *u, int switch_mode) {
+    u->switch_mode = switch_mode;
+
+    pa_assert(u->source);
+    unsigned int num_outputs = pa_idxset_size(u->source->outputs);
+    pa_log_debug("switch_buffers()  got %d outputs", num_outputs);
+
+    pa_source_suspend(u->source, TRUE);
+
+    if (u->switch_mode == SWITCH_PRIMARY) {
+        pa_log_info("switch to primary buffer");
+        u->frame_size = u->pri_frame_size;
+        u->fragment_size = u->pri_fragment_size;
+        u->hwbuf_size = u->pri_hwbuf_size;
+        u->nfragments = u->pri_nfragments;
+        u->period_size = u->pri_period_size;
+    } else {
+        pa_log_info("switch to alternate buffer");
+        u->frame_size = u->alt_frame_size;
+        u->fragment_size = u->alt_fragment_size;
+        u->hwbuf_size = u->alt_hwbuf_size;
+        u->nfragments = u->alt_nfragments;
+        u->period_size = u->alt_period_size;
+    }
+
+    if (num_outputs > 0) {
+        pa_source_suspend(u->source, FALSE);
+    }
+
+    u->switch_done = FALSE;
+}
+
+
+
+
 static int mmap_read(struct userdata *u) {
     int work_done = 0;
 
@@ -467,6 +719,30 @@ static int source_process_msg(pa_msgobject *o, int code, void *data, int64_t off
             }
 
             break;
+
+        case PA_SOURCE_MESSAGE_ADD_OUTPUT:
+            if (!u->switch_done) {
+                if (u->switch_mode == SWITCH_PRIMARY) {
+                    suspend(u);
+                    u->frame_size = u->pri_frame_size;
+                    u->fragment_size = u->pri_fragment_size;
+                    u->hwbuf_size = u->pri_hwbuf_size;
+                    u->nfragments = u->pri_nfragments;
+                    u->period_size = u->pri_period_size;
+                    unsuspend(u);
+                } else {
+                    suspend(u);
+                    u->frame_size = u->alt_frame_size;
+                    u->fragment_size = u->alt_fragment_size;
+                    u->hwbuf_size = u->alt_hwbuf_size;
+                    u->nfragments = u->alt_nfragments;
+                    u->period_size = u->alt_period_size;
+                    unsuspend(u);
+                }
+                u->switch_done = TRUE;
+            }
+        case PA_SOURCE_MESSAGE_REMOVE_OUTPUT:
+            break;
     }
 
     return pa_source_process_msg(o, code, data, offset, chunk);
@@ -704,8 +980,11 @@ int pa__init(pa_module*m) {
     pa_sample_spec ss;
     pa_channel_map map;
     uint32_t nfrags, frag_size;
+    uint32_t alt_nfrags, alt_frag_size;
     snd_pcm_uframes_t period_size;
+    snd_pcm_uframes_t alt_period_size;
     size_t frame_size;
+    size_t alt_frame_size;
     snd_pcm_info_t *pcm_info = NULL;
     int err;
     char *t;
@@ -714,6 +993,7 @@ int pa__init(pa_module*m) {
     int namereg_fail;
     pa_bool_t use_mmap = TRUE, b, d;
     pa_source_new_data data;
+    const char *dbus_type;
 
     snd_pcm_info_alloca(&pcm_info);
 
@@ -742,6 +1022,21 @@ int pa__init(pa_module*m) {
         goto fail;
     }
     period_size = frag_size/frame_size;
+    
+    alt_frame_size = pa_frame_size(&ss);
+
+    alt_nfrags = m->core->default_n_fragments;
+    alt_frag_size = pa_usec_to_bytes(m->core->default_fragment_size_msec*1000, &ss);
+    if (alt_frag_size <= 0)
+        alt_frag_size = alt_frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "alt_fragments", &alt_nfrags) < 0 || pa_modargs_get_value_u32(ma, "alt_fragment_size", &alt_frag_size) < 0) {
+        pa_log("Failed to parse buffer metrics");
+        goto fail;
+    }
+    alt_period_size = alt_frag_size/alt_frame_size;
+
+    dbus_type = pa_modargs_get_value(ma, "dbus_type", "session");
 
     if (pa_modargs_get_value_boolean(ma, "mmap", &use_mmap) < 0) {
         pa_log("Failed to parse mmap argument.");
@@ -749,6 +1044,8 @@ int pa__init(pa_module*m) {
     }
 
     u = pa_xnew0(struct userdata, 1);
+    u->switch_mode = SWITCH_PRIMARY;
+    u->switch_done = TRUE;
     u->core = m->core;
     u->module = m;
     m->userdata = u;
@@ -885,8 +1182,21 @@ int pa__init(pa_module*m) {
     u->nfragments = nfrags;
     u->hwbuf_size = u->fragment_size * nfrags;
     u->period_size = period_size;
-
-    pa_log_info("Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->fragment_size);
+    
+    u->pri_frame_size = frame_size;
+    u->pri_fragment_size = frag_size = period_size * frame_size;
+    u->pri_nfragments = nfrags;
+    u->pri_hwbuf_size = u->fragment_size * nfrags;
+    u->pri_period_size = period_size;
+    
+    u->alt_frame_size = alt_frame_size;
+    u->alt_fragment_size = alt_frag_size = alt_period_size * alt_frame_size;
+    u->alt_nfragments = alt_nfrags;
+    u->alt_hwbuf_size = u->alt_fragment_size * alt_nfrags;
+    u->alt_period_size = alt_period_size;
+
+    pa_log_info("PRI: Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->pri_fragment_size);
+    pa_log_info("ALT: Using %u fragments of size %lu bytes.", alt_nfrags, (long unsigned) u->alt_fragment_size);
 
     if (u->mixer_handle) {
         pa_assert(u->mixer_elem);
@@ -929,6 +1239,9 @@ int pa__init(pa_module*m) {
 
     pa_source_put(u->source);
 
+    if (alsa_switch_init_event_forwarder(u, dbus_type))
+        goto fail;
+
     pa_modargs_free(ma);
 
     return 0;
@@ -951,6 +1264,8 @@ void pa__done(pa_module*m) {
     if (!(u = m->userdata))
         return;
 
+    alsa_switch_unload_event_forwarder(u);
+
     if (u->source)
         pa_source_unlink(u->source);
 
-- 
1.6.0.2.514.g23abd3

