From 8ccd8a34ca6f0faf4b5d25d3220a16bb6e75a3d8 Mon Sep 17 00:00:00 2001
From: Maemo Multimedia <multimedia@maemo.org>
Date: Mon, 17 Nov 2008 19:50:30 +0200
Subject: [PATCH 07/23] alsa-old: various dynamic switching (Nokia specific)

Buffer switching with property list
Cconfiguration parameter to select mixer
Runtime mixer switching using property lists
---
 src/Makefile.am                           |    5 +-
 src/modules/alsa/module-alsa-sink-old.c   |  350 ++++++++++++++++++++++++-----
 src/modules/alsa/module-alsa-sink-old.h   |   11 +
 src/modules/alsa/module-alsa-source-old.c |  169 ++++++++++++++-
 src/modules/alsa/module-alsa-source-old.h |   11 +
 5 files changed, 487 insertions(+), 59 deletions(-)
 create mode 100644 src/modules/alsa/module-alsa-sink-old.h
 create mode 100644 src/modules/alsa/module-alsa-source-old.h

diff --git a/src/Makefile.am b/src/Makefile.am
index 1424162..070eedd 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -965,10 +965,13 @@ modlibexec_LTLIBRARIES += \
 		libalsa-util.la \
 		module-alsa-sink.la \
 		module-alsa-source.la \
-		module-alsa-card.la \
+		module-alsa-card.la
+if HAVE_DBUS
+modlibexec_LTLIBRARIES += \
 		module-alsa-sink-old.la \
 		module-alsa-source-old.la
 endif
+endif
 
 if HAVE_SOLARIS
 modlibexec_LTLIBRARIES += \
diff --git a/src/modules/alsa/module-alsa-sink-old.c b/src/modules/alsa/module-alsa-sink-old.c
index 781c180..1a0d766 100644
--- a/src/modules/alsa/module-alsa-sink-old.c
+++ b/src/modules/alsa/module-alsa-sink-old.c
@@ -45,9 +45,11 @@
 #include <pulsecore/core-error.h>
 #include <pulsecore/thread-mq.h>
 #include <pulsecore/rtpoll.h>
+#include <pulsecore/atomic.h>
 
 #include "alsa-util.h"
 #include "module-alsa-sink-old-symdef.h"
+#include "module-alsa-sink-old.h"
 
 PA_MODULE_AUTHOR("Lennart Poettering");
 PA_MODULE_DESCRIPTION("ALSA Sink");
@@ -60,13 +62,19 @@ PA_MODULE_USAGE(
         "format=<sample format> "
         "channels=<number of channels> "
         "rate=<sample rate> "
+        "mixer=<initial ALSA mixer> "
         "fragments=<number of fragments> "
         "fragment_size=<fragment size> "
+        "alt_fragments=<number of fragments> "
+        "alt_fragment_size=<fragment size> "
         "channel_map=<channel map> "
         "mmap=<enable memory mapping?>");
 
 #define DEFAULT_DEVICE "default"
 
+#define SINK_SWITCH_PRIMARY (0)
+#define SINK_SWITCH_ALTERNATIVE (1)
+
 struct userdata {
     pa_core *core;
     pa_module *module;
@@ -88,6 +96,20 @@ struct userdata {
     unsigned nfragments;
     pa_memchunk memchunk;
 
+    size_t pri_frame_size, pri_fragment_size, pri_hwbuf_size;
+    snd_pcm_uframes_t pri_period_size;
+    unsigned pri_nfragments;
+
+    size_t alt_frame_size, alt_fragment_size, alt_hwbuf_size;
+    snd_pcm_uframes_t alt_period_size;
+    unsigned alt_nfragments;
+
+    pa_bool_t switching_enabled;
+    int switch_mode;
+
+    pa_hook_slot *sink_proplist_changed_slot;
+    char *mixer_name;
+    pa_channel_map channel_map;
     char *device_name;
 
     pa_bool_t use_mmap;
@@ -106,13 +128,65 @@ static const char* const valid_modargs[] = {
     "format",
     "channels",
     "rate",
+    "mixer",
     "fragments",
     "fragment_size",
+    "alt_fragments",
+    "alt_fragment_size",
     "channel_map",
     "mmap",
     NULL
 };
 
+
+static void switch_buffers(struct userdata *u, int switch_mode) {
+    unsigned num_inputs = 0;
+
+    pa_assert(u->sink);
+
+    if (!u->switching_enabled) {
+        pa_log_info("switch_buffers() switching disabled by config (no alt_ parameters)");
+        return;
+    }
+    if (switch_mode == u->switch_mode) {
+        pa_log_debug("switch_buffers() same mode as previously");
+        return;
+    }
+    u->switch_mode = switch_mode;
+    num_inputs = pa_idxset_size(u->sink->inputs);
+
+    pa_log_debug("switch_buffers() got %d inputs", num_inputs);
+
+    /* Suspend is dependent on the context where switch_buffers is run.
+     * If using from thread_func, internal suspend() should be used. */
+    pa_sink_suspend(u->sink, TRUE);
+
+    if (u->switch_mode == SINK_SWITCH_PRIMARY) {
+        pa_log_info("switch to primary buffer");
+        u->frame_size = u->pri_frame_size;
+        u->fragment_size = u->pri_fragment_size;
+        u->hwbuf_size = u->pri_hwbuf_size;
+        u->nfragments = u->pri_nfragments;
+        u->period_size = u->pri_period_size;
+    } else {
+        pa_log_info("switch to alternate buffer");
+        u->frame_size = u->alt_frame_size;
+        u->fragment_size = u->alt_fragment_size;
+        u->hwbuf_size = u->alt_hwbuf_size;
+        u->nfragments = u->alt_nfragments;
+        u->period_size = u->alt_period_size;
+    }
+    pa_proplist_setf(u->sink->proplist,
+                     PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE,
+                     "%lu", (unsigned long) (u->period_size * u->frame_size * u->nfragments));
+    pa_proplist_setf(u->sink->proplist,
+                     PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE,
+                     "%lu", (unsigned long) (u->period_size * u->frame_size));
+
+    if (num_inputs > 0)
+        pa_sink_suspend(u->sink, FALSE);
+}
+
 static int mmap_write(struct userdata *u) {
     int work_done = 0;
 
@@ -475,6 +549,11 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
             }
 
             break;
+
+        case PA_SINK_MESSAGE_ADD_INPUT:
+            break;
+        case PA_SINK_MESSAGE_REMOVE_INPUT:
+            break;
     }
 
     return pa_sink_process_msg(o, code, data, offset, chunk);
@@ -714,6 +793,148 @@ finish:
     pa_log_debug("Thread shutting down");
 }
 
+static int open_alsa_mixer(struct userdata *u, const char *dev_id) {
+    int err;
+    pa_assert(!u->mixer_handle);
+
+    if ((err = snd_mixer_open(&u->mixer_handle, 0)) < 0) {
+        pa_log("Error opening mixer: %s", snd_strerror(err));
+        return -1;
+    } else {
+        pa_bool_t found = FALSE;
+
+        if (pa_alsa_prepare_mixer(u->mixer_handle, u->device_name) >= 0)
+            found = TRUE;
+        else {
+            char *md = pa_sprintf_malloc("hw:%s", dev_id);
+
+            if (strcmp(u->device_name, md))
+                if (pa_alsa_prepare_mixer(u->mixer_handle, md) >= 0)
+                    found = TRUE;
+
+            pa_xfree(md);
+        }
+
+        if (!found) {
+            snd_mixer_close(u->mixer_handle);
+            u->mixer_handle = NULL;
+            return -1;
+        }
+    }
+    return 0;
+}
+
+static int set_alsa_mixer(struct userdata *u, const char *mixer) {
+    int ret = 0;
+    snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
+    pa_alsa_fdlist *mixer_fdl = NULL;
+    snd_mixer_elem_t *mixer_elem = NULL;
+
+    if (u->mixer_handle) {
+        if (u->mixer_elem) {
+            pa_log_info("close old mixer element");
+            if (u->mixer_fdl) {
+                pa_alsa_fdlist_free(u->mixer_fdl);
+                u->mixer_fdl = NULL;
+            }
+            u->sink->get_volume = NULL;
+            u->sink->set_volume = NULL;
+            u->sink->get_mute = NULL;
+            u->sink->set_mute = NULL;
+        }
+        /* Try using mixer as both primary and fallback mixer, to ensure mixer selection
+         * even when mixer hasn't got both volume and mute switches */
+        if (!(mixer_elem = pa_alsa_find_elem(u->mixer_handle, mixer, mixer, TRUE))) {
+            ret = -1;
+            /* Try to select previously used mixer again */
+            if (u->mixer_name)
+                if (!(mixer_elem = pa_alsa_find_elem(u->mixer_handle, u->mixer_name, u->mixer_name, TRUE))) {
+                    pa_log_warn("Could not select mixer at all");
+                    goto done;
+                }
+        }
+    } else {
+        pa_log("No mixer handle.");
+        goto done;
+    }
+
+    if (u->mixer_handle && mixer_elem) {
+        pa_assert(mixer_elem);
+
+        if (snd_mixer_selem_has_playback_volume(mixer_elem))
+            if (pa_alsa_calc_mixer_map(mixer_elem, &u->channel_map, mixer_map, TRUE) >= 0) {
+                u->sink->get_volume = sink_get_volume_cb;
+                u->sink->set_volume = sink_set_volume_cb;
+                snd_mixer_selem_get_playback_volume_range(mixer_elem, &u->hw_volume_min, &u->hw_volume_max);
+                u->sink->flags |= PA_SINK_HW_VOLUME_CTRL;
+            }
+
+        if (snd_mixer_selem_has_playback_switch(mixer_elem)) {
+            u->sink->get_mute = sink_get_mute_cb;
+            u->sink->set_mute = sink_set_mute_cb;
+            u->sink->flags |= PA_SINK_HW_VOLUME_CTRL;
+        }
+
+        mixer_fdl = pa_alsa_fdlist_new();
+
+        if (pa_alsa_fdlist_set_mixer(mixer_fdl, u->mixer_handle, u->module->core->mainloop) < 0) {
+            pa_log("Failed to initialize file descriptor monitoring");
+            //return -1; // goto fail;
+            goto done;
+        }
+
+        snd_mixer_elem_set_callback(mixer_elem, mixer_callback);
+        snd_mixer_elem_set_callback_private(mixer_elem, u);
+
+        u->mixer_elem = mixer_elem;
+        u->mixer_fdl = mixer_fdl;
+        memcpy(&u->mixer_map, &mixer_map, sizeof(snd_mixer_selem_channel_id_t)*SND_MIXER_SCHN_LAST);
+
+        /* Remember selected mixer name */
+        if (u->mixer_name && ret > -1) {
+            pa_xfree(u->mixer_name);
+            u->mixer_name = NULL;
+        }
+        if (!u->mixer_name)
+            u->mixer_name = pa_xstrdup(mixer);
+    } else {
+        u->mixer_fdl = NULL;
+    }
+
+done:
+    return ret;
+}
+
+static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
+    const char *v = NULL;
+
+    pa_assert(u);
+    pa_assert(s);
+
+    v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_BUFFERS);
+    if (v) {
+        if (pa_startswith(v, PA_ALSA_SINK_PROP_BUFFERS_PRIMARY)) {
+            switch_buffers(u, SINK_SWITCH_PRIMARY);
+        }
+        else if (pa_startswith(v, PA_ALSA_SINK_PROP_BUFFERS_ALTERNATIVE)) {
+            switch_buffers(u, SINK_SWITCH_ALTERNATIVE);
+        }
+    }
+
+    v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_MIXER);
+    if (v) {
+        if (strcmp(v, u->mixer_name) != 0) {
+            pa_log_info("select mixer: %s", v);
+            if (set_alsa_mixer(u, v) < 0) {
+                pa_log_debug("reset old mixer name");
+                pa_proplist_sets(s->proplist, PA_ALSA_SINK_PROP_MIXER, u->mixer_name);
+            }
+        }
+    }
+
+    return PA_HOOK_OK;
+}
+
 int pa__init(pa_module*m) {
 
     pa_modargs *ma = NULL;
@@ -721,9 +942,14 @@ int pa__init(pa_module*m) {
     const char *dev_id;
     pa_sample_spec ss;
     pa_channel_map map;
+    char *alsa_mixer = NULL;
+    unsigned ii;
     uint32_t nfrags, frag_size;
+    uint32_t alt_nfrags, alt_frag_size;
     snd_pcm_uframes_t period_size;
+    snd_pcm_uframes_t alt_period_size;
     size_t frame_size;
+    size_t alt_frame_size;
     snd_pcm_info_t *pcm_info = NULL;
     int err;
     char *t;
@@ -749,6 +975,13 @@ int pa__init(pa_module*m) {
         goto fail;
     }
 
+    alsa_mixer = pa_xstrdup(pa_modargs_get_value(ma, "mixer", "Master"));
+    ii = 0;
+    while(alsa_mixer[ii++] != '\0') { // is there a pa function for this?
+        if (alsa_mixer[ii] == '_')
+            alsa_mixer[ii] = ' ';
+    }
+
     frame_size = pa_frame_size(&ss);
 
     nfrags = m->core->default_n_fragments;
@@ -762,12 +995,33 @@ int pa__init(pa_module*m) {
     }
     period_size = frag_size/frame_size;
 
+    alt_frame_size = pa_frame_size(&ss);
+
+    /* 0 is default value from pa_modargs_get */
+    alt_period_size = 0;
+    alt_nfrags = 0;
+    alt_frag_size = alt_frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "alt_fragments", &alt_nfrags) < 0 || pa_modargs_get_value_u32(ma, "alt_fragment_size", &alt_frag_size) < 0) {
+        pa_log("Failed to parse alt buffer metrics");
+        goto fail;
+    }
+
+    if (alt_nfrags != 0) {
+        alt_period_size = alt_frag_size/alt_frame_size;
+    }
+
     if (pa_modargs_get_value_boolean(ma, "mmap", &use_mmap) < 0) {
         pa_log("Failed to parse mmap argument.");
         goto fail;
     }
 
     u = pa_xnew0(struct userdata, 1);
+    u->switch_mode = SINK_SWITCH_PRIMARY;
+    if (alt_nfrags != 0)
+        u->switching_enabled = TRUE;
+    else
+        u->switching_enabled = FALSE;
     u->core = m->core;
     u->module = m;
     m->userdata = u;
@@ -831,33 +1085,9 @@ int pa__init(pa_module*m) {
 
     /* ALSA might tweak the sample spec, so recalculate the frame size */
     frame_size = pa_frame_size(&ss);
+    alt_frame_size = pa_frame_size(&ss);
 
-    if ((err = snd_mixer_open(&u->mixer_handle, 0)) < 0)
-        pa_log_warn("Error opening mixer: %s", snd_strerror(err));
-    else {
-        pa_bool_t found = FALSE;
-
-        if (pa_alsa_prepare_mixer(u->mixer_handle, u->device_name) >= 0)
-            found = TRUE;
-        else {
-            char *md = pa_sprintf_malloc("hw:%s", dev_id);
-
-            if (strcmp(u->device_name, md))
-                if (pa_alsa_prepare_mixer(u->mixer_handle, md) >= 0)
-                    found = TRUE;
-
-            pa_xfree(md);
-        }
-
-        if (found)
-            if (!(u->mixer_elem = pa_alsa_find_elem(u->mixer_handle, "Master", "PCM", TRUE)))
-                found = FALSE;
-
-        if (!found) {
-            snd_mixer_close(u->mixer_handle);
-            u->mixer_handle = NULL;
-        }
-    }
+    open_alsa_mixer(u, dev_id);
 
     if ((name = pa_modargs_get_value(ma, "sink_name", NULL)))
         namereg_fail = 1;
@@ -910,38 +1140,29 @@ int pa__init(pa_module*m) {
     u->hwbuf_size = u->fragment_size * nfrags;
     u->period_size = period_size;
 
-    pa_log_info("Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->fragment_size);
-
-    pa_memchunk_reset(&u->memchunk);
-
-    if (u->mixer_handle) {
-        pa_assert(u->mixer_elem);
-
-        if (snd_mixer_selem_has_playback_volume(u->mixer_elem))
-            if (pa_alsa_calc_mixer_map(u->mixer_elem, &map, u->mixer_map, TRUE) >= 0) {
-                u->sink->get_volume = sink_get_volume_cb;
-                u->sink->set_volume = sink_set_volume_cb;
-                snd_mixer_selem_get_playback_volume_range(u->mixer_elem, &u->hw_volume_min, &u->hw_volume_max);
-                u->sink->flags |= PA_SINK_HW_VOLUME_CTRL;
-            }
-
-        if (snd_mixer_selem_has_playback_switch(u->mixer_elem)) {
-            u->sink->get_mute = sink_get_mute_cb;
-            u->sink->set_mute = sink_set_mute_cb;
-            u->sink->flags |= PA_SINK_HW_VOLUME_CTRL;
-        }
+    if (u->switching_enabled) {
+        u->pri_frame_size = frame_size;
+        u->pri_fragment_size = frag_size = period_size * frame_size;
+        u->pri_nfragments = nfrags;
+        u->pri_hwbuf_size = u->fragment_size * nfrags;
+        u->pri_period_size = period_size;
+
+        u->alt_frame_size = alt_frame_size;
+        u->alt_fragment_size = alt_frag_size = alt_period_size * alt_frame_size;
+        u->alt_nfragments = alt_nfrags;
+        u->alt_hwbuf_size = u->alt_fragment_size * alt_nfrags;
+        u->alt_period_size = alt_period_size;
+    }
 
-        u->mixer_fdl = pa_alsa_fdlist_new();
+    pa_log_info("PRI: Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->fragment_size);
+    if (u->switching_enabled)
+        pa_log_info("ALT: Using %u fragments of size %lu bytes.", alt_nfrags, (long unsigned) u->alt_fragment_size);
 
-        if (pa_alsa_fdlist_set_mixer(u->mixer_fdl, u->mixer_handle, m->core->mainloop) < 0) {
-            pa_log("Failed to initialize file descriptor monitoring");
-            goto fail;
-        }
+    pa_memchunk_reset(&u->memchunk);
 
-        snd_mixer_elem_set_callback(u->mixer_elem, mixer_callback);
-        snd_mixer_elem_set_callback_private(u->mixer_elem, u);
-    } else
-        u->mixer_fdl = NULL;
+    u->channel_map = map;
+    if (set_alsa_mixer(u, alsa_mixer) < 0)
+        goto fail;
 
     if (!(u->thread = pa_thread_new(thread_func, u))) {
         pa_log("Failed to create thread.");
@@ -954,14 +1175,31 @@ int pa__init(pa_module*m) {
     if (u->sink->get_mute)
         u->sink->get_mute(u->sink);
 
+    if (!u->mixer_name)
+        u->mixer_name = pa_sprintf_malloc("(none)");
+
+    pa_proplist_sets(u->sink->proplist, PA_ALSA_SINK_PROP_BUFFERS, PA_ALSA_SINK_PROP_BUFFERS_PRIMARY);
+    pa_proplist_sets(u->sink->proplist, PA_ALSA_SINK_PROP_MIXER, u->mixer_name);
+
+    /* hook for buffer & mixer switching */
+    u->sink_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_PROPLIST_CHANGED],
+                                                    PA_HOOK_LATE,
+                                                    (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
+
     pa_sink_put(u->sink);
 
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
     pa_modargs_free(ma);
 
     return 0;
 
 fail:
 
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
     if (ma)
         pa_modargs_free(ma);
 
@@ -1011,6 +1249,8 @@ void pa__done(pa_module*m) {
         snd_pcm_close(u->pcm_handle);
     }
 
+    if (u->mixer_name)
+        pa_xfree(u->mixer_name);
     pa_xfree(u->device_name);
     pa_xfree(u);
 
diff --git a/src/modules/alsa/module-alsa-sink-old.h b/src/modules/alsa/module-alsa-sink-old.h
new file mode 100644
index 0000000..69309cd
--- /dev/null
+++ b/src/modules/alsa/module-alsa-sink-old.h
@@ -0,0 +1,11 @@
+#ifndef foomodulealsasinkfoo
+#define foomodulealsasinkfoo
+
+#define PA_ALSA_SINK_PROP_MIXER   "x-maemo.alsa_sink.mixer"    /* Name of mixer control, PCM/Master/etc */
+#define PA_ALSA_SINK_PROP_BUFFERS "x-maemo.alsa_sink.buffers"  /* Buffer mode, primary/alternative */
+
+#define PA_ALSA_SINK_PROP_BUFFERS_PRIMARY     "primary"
+#define PA_ALSA_SINK_PROP_BUFFERS_ALTERNATIVE "alternative"
+
+#endif
+
diff --git a/src/modules/alsa/module-alsa-source-old.c b/src/modules/alsa/module-alsa-source-old.c
index c18a27f..df873d3 100644
--- a/src/modules/alsa/module-alsa-source-old.c
+++ b/src/modules/alsa/module-alsa-source-old.c
@@ -36,7 +36,7 @@
 #include <pulsecore/core.h>
 #include <pulsecore/module.h>
 #include <pulsecore/memchunk.h>
-#include <pulsecore/sink.h>
+#include <pulsecore/source.h>
 #include <pulsecore/modargs.h>
 #include <pulsecore/core-util.h>
 #include <pulsecore/sample-util.h>
@@ -49,6 +49,7 @@
 
 #include "alsa-util.h"
 #include "module-alsa-source-old-symdef.h"
+#include "module-alsa-source-old.h"
 
 PA_MODULE_AUTHOR("Lennart Poettering");
 PA_MODULE_DESCRIPTION("ALSA Source");
@@ -61,13 +62,19 @@ PA_MODULE_USAGE(
         "format=<sample format> "
         "channels=<number of channels> "
         "rate=<sample rate> "
+        "mixer=<initial ALSA mixer> "
         "fragments=<number of fragments> "
         "fragment_size=<fragment size> "
+        "alt_fragments=<number of fragments> "
+        "alt_fragment_size=<fragment size> "
         "channel_map=<channel map> "
         "mmap=<enable memory mapping?>");
 
 #define DEFAULT_DEVICE "default"
 
+#define SOURCE_SWITCH_PRIMARY (0)
+#define SOURCE_SWITCH_ALTERNATIVE (1)
+
 struct userdata {
     pa_core *core;
     pa_module *module;
@@ -88,6 +95,19 @@ struct userdata {
     snd_pcm_uframes_t period_size;
     unsigned nfragments;
 
+    size_t pri_frame_size, pri_fragment_size, pri_hwbuf_size;
+    snd_pcm_uframes_t pri_period_size;
+    unsigned pri_nfragments;
+
+    size_t alt_frame_size, alt_fragment_size, alt_hwbuf_size;
+    snd_pcm_uframes_t alt_period_size;
+    unsigned alt_nfragments;
+
+    pa_bool_t switching_enabled;
+    int switch_mode;
+
+    pa_hook_slot *source_proplist_changed_slot;
+    char *mixer_name;
     char *device_name;
 
     pa_bool_t use_mmap;
@@ -103,14 +123,68 @@ static const char* const valid_modargs[] = {
     "source_name",
     "channels",
     "rate",
+    "mixer",
     "format",
     "fragments",
     "fragment_size",
+    "alt_fragments",
+    "alt_fragment_size",
     "channel_map",
     "mmap",
     NULL
 };
 
+
+static void switch_buffers(struct userdata *u, int switch_mode) {
+    unsigned num_outputs = 0;
+
+    pa_assert(u->source);
+
+    if (!u->switching_enabled) {
+        pa_log_info("switch_buffers() switching disabled by config (no alt_ parameters)");
+        return;
+    }
+    if (switch_mode == u->switch_mode) {
+        pa_log_debug("switch_buffers() same mode as previously");
+        return;
+    }
+    u->switch_mode = switch_mode;
+    num_outputs = pa_idxset_size(u->source->outputs);
+
+    pa_log_debug("switch_buffers() got %d outputs", num_outputs);
+
+    /* Suspend is dependent on the context where switch_buffers is run.
+     * If using from thread_func, internal suspend() should be used. */
+    pa_source_suspend(u->source, TRUE);
+
+    if (u->switch_mode == SOURCE_SWITCH_PRIMARY) {
+        pa_log_info("switch to primary buffer");
+        u->frame_size = u->pri_frame_size;
+        u->fragment_size = u->pri_fragment_size;
+        u->hwbuf_size = u->pri_hwbuf_size;
+        u->nfragments = u->pri_nfragments;
+        u->period_size = u->pri_period_size;
+    } else {
+        pa_log_info("switch to alternate buffer");
+        u->frame_size = u->alt_frame_size;
+        u->fragment_size = u->alt_fragment_size;
+        u->hwbuf_size = u->alt_hwbuf_size;
+        u->nfragments = u->alt_nfragments;
+        u->period_size = u->alt_period_size;
+    }
+
+    pa_proplist_setf(u->source->proplist,
+                     PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE,
+                     "%lu", (unsigned long) (u->period_size * u->frame_size * u->nfragments));
+    pa_proplist_setf(u->source->proplist,
+                     PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE,
+                     "%lu", (unsigned long) (u->period_size * u->frame_size));
+
+    if (num_outputs > 0) {
+        pa_source_suspend(u->source, FALSE);
+    }
+}
+
 static int mmap_read(struct userdata *u) {
     int work_done = 0;
 
@@ -466,6 +540,11 @@ static int source_process_msg(pa_msgobject *o, int code, void *data, int64_t off
             }
 
             break;
+
+        case PA_SOURCE_MESSAGE_ADD_OUTPUT:
+            break;
+        case PA_SOURCE_MESSAGE_REMOVE_OUTPUT:
+            break;
     }
 
     return pa_source_process_msg(o, code, data, offset, chunk);
@@ -695,6 +774,25 @@ finish:
     pa_log_debug("Thread shutting down");
 }
 
+static pa_hook_result_t source_proplist_changed_hook_callback(pa_core *c, pa_source *s, struct userdata *u) {
+    const char *v = NULL;
+
+    pa_assert(u);
+    pa_assert(s);
+
+    v = pa_proplist_gets(s->proplist, PA_ALSA_SOURCE_PROP_BUFFERS);
+    if (v) {
+        if (pa_startswith(v, PA_ALSA_SOURCE_PROP_BUFFERS_PRIMARY)) {
+            switch_buffers(u, SOURCE_SWITCH_PRIMARY);
+        }
+        else if (pa_startswith(v, PA_ALSA_SOURCE_PROP_BUFFERS_ALTERNATIVE)) {
+            switch_buffers(u, SOURCE_SWITCH_ALTERNATIVE);
+        }
+    }
+
+    return PA_HOOK_OK;
+}
+
 int pa__init(pa_module*m) {
 
     pa_modargs *ma = NULL;
@@ -702,9 +800,14 @@ int pa__init(pa_module*m) {
     const char *dev_id;
     pa_sample_spec ss;
     pa_channel_map map;
+    char *alsa_mixer = NULL;
+    unsigned ii;
     uint32_t nfrags, frag_size;
+    uint32_t alt_nfrags, alt_frag_size;
     snd_pcm_uframes_t period_size;
+    snd_pcm_uframes_t alt_period_size;
     size_t frame_size;
+    size_t alt_frame_size;
     snd_pcm_info_t *pcm_info = NULL;
     int err;
     char *t;
@@ -730,6 +833,13 @@ int pa__init(pa_module*m) {
         goto fail;
     }
 
+    alsa_mixer = pa_xstrdup(pa_modargs_get_value(ma, "mixer", "Capture"));
+    ii = 0;
+    while(alsa_mixer[ii++] != '\0') {
+        if (alsa_mixer[ii] == '_')
+            alsa_mixer[ii] = ' ';
+    }
+
     frame_size = pa_frame_size(&ss);
 
     nfrags = m->core->default_n_fragments;
@@ -743,12 +853,35 @@ int pa__init(pa_module*m) {
     }
     period_size = frag_size/frame_size;
 
+    alt_frame_size = pa_frame_size(&ss);
+
+    /* 0 is default value from pa_modargs_get */
+    alt_period_size = 0;
+    alt_nfrags = 0;
+    alt_frag_size = alt_frame_size;
+
+    if (alt_frag_size <= 0)
+        alt_frag_size = alt_frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "alt_fragments", &alt_nfrags) < 0 || pa_modargs_get_value_u32(ma, "alt_fragment_size", &alt_frag_size) < 0) {
+        pa_log("Failed to parse buffer metrics");
+        goto fail;
+    }
+
+    if (alt_nfrags != 0)
+        alt_period_size = alt_frag_size/alt_frame_size;
+
     if (pa_modargs_get_value_boolean(ma, "mmap", &use_mmap) < 0) {
         pa_log("Failed to parse mmap argument.");
         goto fail;
     }
 
     u = pa_xnew0(struct userdata, 1);
+    u->switch_mode = SOURCE_SWITCH_PRIMARY;
+    if (alt_nfrags != 0)
+        u->switching_enabled = TRUE;
+    else
+        u->switching_enabled = FALSE;
     u->core = m->core;
     u->module = m;
     m->userdata = u;
@@ -828,7 +961,7 @@ int pa__init(pa_module*m) {
         }
 
         if (found)
-            if (!(u->mixer_elem = pa_alsa_find_elem(u->mixer_handle, "Capture", "Mic", FALSE)))
+            if (!(u->mixer_elem = pa_alsa_find_elem(u->mixer_handle, alsa_mixer, "Mic", FALSE)))
                 found = FALSE;
 
         if (!found) {
@@ -887,7 +1020,23 @@ int pa__init(pa_module*m) {
     u->hwbuf_size = u->fragment_size * nfrags;
     u->period_size = period_size;
 
-    pa_log_info("Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->fragment_size);
+    if (u->switching_enabled) {
+        u->pri_frame_size = frame_size;
+        u->pri_fragment_size = frag_size = period_size * frame_size;
+        u->pri_nfragments = nfrags;
+        u->pri_hwbuf_size = u->fragment_size * nfrags;
+        u->pri_period_size = period_size;
+
+        u->alt_frame_size = alt_frame_size;
+        u->alt_fragment_size = alt_frag_size = alt_period_size * alt_frame_size;
+        u->alt_nfragments = alt_nfrags;
+        u->alt_hwbuf_size = u->alt_fragment_size * alt_nfrags;
+        u->alt_period_size = alt_period_size;
+    }
+
+    pa_log_info("PRI: Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->pri_fragment_size);
+    if (u->switching_enabled)
+        pa_log_info("ALT: Using %u fragments of size %lu bytes.", alt_nfrags, (long unsigned) u->alt_fragment_size);
 
     if (u->mixer_handle) {
         pa_assert(u->mixer_elem);
@@ -928,14 +1077,28 @@ int pa__init(pa_module*m) {
     if (u->source->get_mute)
         u->source->get_mute(u->source);
 
+    pa_proplist_sets(u->source->proplist, PA_ALSA_SOURCE_PROP_BUFFERS, PA_ALSA_SOURCE_PROP_BUFFERS_PRIMARY);
+
+    /* hook for buffer switching */
+    if (u->switching_enabled)
+        u->source_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SOURCE_PROPLIST_CHANGED],
+                                                          PA_HOOK_LATE,
+                                                          (pa_hook_cb_t)source_proplist_changed_hook_callback, u);
+
     pa_source_put(u->source);
 
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
     pa_modargs_free(ma);
 
     return 0;
 
 fail:
 
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
     if (ma)
         pa_modargs_free(ma);
 
diff --git a/src/modules/alsa/module-alsa-source-old.h b/src/modules/alsa/module-alsa-source-old.h
new file mode 100644
index 0000000..ef5481e
--- /dev/null
+++ b/src/modules/alsa/module-alsa-source-old.h
@@ -0,0 +1,11 @@
+#ifndef foomodulealsasourcefoo
+#define foomodulealsasourcefoo
+
+#define PA_ALSA_SOURCE_PROP_MIXER   "x-maemo.alsa_source.mixer"    /* Name of mixer control, PCM/Master/etc */
+#define PA_ALSA_SOURCE_PROP_BUFFERS "x-maemo.alsa_source.buffers"  /* Buffer mode, primary/alternative */
+
+#define PA_ALSA_SOURCE_PROP_BUFFERS_PRIMARY     "primary"
+#define PA_ALSA_SOURCE_PROP_BUFFERS_ALTERNATIVE "alternative"
+
+#endif
+
-- 
1.6.1.224.gb56c

