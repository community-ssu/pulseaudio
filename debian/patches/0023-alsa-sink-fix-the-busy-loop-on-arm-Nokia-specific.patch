From 780a22c82c54588bba78d0b1b48bb7783bdad06f Mon Sep 17 00:00:00 2001
From: Jyri Sarha <jyri.sarha@nokia.com>
Date: Mon, 25 Aug 2008 18:51:01 +0300
Subject: [PATCH] alsa-sink: fix the busy loop on arm (Nokia specific)

---
 src/modules/module-alsa-sink.c |   23 ++++++++++++++++++++---
 1 files changed, 20 insertions(+), 3 deletions(-)

diff --git a/src/modules/module-alsa-sink.c b/src/modules/module-alsa-sink.c
index 4044de1..4c2c111 100644
--- a/src/modules/module-alsa-sink.c
+++ b/src/modules/module-alsa-sink.c
@@ -72,7 +72,9 @@ PA_MODULE_USAGE(
         "mmap=<enable memory mapping?> "
         "tsched=<enable system timer based scheduling mode?> "
         "tsched_buffer_size=<buffer size when using timer based scheduling> "
-        "tsched_buffer_watermark=<lower fill watermark>");
+        "tsched_buffer_watermark=<lower fill watermark> "
+        "mixer_reset=<reset hw volume and mute settings to sane defaults when falling back to software?>"
+	"hwbuf_min_frames_to_write=<minimum number of available frames in hwbuf to fill>");
 
 static const char* const valid_modargs[] = {
     "sink_name",
@@ -88,6 +90,8 @@ static const char* const valid_modargs[] = {
     "tsched",
     "tsched_buffer_size",
     "tsched_buffer_watermark",
+    "mixer_reset",
+    "hwbuf_min_frames_to_write",
     NULL
 };
 
@@ -136,6 +140,7 @@ struct userdata {
     uint64_t since_start;
 
     snd_pcm_sframes_t hwbuf_unused_frames;
+    snd_pcm_sframes_t hwbuf_min_frames_to_write;
 };
 
 static void fix_tsched_watermark(struct userdata *u) {
@@ -282,7 +287,7 @@ static int mmap_write(struct userdata *u, pa_usec_t *sleep_usec) {
             if (pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= u->hwbuf_unused_frames))
+        if (PA_UNLIKELY(n <= u->hwbuf_min_frames_to_write || n <= u->hwbuf_unused_frames))
             break;
 
         n -= u->hwbuf_unused_frames;
@@ -395,7 +400,7 @@ static int unix_write(struct userdata *u, pa_usec_t *sleep_usec) {
             if (pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= u->hwbuf_unused_frames))
+        if (PA_UNLIKELY(n <= u->hwbuf_min_frames_to_write || n <= u->hwbuf_unused_frames))
             break;
 
         n -= u->hwbuf_unused_frames;
@@ -1232,6 +1237,7 @@ int pa__init(pa_module*m) {
     pa_bool_t use_mmap = TRUE, b, use_tsched = TRUE, d;
     pa_usec_t usec;
     pa_sink_new_data data;
+    int32_t hwbuf_min_frames_to_write = 0;
 
     snd_pcm_info_alloca(&pcm_info);
 
@@ -1286,6 +1292,16 @@ int pa__init(pa_module*m) {
         use_tsched = FALSE;
     }
 
+    if (pa_modargs_get_value_boolean(ma, "mixer_reset", &mixer_reset) < 0) {
+        pa_log("Failed to parse mixer_reset argument.");
+        goto fail;
+    }
+
+    if (pa_modargs_get_value_s32(ma, "hwbuf_min_frames_to_write", &hwbuf_min_frames_to_write) < 0) {
+        pa_log("Failed to parse hwbuf_min_frames_to_write argument");
+	goto fail;
+    }
+
     u = pa_xnew0(struct userdata, 1);
     u->core = m->core;
     u->module = m;
@@ -1440,6 +1456,7 @@ int pa__init(pa_module*m) {
     u->fragment_size = frag_size = (uint32_t) (period_frames * frame_size);
     u->nfragments = nfrags;
     u->hwbuf_size = u->fragment_size * nfrags;
+    u->hwbuf_min_frames_to_write = hwbuf_min_frames_to_write;
     u->hwbuf_unused_frames = 0;
     u->tsched_watermark = tsched_watermark;
     u->frame_index = 0;
-- 
1.6.0.2.514.g23abd3

