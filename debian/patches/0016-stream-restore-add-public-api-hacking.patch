From fb2687031f180915c984ee05db828dcb53859b03 Mon Sep 17 00:00:00 2001
From: =?utf-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@gmail.com>
Date: Thu, 20 Nov 2008 18:39:52 +0200
Subject: [PATCH] stream-restore: add public api (hacking)

---
 src/modules/module-stream-restore.c |  134 ++++++++++++++++++++++++++---------
 src/modules/module-stream-restore.h |   25 +++++++
 2 files changed, 124 insertions(+), 35 deletions(-)
 create mode 100644 src/modules/module-stream-restore.h

diff --git a/src/modules/module-stream-restore.c b/src/modules/module-stream-restore.c
index 6c4e43c..8d10c22 100644
--- a/src/modules/module-stream-restore.c
+++ b/src/modules/module-stream-restore.c
@@ -31,6 +31,7 @@
 #include <stdlib.h>
 #include <ctype.h>
 #include <gdbm.h>
+#include <regex.h>
 
 #include <pulse/xmalloc.h>
 #include <pulse/volume.h>
@@ -51,6 +52,7 @@
 #include <pulsecore/pstream-util.h>
 
 #include "module-stream-restore-symdef.h"
+#include "module-stream-restore.h"
 
 PA_MODULE_AUTHOR("Lennart Poettering");
 PA_MODULE_DESCRIPTION("Automatically restore the volume/mute/device state of streams");
@@ -86,13 +88,7 @@ struct userdata {
     pa_idxset *subscribed;
 };
 
-struct entry {
-    char device[PA_NAME_MAX];
-    pa_channel_map channel_map;
-    pa_cvolume volume;
-    pa_bool_t muted:1;
-};
-
+typedef struct module_stream_restore_entry entry_t;
 
 enum {
     SUBCOMMAND_TEST,
@@ -103,6 +99,16 @@ enum {
     SUBCOMMAND_EVENT
 };
 
+void module_stream_restore_sync(pa_module *m) {
+    struct userdata *u;
+
+    pa_assert(m);
+    u = m->userdata;
+
+    gdbm_sync(u->gdbm_file);
+    pa_log_info("Synced.");
+}
+
 static void save_time_callback(pa_mainloop_api*a, pa_time_event* e, const struct timeval *tv, void *userdata) {
     struct userdata *u = userdata;
 
@@ -115,8 +121,7 @@ static void save_time_callback(pa_mainloop_api*a, pa_time_event* e, const struct
     u->core->mainloop->time_free(u->save_time_event);
     u->save_time_event = NULL;
 
-    gdbm_sync(u->gdbm_file);
-    pa_log_info("Synced.");
+    module_stream_restore_sync(u->module);
 }
 
 static char *get_name(pa_proplist *p, const char *prefix) {
@@ -137,14 +142,14 @@ static char *get_name(pa_proplist *p, const char *prefix) {
     return pa_sprintf_malloc("%s-fallback", prefix);
 }
 
-static struct entry* read_entry(struct userdata *u, char *name) {
+static entry_t* read_entry(struct userdata *u, const char *name) {
     datum key, data;
-    struct entry *e;
+    entry_t *e;
 
     pa_assert(u);
     pa_assert(name);
 
-    key.dptr = name;
+    key.dptr = (void*) name;
     key.dsize = (int) strlen(name);
 
     data = gdbm_fetch(u->gdbm_file, key);
@@ -152,12 +157,12 @@ static struct entry* read_entry(struct userdata *u, char *name) {
     if (!data.dptr)
         goto fail;
 
-    if (data.dsize != sizeof(struct entry)) {
-        pa_log_warn("Database contains entry for stream %s of wrong size %lu != %lu", name, (unsigned long) data.dsize, (unsigned long) sizeof(struct entry));
+    if (data.dsize != sizeof(entry_t)) {
+        pa_log_warn("Database contains entry for stream %s of wrong size %lu != %lu", name, (unsigned long) data.dsize, (unsigned long) sizeof(entry_t));
         goto fail;
     }
 
-    e = (struct entry*) data.dptr;
+    e = (entry_t*) data.dptr;
 
     if (!memchr(e->device, 0, sizeof(e->device))) {
         pa_log_warn("Database contains entry for stream %s with missing NUL byte in device name", name);
@@ -217,7 +222,7 @@ static void trigger_save(struct userdata *u) {
 
 static void subscribe_callback(pa_core *c, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
     struct userdata *u = userdata;
-    struct entry entry, *old;
+    entry_t entry, *old;
     char *name;
     datum key, data;
 
@@ -295,7 +300,7 @@ static void subscribe_callback(pa_core *c, pa_subscription_event_type_t t, uint3
 
 static pa_hook_result_t sink_input_new_hook_callback(pa_core *c, pa_sink_input_new_data *new_data, struct userdata *u) {
     char *name;
-    struct entry *e;
+    entry_t *e;
 
     pa_assert(new_data);
 
@@ -325,7 +330,7 @@ static pa_hook_result_t sink_input_new_hook_callback(pa_core *c, pa_sink_input_n
 
 static pa_hook_result_t sink_input_fixate_hook_callback(pa_core *c, pa_sink_input_new_data *new_data, struct userdata *u) {
     char *name;
-    struct entry *e;
+    entry_t *e;
 
     pa_assert(new_data);
 
@@ -361,7 +366,7 @@ static pa_hook_result_t sink_input_fixate_hook_callback(pa_core *c, pa_sink_inpu
 
 static pa_hook_result_t source_output_new_hook_callback(pa_core *c, pa_source_output_new_data *new_data, struct userdata *u) {
     char *name;
-    struct entry *e;
+    entry_t *e;
 
     pa_assert(new_data);
 
@@ -411,7 +416,7 @@ static void clear_db(struct userdata *u) {
     gdbm_reorganize(u->gdbm_file);
 }
 
-static void apply_entry(struct userdata *u, const char *name, struct entry *e) {
+static void apply_entry(struct userdata *u, const char *name, entry_t *e) {
     pa_sink_input *si;
     pa_source_output *so;
     uint32_t idx;
@@ -479,7 +484,7 @@ static void dump_database(struct userdata *u) {
     key = gdbm_firstkey(u->gdbm_file);
     while (key.dptr) {
         datum next_key;
-        struct entry *e;
+        entry_t *e;
         char *name;
 
         next_key = gdbm_nextkey(u->gdbm_file, key);
@@ -541,7 +546,7 @@ static int extension_cb(pa_native_protocol *p, pa_module *m, pa_native_connectio
             key = gdbm_firstkey(u->gdbm_file);
             while (key.dptr) {
                 datum next_key;
-                struct entry *e;
+                entry_t *e;
                 char *name;
 
                 next_key = gdbm_nextkey(u->gdbm_file, key);
@@ -586,9 +591,7 @@ static int extension_cb(pa_native_protocol *p, pa_module *m, pa_native_connectio
             while (!pa_tagstruct_eof(t)) {
                 const char *name, *device;
                 pa_bool_t muted;
-                struct entry entry;
-                datum key, data;
-                int k;
+                entry_t entry;
 
                 memset(&entry, 0, sizeof(entry));
 
@@ -605,18 +608,10 @@ static int extension_cb(pa_native_protocol *p, pa_module *m, pa_native_connectio
                 entry.muted = muted;
                 pa_strlcpy(entry.device, device, sizeof(entry.device));
 
-                key.dptr = (void*) name;
-                key.dsize = (int) strlen(name);
-
-                data.dptr = (void*) &entry;
-                data.dsize = sizeof(entry);
-
-                if ((k = gdbm_store(u->gdbm_file, key, data, mode == PA_UPDATE_REPLACE ? GDBM_REPLACE : GDBM_INSERT)) == 0)
-                    if (apply_immediately)
-                        apply_entry(u, name, &entry);
+                module_stream_restore_update_entry(m, mode, name, &entry, apply_immediately);
             }
 
-            trigger_save(u);
+            /* trigger_save() called by module_stream_restore_update_entry */
 
             break;
         }
@@ -680,6 +675,75 @@ static pa_hook_result_t connection_unlink_hook_cb(pa_native_protocol *p, pa_nati
     return PA_HOOK_OK;
 }
 
+pa_strlist* module_stream_restore_list_entries(pa_module *m, const char *expr) {
+    struct userdata *u;
+    datum key;
+    regex_t re;
+    pa_strlist *l = NULL;
+
+    pa_assert(m);
+    u = m->userdata;
+
+    if (expr && regcomp(&re, expr, REG_NOSUB|REG_EXTENDED) != 0)
+        expr = NULL;
+
+    key = gdbm_firstkey(u->gdbm_file);
+    while (key.dptr) {
+        datum next_key;
+        char *name;
+
+        name = pa_xstrndup(key.dptr, (size_t) key.dsize); /* 2 allocs? */
+
+        if (!expr || regexec(&re, name, 0, NULL, 0) == 0)
+            l = pa_strlist_prepend(l, name);
+
+        next_key = gdbm_nextkey(u->gdbm_file, key);
+
+        pa_xfree(key.dptr);
+        pa_xfree(name);
+
+        key = next_key;
+    }
+
+    if (expr)
+        regfree(&re);
+
+    return l;
+}
+
+struct module_stream_restore_entry* module_stream_restore_read_entry(pa_module *m, const char *name) {
+    pa_assert(m);
+    pa_assert(name);
+
+    return read_entry(m->userdata, name);
+}
+
+int module_stream_restore_update_entry(pa_module *m, pa_update_mode_t mode, const char *name, struct module_stream_restore_entry* entry, pa_bool_t apply_immediately) {
+    struct userdata *u;
+    datum key, data;
+    int ret;
+
+    pa_assert(m);
+    pa_assert(name);
+    pa_assert(entry);
+
+    u = m->userdata;
+
+    key.dptr = (void*) name;
+    key.dsize = (int) strlen(name);
+
+    data.dptr = (void*) entry;
+    data.dsize = sizeof(*entry);
+
+    if ((ret = gdbm_store(u->gdbm_file, key, data, mode == PA_UPDATE_REPLACE ? GDBM_REPLACE : GDBM_INSERT)) == 0)
+        if (apply_immediately)
+            apply_entry(u, name, entry);
+
+    trigger_save(u);
+
+    return ret;
+}
+
 int pa__init(pa_module*m) {
     pa_modargs *ma = NULL;
     struct userdata *u;
diff --git a/src/modules/module-stream-restore.h b/src/modules/module-stream-restore.h
new file mode 100644
index 0000000..a421b0e
--- /dev/null
+++ b/src/modules/module-stream-restore.h
@@ -0,0 +1,25 @@
+#ifndef foomodulestreamrestorefoo
+#define foomodulestreamrestorefoo
+
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/macro.h>
+#include <pulsecore/namereg.h>
+#include <pulsecore/strlist.h>
+
+struct module_stream_restore_entry {
+  char device[PA_NAME_MAX];
+  pa_channel_map channel_map;
+  pa_cvolume volume;
+  pa_bool_t muted:1;
+};
+
+pa_strlist* module_stream_restore_list_entries(pa_module *m, const char *expr);
+
+struct module_stream_restore_entry* module_stream_restore_read_entry(pa_module *m, const char *name);
+
+int module_stream_restore_update_entry(pa_module *m, pa_update_mode_t mode, const char *name, struct module_stream_restore_entry* entry, pa_bool_t apply_immediately);
+
+void module_stream_restore_sync(pa_module *m);
+
+#endif
-- 
1.6.0.2.514.g23abd3

