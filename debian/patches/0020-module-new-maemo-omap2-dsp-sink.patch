From bae23fd8c427a8cb86178405aea02588b917cd7c Mon Sep 17 00:00:00 2001
From: =?utf-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@gmail.com>
Date: Sat, 13 Dec 2008 21:47:59 +0200
Subject: [PATCH] module: new maemo omap2 dsp sink

---
 configure.ac                               |    9 +
 src/Makefile.am                            |   18 +-
 src/modules/maemo-dsp-util.c               | 1398 ++++++++++++++++++++++++++++
 src/modules/maemo-dsp-util.h               |  263 ++++++
 src/modules/module-maemo-dsp-sink-symdef.h |   25 +
 src/modules/module-maemo-dsp-sink.c        |  413 ++++++++
 6 files changed, 2125 insertions(+), 1 deletions(-)
 create mode 100644 src/modules/maemo-dsp-util.c
 create mode 100644 src/modules/maemo-dsp-util.h
 create mode 100644 src/modules/module-maemo-dsp-sink-symdef.h
 create mode 100644 src/modules/module-maemo-dsp-sink.c

diff --git a/configure.ac b/configure.ac
index 8586dcd..d2db9d1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1043,6 +1043,14 @@ esac],[manpages=yes])
 
 AM_CONDITIONAL([BUILD_MANPAGES], [test "x$manpages" = xyes])
 
+#### maemo DSP support (optional) ####
+
+AC_ARG_ENABLE(
+        [maemo-dsp],
+        AC_HELP_STRING([--enable-maemo-dsp],[Enable maemo DSP support.]),
+        [ENABLE_MAEMO_DSP=yes], [ENABLE_MAEMO_DSP=no])
+AM_CONDITIONAL([MAEMO_DSP], [test "x$ENABLE_MAEMO_DSP" = "xyes"])
+
 #### PulseAudio system group & user  #####
 
 AC_ARG_WITH(system_user, AS_HELP_STRING([--with-system-user=<user>],[User for running the PulseAudio daemon as a system-wide instance (pulse)]))
@@ -1267,6 +1275,7 @@ echo "
     Enable Async DNS:              ${ENABLE_LIBASYNCNS}
     Enable LIRC:                   ${ENABLE_LIRC}
     Enable HAL:                    ${ENABLE_HAL}
+    Enable Maemo DSP:              ${ENABLE_MAEMO_DSP}
     Enable BlueZ:                  ${ENABLE_BLUEZ}
     Enable TCP Wrappers:           ${ENABLE_TCPWRAP}
     Enable libsamplerate:          ${ENABLE_LIBSAMPLERATE}
diff --git a/src/Makefile.am b/src/Makefile.am
index 7b2a20e..91b0286 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1000,6 +1000,11 @@ modlibexec_LTLIBRARIES += \
 endif
 endif
 
+if MAEMO_DSP
+modlibexec_LTLIBRARIES += \
+		libmaemo-dsp-util.la \
+		module-maemo-dsp-sink.la
+endif
 
 # These are generated by a M4 script
 
@@ -1064,7 +1069,8 @@ SYMDEF_FILES = \
 		modules/gconf/module-gconf-symdef.h \
 		modules/module-position-event-sounds-symdef.h \
 		modules/module-console-kit-symdef.h \
-		modules/module-flat-volume-symdef.h
+		modules/module-flat-volume-symdef.h \
+		modules/module-maemo-dsp-sink-symdef.h
 
 EXTRA_DIST += $(SYMDEF_FILES)
 BUILT_SOURCES += $(SYMDEF_FILES)
@@ -1450,6 +1456,16 @@ module_raop_discover_la_LIBADD = $(AM_LIBADD) $(AVAHI_LIBS) libavahi-wrap.la lib
 module_raop_discover_la_CFLAGS = $(AM_CFLAGS) $(AVAHI_CFLAGS)
 
 
+# Maemo
+libmaemo_dsp_util_la_SOURCES =  modules/maemo-dsp-util.c modules/maemo-dsp-util.h
+libmaemo_dsp_util_la_LDFLAGS = -avoid-version
+libmaemo_dsp_util_la_LIBADD = $(AM_LIBADD) libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
+libmaemo_dsp_util_la_CFLAGS = $(AM_CFLAGS)
+
+module_maemo_dsp_sink_la_SOURCES = modules/module-maemo-dsp-sink.c
+module_maemo_dsp_sink_la_LDFLAGS = -module -avoid-version
+module_maemo_dsp_sink_la_LIBADD = $(AM_LIBADD) libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la libmaemo-dsp-util.la libiochannel.la
+
 ###################################
 #        Some minor stuff         #
 ###################################
diff --git a/src/modules/maemo-dsp-util.c b/src/modules/maemo-dsp-util.c
new file mode 100644
index 0000000..2cc9f31
--- /dev/null
+++ b/src/modules/maemo-dsp-util.c
@@ -0,0 +1,1398 @@
+/* $Id$ */
+
+/***
+    Definition of functions whose represents an interface to the DSP PCM Task node protocol.
+
+    Copyright (C) 2006, 2007 Nokia Corporation
+    Author: Marc-Andre Lureau <marc-andre.lureau@nokia.com>
+    Based on ALSA plugin by Eduardo Bezerra Valentin <eduardo.valentin@indt.org.br>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the
+    Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+    Boston, MA 02111-1307, USA.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <poll.h>
+#include <sys/errno.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <math.h>
+#include <sys/ioctl.h>
+#include <sys/sem.h>
+
+#include <pulsecore/macro.h>
+#include <pulsecore/log.h>
+
+#include "maemo-dsp-util.h"
+
+#define MAGIC_NUMBER            0x00A3D70A
+#define PANNING_STEP            0x06
+#define TASK_IOCTL_LOCK         0x10002
+#define TASK_IOCTL_UNLOCK       0x10003
+
+/** No command */
+#define DSP_CMD_NONE            0x00
+/** Informs the DSP that the following data is about initialisation. */
+#define DSP_CMD_INIT            0x01
+/** Informs the DSP that the following data is parameters */
+#define DSP_CMD_SET_PARAMS      0x02
+/** Informs the DSP that the following data is general data (compressed
+ * or raw audio or video)
+ * */
+#define DSP_CMD_DATA_WRITE      0x03
+/** Starts audio or video playback or recording */
+#define DSP_CMD_PLAY            0x04
+/** Pauses playback */
+#define DSP_CMD_PAUSE           0x05
+/** Stops playback */
+#define DSP_CMD_STOP            0x06
+/** Informs the DSP that the following data is volume */
+#define DSP_CMD_SET_VOLUME      0x07
+/** Requests from the DSP to send information about current task node
+ * state
+ * */
+#define DSP_CMD_STATE           0x08
+/** Informs the DSP that the following data is about setting the current
+ *  presentation time
+ * */
+#define DSP_CMD_SET_TIME        0x09
+/** Informs the DSP that the ARM queries the current presentation time */
+#define DSP_CMD_GET_TIME        0x0A
+/** Informs the DSP that the following data is about setting video
+ * post-processing parameters
+ * */
+#define DSP_CMD_SET_POSTPROC    0x0B
+/** Informs the DSP that the following data is about setting the panning
+ * */
+#define DSP_CMD_SET_PANNING     0x0D
+/** Informs the DSP about discontinuity in the audio stream */
+#define DSP_CMD_DISCONT         0x0E
+/** Mutes the audio playback */
+#define DSP_CMD_MUTE            0x0F
+/** Unmutes the audio playback */
+#define DSP_CMD_UNMUTE          0x10
+/**Closes the task node*/
+#define DSP_CMD_CLOSE           0x14
+/** Command from DSP to start to read data*/
+#define DSP_CMD_DATA_READ       0x25
+/**Sets speech parameters*/
+#define DSP_CMD_SET_SPEECH_PARAMS 0x26
+
+/**
+ * DSP Return values
+ * */
+/** Operation successful */
+#define DSP_OK                  0x01
+/** Unrecognised or unsupported command value */
+#define DSP_ERROR_CMD           0x02
+/** Unrecognised or unsupported audio format value */
+#define DSP_ERROR_FMT           0x03
+/** Unrecognised or unsupported sampling rate value */
+#define DSP_ERROR_RATE          0x04
+/** Unrecognised or unsupported number of channels */
+#define DSP_ERROR_CHANNELS      0x05
+/** Destination/source stream ID out of range */
+#define DSP_ERROR_DS_ID         0x06
+/** Insufficient memory to perform requested action */
+#define DSP_ERROR_MEMORY        0x07
+/** Unspecified error */
+#define DSP_ERROR_GENERAL       0x08
+/** Error in stream (audio or video) */
+#define DSP_ERROR_STREAM        0x09
+/** Unexpected task node state */
+#define DSP_ERROR_STATE         0x0A
+/** Error in synchronisation:
+    For MP3 – synchronisation marker not found */
+#define DSP_ERROR_SYNC          0x0B
+/** For MPEG4: non-compliant video stream */
+#define DSP_ERROR_VIDEO_NON_COMPLIANT 0x100
+/** For MPEG4: Error in VOS */
+#define DSP_ERROR_VIDEO_FAULT_IN_VOS  0x101
+/** For MPEG4: Image size not supported */
+#define DSP_ERROR_VIDEO_SIZE_NOT_SUPPORTED 0x102
+/** End of VOS code reached */
+#define DSP_ERROR_VIDEO_VOS_END_CODE 0x103
+/**
+ * Channels
+ * */
+/** One channel (mono) */
+#define CHANNELS_1              0x01
+/** Two channels (stereo) */
+#define CHANNELS_2              0x02
+
+/** Sending commands */
+#define REQUEST_CONFIRMATION    0x01
+#define WITHOU_CONFIRMATION     0x00
+
+const char *dsp_commands[] = {
+    "DSP_CMD_NONE", "No command",
+    "DSP_CMD_INIT", "Informs the DSP that the following data is"
+    "about initialisation",
+    "DSP_CMD_SET_PARAMS", "Informs the DSP that the following "
+    "data is parameters",
+    "DSP_CMD_DATA_WRITE", "Informs the DSP that the following "
+    "data is general data (compressed " "or raw audio or video)",
+    "DSP_CMD_PLAY", "Starts audio or video playback or recording",
+    "DSP_CMD_PAUSE", "Pauses playback",
+    "DSP_CMD_STOP", "Stops playback",
+    "DSP_CMD_SET_VOLUME", "Informs the DSP that the following "
+    "data is volume",
+    "DSP_CMD_STATE", "Requests from the DSP to send information"
+    " about current task node state",
+    "DSP_CMD_SET_TIME", "Informs the DSP that the following data"
+    " is about setting the current" " presentation time",
+    "DSP_CMD_GET_TIME", "Informs the DSP that the ARM queries the"
+    " current presentation time",
+    "ERROR", "This is unused!!!!!",
+    "DSP_CMD_SET_POSTPROC", "Informs the DSP that the following data"
+    " is about setting video post-processing " "parameters",
+    "DSP_CMD_SET_PANNING", "Informs the DSP that the following data "
+    "is about setting the panning",
+    "DSP_CMD_DISCONT", "Informs the DSP about discontinuity in the "
+    "audio stream",
+    "DSP_CMD_MUTE", "Mutes the audio playback",
+    "DSP_CMD_UNMUTE", "Unmutes the audio playback",
+    "ERROR", "This is unused!!!!!",
+    "ERROR", "This is unused!!!!!",
+    "ERROR", "This is unused!!!!!",
+    "DSP_CMD_CLOSE", "Closes the task node"
+};
+
+const char *dsp_return_values[] = {
+    "DSP_NONE", "Error. This isn't a valid return value",
+    "DSP_OK", "Operation successful",
+    "DSP_ERROR_CMD", "Unrecognised or unsupported command value",
+    "DSP_ERROR_FMT", "Unrecognised or unsupported audio format value",
+    "DSP_ERROR_RATE", "Unrecognised or unsupported sampling rate value",
+    "DSP_ERROR_CHANNELS", "Unrecognised or unsupported number of channels",
+    "DSP_ERROR_DS_id", "Destination/source stream id out of range",
+    "DSP_ERROR_MEMORY", "Insufficient memory to perform requested action",
+    "DSP_ERROR_GENERAL", "Unspecified error",
+    "DSP_ERROR_STREAM", "Error in stream (audio or video)",
+    "DSP_ERROR_STATE", "Unexpected task node state",
+    "DSP_ERROR_SYNC", "Error in synchronisation:"
+    "For MP3 – synchronisation marker not found"
+};
+
+const char *dsp_states[] = {
+    "STATE_INITIALISED", "Initialised",
+    "STATE_PLAYING", "Playing/recording",
+    "STATE_STOPPED", "Stopped",
+    "STATE_PAUSED", "Paused",
+    "STATE_UNINITIALISED", "Not initialised",
+    "STATE_RESET", "Reseted",
+    "STATE_MUTED", "Muted"
+};
+
+const char *dsp_rates[] = {
+    "SAMPLE_RATE_96KHZ", "96KHz sampling rate",
+    "SAMPLE_RATE_88_2KHZ", "88.2KHz sampling rate",
+    "SAMPLE_RATE_64KHZ", "64KHz sampling rate",
+    "SAMPLE_RATE_48KHZ", "48KHz sampling rate",
+    "SAMPLE_RATE_44_1KHZ", "44.1KHz sampling rate",
+    "SAMPLE_RATE_32KHZ", "32KHz sampling rate",
+    "SAMPLE_RATE_24KHZ", "24KHz sampling rate",
+    "SAMPLE_RATE_22_05KHZ", "22.05KHz sampling rate",
+    "SAMPLE_RATE_16KHZ", "16KHz sampling rate",
+    "SAMPLE_RATE_12KHZ", "12KHz sampling rate",
+    "SAMPLE_RATE_11_025KHZ", "11.025KHz sampling rate",
+    "SAMPLE_RATE_8KHZ", "8KHz sampling rate",
+    "SAMPLE_RATE_5_5125KHZ", "5.5125Khz sampling rate"
+};
+
+const char *dsp_channels[] = {
+    "0--", "Error - No channel!",
+    "CHANNELS_1", "One channel (mono)",
+    "CHANNELS_2", "Two channels (stereo)"
+};
+
+const char *dsp_audio_fmt[] = {
+    "0", "Error No format!!!",
+    "DSP_AFMT_U8", "Unsigned 8 bits per sample PCM",
+    "DSP_AFMT_S16_LE", "Signed 16 bits per sample PCM, little endian",
+    "DSP_AFMT_S16_BE", "Signed 16 bits per sample PCM, big endian",
+    "DSP_AFMT_S8", "Signed 8 bits per sample PCM",
+    "DSP_AFMT_U16_LE", "Unsigned 16 bits per sample PCM, little endian",
+    "DSP_AFMT_U16_BE", "Unsigned 16 bits per sample PCM, big endian",
+    "DSP_AFMT_ALAW", "A-law encoded PCM",
+    "DSP_AFMT_ULAW", "μ-Law encoded PCM",
+    "DSP_AFMT_MP3", "MP3 stream",
+    "DSP_AFMT_AAC", "AAC stream",
+    "DSP_AFMT_AMR", "AMR stream",
+    "DSP_AFMT_MP2", "MP2 stream",
+    "DSP_AFMT_ILBC", "iLBC stream",
+    "DSP_AFMT_G729", "G.729 stream"
+};
+
+#define ARRAY_SIZE(ary) (sizeof(ary)/sizeof(ary[0]))
+#define report_table(mens,name,value,table)			\
+    do{								\
+	if ((unsigned)value >= ARRAY_SIZE(table))		\
+	    pa_log_debug("%s: %d isnt a valid %s value\n",mens,	\
+			 value,name);				\
+	else							\
+	    pa_log_debug("%s: [%d|%s] - %s\n", mens, value,	\
+			 table[value * 2],			\
+			 table[value * 2 + 1]);			\
+    }while(0)
+
+#define report_command(m,v)             report_table(m,"command",v,	\
+						     /*20,*/dsp_commands)
+#define report_return_value(m,v)        report_table(m,"return",v,	\
+						     /*11,*/dsp_return_values)
+#define report_state(m,v)               report_table(m,"state",v,	\
+						     /*6,*/dsp_states)
+#define report_sample_rate(m,v)         report_table(m,"sample rate",v,	\
+						     /*12,*/dsp_rates)
+#define report_number_channels(m,v)     report_table(m,"number of channels",v, \
+						     /*2,*/dsp_channels)
+#define report_audio_fmt(m,v)           report_table(m,"audio format",v, \
+						     /*14,*/dsp_audio_fmt)
+#define report_dsp_protocol(m,dp)		\
+    do{						\
+	pa_log_debug("%s:\n"			\
+		     "fd: %d\n"			\
+		     "stream_id: %d\n"		\
+		     "bridge_buffer_size: %d\n"	\
+		     "mmap_buffer_size: %d\n"	\
+		     "mmap_buffer: %p\n",	\
+		     m,				\
+		     dp->fd,			\
+		     dp->stream_id,		\
+		     dp->bridge_buffer_size,	\
+		     dp->mmap_buffer_size,	\
+		     dp->mmap_buffer);		\
+	report_state("state", dp->state);	\
+    }while(0)
+
+#define report_audio_status_info(m, asi)				\
+    do{									\
+	pa_log_debug("%s\n", m);					\
+	pa_log_debug("***** Audio status info *****\n");		\
+	report_command("\tdsp_cmd", asi.dsp_cmd);			\
+	pa_log_debug("\tstream_id: %d\n", asi.stream_id);		\
+	pa_log_debug("\tds_stream_id: %d\n", asi.ds_stream_id);		\
+	pa_log_debug("\tbridge_buffer_size: %d\n", asi.bridge_buffer_size); \
+	pa_log_debug("\tmmap_buffer_size: %d\n", asi.mmap_buffer_size);	\
+	report_state("\tstatus", asi.status);				\
+	pa_log_debug("\tnum_frames: %d\n", asi.num_frames);		\
+	report_sample_rate("\tsample_rate", asi.sample_rate);		\
+	report_number_channels("\tnumber_channels",			\
+			       asi.number_channels);			\
+	pa_log_debug("\tvol_scale: %d\n", asi.vol_scale);		\
+	pa_log_debug("\tvol_power2: %d\n", asi.vol_power2);		\
+	pa_log_debug("\tleft_gain: %d\n", asi.left_gain);		\
+	pa_log_debug("\tright_gain: %d\n", asi.right_gain);		\
+	report_audio_fmt("\tdsp_audio_fmt", asi.dsp_audio_fmt);		\
+    }while(0)
+
+#define report_audio_init_status(m, ais)				\
+    do{									\
+	pa_log_debug("%s\n", m);					\
+	pa_log_debug("***** Audio init status *****\n");		\
+	report_command("\tdsp_cmd", ais.dsp_cmd);			\
+	pa_log_debug("\tstream_id: %d\n", ais.stream_id);		\
+	pa_log_debug("\tbridge_buffer_size: %d\n", ais.bridge_buffer_size); \
+	pa_log_debug("\tmmap_buffer_size: %d\n", ais.mmap_buffer_size);	\
+	report_return_value("\tinit_status", ais.init_status);		\
+    }while(0)
+
+#define report_audio_params(m,ap)					\
+    do{									\
+	pa_log_debug("%s\n",m);						\
+	pa_log_debug("**** Audio parameters *****\n");			\
+	report_command("\tdsp_cmd",ap.dsp_cmd);				\
+	report_audio_fmt("\taudio_format", ap.dsp_audio_fmt);		\
+	report_sample_rate("\tsample_rate", ap.sample_rate);		\
+	pa_log_debug("Number of channels %d\n", ap.number_channels);	\
+	pa_log_debug("ds_stream_id: %d\n", ap.ds_stream_id);		\
+	pa_log_debug("stream_priority: %d\n", ap.stream_priority);	\
+    }while(0)
+
+#define report_speech_params(m,sp)					\
+    do{									\
+	pa_log_debug("%s\n",m);						\
+	pa_log_debug("**** Speech parameters *****\n");			\
+	pa_log_debug("\tdsp_cmd 0x%x\n",sp.dsp_cmd);			\
+	report_audio_fmt("\taudio_format", sp.audio_fmt);		\
+	report_sample_rate("\tsample_rate", sp.sample_rate);		\
+	pa_log_debug("ds_stream_id: %d\n", sp.ds_stream_id);		\
+	pa_log_debug("stream_priority: %d\n", sp.stream_priority);	\
+	pa_log_debug("frame_size: %d\n", sp.frame_size);		\
+    }while(0)
+
+/* internal datatypes declarations */
+union semun {
+    int val; /* value for SETVAL */
+    struct semid_ds *buf; /* buffer for IPC_STAT & IPC_SET */
+    u_short *array;     /* array for GETALL & SETALL */
+};
+
+/* internal features declarations */
+static int dsp_protocol_flush(dsp_protocol_t *dsp_protocol);
+static int dsp_protocol_send_command(dsp_protocol_t *dsp_protocol, const short int command);
+static void dsp_protocol_linear2Q15(const unsigned short int input, unsigned short int *scale, unsigned short int *power2);
+static void dsp_protocol_Q152linear(const unsigned short int scale, const unsigned short int power2, unsigned short int *output);
+static int dsp_protocol_update_state(dsp_protocol_t *dsp_protocol);
+static inline int dsp_protocol_get_sem(dsp_protocol_t *dsp_protocol);
+static inline int dsp_protocol_lock_dev(dsp_protocol_t *dsp_protocol);
+static inline int dsp_protocol_unlock_dev(dsp_protocol_t *dsp_protocol);
+
+/* Initialisation phase features definitions */
+/**
+ * @param dsp_protocol DSP protocol reference pointer to be instanciated.
+ *
+ * Creates new dsp_protocol object instance and initializes it
+ * with default parameters. After this the device must be
+ * separately opened with gst_dspaudio_open_node() method.
+ *
+ * @return zero if success, otherwise a negative error code
+ *          (-ENOMEM - fail when requesting memory for data structures).
+ */
+int dsp_protocol_create(dsp_protocol_t **dsp_protocol) {
+    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
+    int ret = 0;
+
+    *dsp_protocol = (dsp_protocol_t *) calloc(1, sizeof(dsp_protocol_t));
+    if ((*dsp_protocol) == NULL) {
+        pa_log_error("Could not allocate dsp_protocol instance\n");
+        ret = -ENOMEM;
+        goto out;
+    }
+    (*dsp_protocol)->fd = -1;
+    (*dsp_protocol)->device = NULL;
+    (*dsp_protocol)->state = STATE_UNINITIALISED;
+    (*dsp_protocol)->mute = 0;
+    (*dsp_protocol)->stream_id = 0;
+    (*dsp_protocol)->bridge_buffer_size = 0;
+    (*dsp_protocol)->mmap_buffer_size = 0;
+    (*dsp_protocol)->mmap_buffer = NULL;
+    (*dsp_protocol)->mutex = mutex;
+    (*dsp_protocol)->sem_set_id = -1;
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol DSP protocol reference pointer to be initialized.
+ * @param device dsp device node name.
+ *
+ * Opens pcm dsp device file and initializes dsp_protocol
+ * with information about stream, state and mmapbuffer.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+int dsp_protocol_open_node(dsp_protocol_t *dsp_protocol, const char *device) {
+    int ret;
+    short int tmp;
+    audio_status_info_t audio_status_info;
+    audio_init_status_t audio_init_status;
+
+    if (dsp_protocol->state != STATE_UNINITIALISED) {
+        report_dsp_protocol("Trying to send open node from a non-valid state", dsp_protocol);
+        ret = -EIO;
+        goto out;
+    }
+
+    dsp_protocol->fd = open(device, O_RDWR);
+    if (dsp_protocol->fd < 0) {
+        pa_log_error("Could not open pcm device file %s\n", device);
+        ret = errno;
+        goto out;
+    }
+    dsp_protocol->device = strdup(device);
+    dsp_protocol_get_sem(dsp_protocol);
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    if ((ret = dsp_protocol_flush(dsp_protocol)) < 0)
+        goto unlock;
+    tmp = DSP_CMD_STATE;
+    if (write(dsp_protocol->fd, &tmp, sizeof(short int)) < 0) {
+        ret = -EIO;
+        goto unlock;
+    }
+    if ((ret = read(dsp_protocol->fd, &audio_status_info, sizeof(audio_status_info_t))) < 0) {
+        report_dsp_protocol("Could not read audio_status_info", dsp_protocol);
+        goto unlock;
+    }
+    report_audio_status_info("Received:", audio_status_info);
+    if (audio_status_info.status == STATE_UNINITIALISED) {
+        tmp = DSP_CMD_INIT;
+        if (write(dsp_protocol->fd, &tmp, sizeof(short int)) < 0) {
+            ret = -EIO;
+            goto unlock;
+        }
+        if ((ret = read(dsp_protocol->fd, &audio_init_status, sizeof(audio_init_status_t))) < 0) {
+            report_dsp_protocol("Error reading INIT status", dsp_protocol);
+            goto unlock;
+        }
+        report_audio_init_status("Received:", audio_init_status);
+        /* receive info from audio_init_status */
+        dsp_protocol->stream_id = audio_init_status.stream_id;
+        dsp_protocol->bridge_buffer_size = audio_init_status.bridge_buffer_size;
+        dsp_protocol->mmap_buffer_size = audio_init_status.mmap_buffer_size;
+    } else {
+        /* This pcm task node is busy. Try to use another one. */
+        ret = -EBUSY;
+        goto unlock;
+    }
+    dsp_protocol->mmap_buffer = (short int *) mmap((void *)0, dsp_protocol->mmap_buffer_size, PROT_READ | PROT_WRITE, MAP_SHARED, dsp_protocol->fd, 0);
+
+    if (dsp_protocol->mmap_buffer == NULL) {
+        report_dsp_protocol("Cannot mmap data buffer", dsp_protocol);
+        ret = -ENOMEM;
+        goto unlock;
+    }
+    dsp_protocol->state = STATE_INITIALISED;
+    report_dsp_protocol("connection stablished:", dsp_protocol);
+
+    ret = 0;
+ unlock:
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol DSP protocol reference pointer.
+ * @param audio_params_data audio params to be sent to the dsp.
+ *
+ * Send audio params to pcm task node and checks if
+ * it was sent properly.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+int dsp_protocol_send_audio_params(dsp_protocol_t *dsp_protocol, audio_params_data_t *audio_params_data) {
+    int ret;
+    dsp_cmd_status_t audio_cmd_status;
+
+    if (dsp_protocol->state != STATE_INITIALISED) {
+        report_dsp_protocol("Trying to send audio parameters from a non-valid state", dsp_protocol);
+        ret = -EIO;
+        goto out;
+    }
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    audio_params_data->ds_stream_id = dsp_protocol->stream_id;
+    if (write(dsp_protocol->fd, audio_params_data, sizeof(audio_params_data_t)) < 0) {
+        ret = -1;
+        report_dsp_protocol("Could not send audio_params_data", dsp_protocol);
+        goto unlock;
+    }
+    if (read(dsp_protocol->fd, &audio_cmd_status, sizeof(dsp_cmd_status_t)) < 0) {
+        ret = -1;
+        report_dsp_protocol("Could not receive DSP_CMD_STATUS", dsp_protocol);
+        goto unlock;
+    }
+    if (audio_cmd_status.status != DSP_OK) {
+        ret = -1;
+    pa_log("g");
+        report_dsp_protocol("DSP returned a diferent Status of DSP_OK", dsp_protocol);
+        report_return_value("DSP returned", audio_cmd_status.status);
+        report_audio_params("Audio params sent", (*audio_params_data));
+        goto unlock;
+    }
+    report_audio_params("Audio params sent", (*audio_params_data));
+    ret = 0;
+ unlock:
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol DSP protocol reference pointer.
+ * @param speech_params_data audio params to be sent to the dsp.
+ *
+ * Send audio params to pcm_rec task node and checks if
+ * it was sent properly.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+int dsp_protocol_send_speech_params(dsp_protocol_t *dsp_protocol, speech_params_data_t *speech_params_data) {
+    int ret;
+    dsp_cmd_status_t audio_cmd_status;
+
+    if (dsp_protocol->state != STATE_INITIALISED) {
+        report_dsp_protocol("Trying to send speech parameters from a non-valid state", dsp_protocol);
+        ret = -EIO;
+        goto out;
+    }
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    speech_params_data->ds_stream_id = dsp_protocol->stream_id;
+    if (write(dsp_protocol->fd, speech_params_data, sizeof(speech_params_data_t)) < 0) {
+        ret = -1;
+        report_dsp_protocol("Could not send speech_params_data", dsp_protocol);
+        goto unlock;
+    }
+    if (read(dsp_protocol->fd, &audio_cmd_status, sizeof(dsp_cmd_status_t)) < 0) {
+        ret = -1;
+        report_dsp_protocol("Could not receive DSP_CMD_STATUS", dsp_protocol);
+        goto unlock;
+    }
+    if (audio_cmd_status.status != DSP_OK) {
+        ret = -1;
+        report_dsp_protocol("DSP returned a diferent Status of DSP_OK", dsp_protocol);
+        report_return_value("DSP returned", audio_cmd_status.status);
+        report_speech_params("Speech params sent", (*speech_params_data));
+        goto unlock;
+    }
+    report_speech_params("Speech params sent", (*speech_params_data));
+    ret = 0;
+ unlock:
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/* Execution phase features definitions */
+/**
+ * @param dsp_protocol dsp_protocol_t structure.
+ *
+ * It starts a playback section sending a DSP_CMD_PLAY. It flushes
+ * all pending message comming from DSP side after DSP_CMD_PLAY.
+ *
+ * @return zero if success, otherwise a negative error code
+ *          (-EIO - sending play from a non-valid state).
+ */
+int dsp_protocol_send_play(dsp_protocol_t *dsp_protocol) {
+    int ret;
+
+    if (dsp_protocol->state == STATE_UNINITIALISED) {
+        report_dsp_protocol("Trying to send play from a non-valid state", dsp_protocol);
+        ret = -EIO;
+        goto out;
+    }
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    if (dsp_protocol->state == STATE_PLAYING)
+        ret = 0;
+    else {
+        if ((ret = dsp_protocol_send_command(dsp_protocol, DSP_CMD_PLAY)) == 0)
+            dsp_protocol->state = STATE_PLAYING;
+        dsp_protocol_flush(dsp_protocol);
+        //Both, read and write remain data on the mbx system
+    }
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol dsp_protocol_t structure.
+ * @param data audio data buffer.
+ * @param count amount of data to be copied (in TUint16).
+ *
+ * It copies audio data to the mmap area in the right moment.
+ *
+ * @return if success, it returns the amount of data was sent.
+ * If called in a wrong moment, it returns 0.  Otherwise, a negative error code.
+ */
+int dsp_protocol_send_audio_data(dsp_protocol_t *dsp_protocol, void *data, unsigned short int count /* TUint16 */ ) {
+    write_status_t write_status;
+    data_write_t data_write;
+    int ret = 0;
+
+    pa_log_debug("count %d\n", count);
+    if (dsp_protocol->state != STATE_PLAYING) {
+        report_dsp_protocol("Not in the STATE_PLAYING\n", dsp_protocol);
+        goto out;
+    }
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+
+    memcpy(dsp_protocol->mmap_buffer, data, count * 2);
+    data_write.dsp_cmd = DSP_CMD_DATA_WRITE;
+    data_write.data_size = count;
+    if ((ret = write(dsp_protocol->fd, &data_write, sizeof(data_write_t))) < 0)
+        goto unlock;
+
+    if ((ret = read(dsp_protocol->fd, &write_status, sizeof(write_status_t))) < 0)
+        goto unlock;
+    if (write_status.dsp_cmd == DSP_CMD_DATA_WRITE) {
+
+        if (write_status.status == DSP_OK) {
+            ret = count;
+            pa_log_debug("%d words sent\n", ret);
+        } else {
+            pa_log_debug("Received a response different of DSP_OK\n");
+            report_return_value("Returned value:", write_status.status);
+            report_dsp_protocol("Current dsp_protocol", dsp_protocol);
+            ret = 0;
+        }
+    } else {
+        report_dsp_protocol("Could not send audio data", dsp_protocol);
+        report_command("Returned cmd", write_status.dsp_cmd);
+        ret = 0;
+    }
+
+ unlock:
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+
+}
+
+/**
+ * @param dsp_protocol dsp_protocol_t structure.
+ * @param data audio data buffer.
+ * @param count amount of data to be copied (in TUint16).
+ *
+ * It copies the audio data from the mmap area in the right moment.
+ *
+ * @return if success, it returns the amount of data was received.
+ * If called in a wrong moment, it returns 0.  Otherwise, a negative error code.
+ */
+int dsp_protocol_receive_audio_data(dsp_protocol_t *dsp_protocol, void *data, int count /* TU16int */ ) {
+    read_status_t read_status;
+    dsp_cmd_status_t audio_cmd_status;
+
+    int ret = 0;
+
+    pa_log_debug("count %d\n", count);
+    if (dsp_protocol->state != STATE_PLAYING) {
+        report_dsp_protocol("Not in the STATE_PLAYING\n", dsp_protocol);
+        goto out;
+    }
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    memcpy(data, dsp_protocol->mmap_buffer, count * 2);
+    audio_cmd_status.dsp_cmd = DSP_CMD_DATA_READ;
+    audio_cmd_status.status = DSP_OK;
+    if ((ret = write(dsp_protocol->fd, &audio_cmd_status, sizeof(dsp_cmd_status_t))) < 0)
+        goto unlock;
+    if ((ret = read(dsp_protocol->fd, &read_status, sizeof(read_status_t))) < 0)
+        goto unlock;
+    if (read_status.dsp_cmd == DSP_CMD_DATA_READ) {
+        if (read_status.status == DSP_OK) {
+            pa_log_debug("---------> DSP: ### %d ###\n", read_status.frame_size);
+            ret = count;
+            pa_log_debug("%d words sent\n", ret);
+        } else {
+            report_dsp_protocol("Receive a status different from DSP_OK (skiping block)", dsp_protocol);
+            report_return_value("Returned: ", read_status.status);
+            ret = 0;
+        }
+
+    } else {
+        report_dsp_protocol("Could not receive audio data", dsp_protocol);
+        pa_log_debug("Returned cmd %d expected %d\n", read_status.dsp_cmd, DSP_CMD_DATA_READ);
+        report_return_value("Returned: ", read_status.status);
+        ret = 0;
+    }
+ unlock:
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol dsp_protocol_t structure.
+ *
+ * It pauses a playback section sending a DSP_CMD_PAUSE.
+ *
+ * @return zero if success, otherwise a negative error code
+ *          (-EIO - sending play from a non-valid state).
+ */
+int dsp_protocol_send_pause(dsp_protocol_t *dsp_protocol) {
+    int ret;
+
+    if (dsp_protocol->state != STATE_PLAYING) {
+        report_dsp_protocol("Not in the STATE_PLAYING\n", dsp_protocol);
+        ret = -EIO;
+        goto out;
+    }
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    if (dsp_protocol->state == STATE_PAUSED)
+        ret = 0;
+    else {
+        if ((ret = dsp_protocol_send_command(dsp_protocol, DSP_CMD_PAUSE)) == 0)
+            dsp_protocol->state = STATE_PAUSED;
+    }
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol dsp_protocol_t structure.
+ *
+ * It stops a playback section sending a DSP_CMD_STOP.
+ *
+ * @return zero if success, otherwise a negative error code
+ *          (-EIO - sending play from a non-valid state).
+ */
+int dsp_protocol_send_stop(dsp_protocol_t *dsp_protocol) {
+    int ret;
+
+    if (dsp_protocol->state != STATE_PLAYING) {
+        report_dsp_protocol("Not in the STATE_PLAYING\n", dsp_protocol);
+        ret = -EIO;
+        goto out;
+    }
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    if (dsp_protocol->state == STATE_STOPPED)
+        ret = 0;
+    else {
+        if ((ret = dsp_protocol_send_command(dsp_protocol, DSP_CMD_STOP)) == 0)
+            dsp_protocol->state = STATE_STOPPED;
+    }
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/* Deletion phase features definitions */
+/**
+ * @param dsp_protocol DSP protocol reference pointer to be uninitialized.
+ *
+ * It closes the connection with pcm dsp task node. It flushes all
+ * pending data before that. Closes the mmap area. Initialize the
+ * dsp_protocol structure with unused values.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+int dsp_protocol_close_node(dsp_protocol_t *dsp_protocol) {
+    int ret;
+
+    if (dsp_protocol->state != STATE_UNINITIALISED) {
+        if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+            goto out;
+        if ((ret = dsp_protocol_flush(dsp_protocol)) < 0)
+            goto unlock;
+        if ((ret = dsp_protocol_send_command(dsp_protocol, DSP_CMD_CLOSE)) < 0)
+            goto unlock;
+    }
+
+    if (dsp_protocol->mmap_buffer)
+        munmap(dsp_protocol->mmap_buffer, dsp_protocol->mmap_buffer_size);
+    close(dsp_protocol->fd);
+    dsp_protocol->fd = -1;
+    free(dsp_protocol->device);
+    dsp_protocol->device = NULL;
+    dsp_protocol->state = STATE_UNINITIALISED;
+    dsp_protocol->mute = 0;
+    dsp_protocol->stream_id = 0;
+    dsp_protocol->bridge_buffer_size = 0;
+    dsp_protocol->mmap_buffer_size = 0;
+    dsp_protocol->mmap_buffer = NULL;
+    ret = 0;
+ unlock:
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol DSP protocol reference pointer.
+ *
+ * It frees all the allocated memory. It sets NULL to the pointer.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+int dsp_protocol_destroy(dsp_protocol_t **dsp_protocol) {
+    int ret = 0;
+
+    if (*dsp_protocol) {
+        if ((*dsp_protocol)->device)
+            free((*dsp_protocol)->device);
+        free((*dsp_protocol));
+        *dsp_protocol = NULL;
+    }
+    return ret;
+}
+
+/* controls features definitions */
+/**
+ * dsp_protocol_set_volume:
+ *
+ * @param dsp_protocol dsp_protocol_t structure.
+ * @param left left channel volume value (0 - 100).
+ * @param right right channel volume value (0 - 100).
+ *
+ * It changes volume data for both left and right channels.
+ * It receives both values in a 0 - 100 scale.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+int dsp_protocol_set_volume(dsp_protocol_t *dsp_protocol, unsigned char left, unsigned char right) {
+    int ret;
+    dsp_cmd_status_t audio_cmd_status;
+    volume_data_t volume_data;
+    panning_data_t panning_data;
+
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    dsp_protocol_linear2Q15(left > right ? left : right, &volume_data.scale, &volume_data.power2);
+    volume_data.dsp_cmd = DSP_CMD_SET_VOLUME;
+    if ((ret = write(dsp_protocol->fd, &volume_data, sizeof(volume_data_t))) < 0)
+        goto unlock;
+    if (read(dsp_protocol->fd, &audio_cmd_status, sizeof(dsp_cmd_status_t)) < 0) {
+        ret = -EINVAL;
+        report_dsp_protocol("Could not receive DSP_CMD_STATUS", dsp_protocol);
+        goto unlock;
+    }
+    report_return_value("Received", audio_cmd_status.status);
+    ret = 0;
+    if (audio_cmd_status.status != DSP_OK)
+        ret = -EIO;
+    if (ret == 0) {        /*if sucess till here, update panning info */
+        panning_data.dsp_cmd = DSP_CMD_SET_PANNING;
+        panning_data.steps = PANNING_STEP;
+        if (left != right) {
+            panning_data.left_gain = left > right ? 0x4000 : (1.0 * left) / right * 0x4000;
+            panning_data.right_gain = right > left ? 0x4000 : (1.0 * right) / left * 0x4000;
+        } else {
+            panning_data.left_gain = 0x4000;
+            panning_data.right_gain = 0x4000;
+        }
+        pa_log_debug("left gain %x right gain %x\n", panning_data.left_gain, panning_data.right_gain);
+        if ((ret = write(dsp_protocol->fd, &panning_data, sizeof(panning_data_t))) < 0)
+            goto unlock;
+        if (read(dsp_protocol->fd, &audio_cmd_status, sizeof(dsp_cmd_status_t)) < 0) {
+            ret = -EINVAL;
+            report_dsp_protocol("Could not receive DSP_CMD_STATUS", dsp_protocol);
+            goto unlock;
+        }
+        ret = 0;
+        if (audio_cmd_status.status != DSP_OK)
+            ret = -EIO;
+    }
+ unlock:
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol dsp_protocol_t structure.
+ * @param left left channel volume value output (0 - 100).
+ * @param right right channel volume value output (0 - 100).
+ *
+ * It returns volume data for both left and right channels.
+ * It provides both values in a 0 - 100 scale.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+int dsp_protocol_get_volume(dsp_protocol_t *dsp_protocol, unsigned char *left, unsigned char *right) {
+    unsigned short int tmp;
+    int ret;
+    audio_status_info_t audio_status_info;
+
+    tmp = DSP_CMD_STATE;
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+
+    if (write(dsp_protocol->fd, &tmp, sizeof(short int)) < 0) {
+        ret = -EIO;
+        goto unlock;
+    }
+    if ((ret = read(dsp_protocol->fd, &audio_status_info, sizeof(audio_status_info_t))) < 0) {
+        report_dsp_protocol("Could not read audio_status_info", dsp_protocol);
+        goto unlock;
+    }
+    dsp_protocol->state = audio_status_info.status;
+    report_audio_status_info("Received:", audio_status_info);
+    dsp_protocol_Q152linear(audio_status_info.vol_scale, audio_status_info.vol_power2, &tmp);
+    *left = tmp;
+    *right = tmp;
+    if (audio_status_info.number_channels == CHANNELS_2) {
+        if (audio_status_info.left_gain > audio_status_info.right_gain) {
+            float result = *right * audio_status_info.right_gain / (0x4000 * 1.0);
+            *right = result;
+            if ((result - *right) > 0.5)
+                (*right)++;
+        }
+        if (audio_status_info.left_gain < audio_status_info.right_gain) {
+            float result = *left * audio_status_info.left_gain / (0x4000 * 1.0);
+            *left = result;
+            if ((result - *left) > 0.5)
+                (*left)++;
+        }
+    }
+    ret = 0;
+ unlock:
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol dsp_protocol_t structure.
+ * @param mute mute value (0 unmuted - 1 muted).
+ *
+ * It changes mute state of DSP task node sending DSP_CMD_[UN]MUTE.
+ * Provide 0 in mute to unmute, and 1 in mute to mute.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+int dsp_protocol_set_mute(dsp_protocol_t *dsp_protocol, unsigned char mute) {
+    int ret = 0;
+    int command;
+
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    if (mute == 1)
+        command = DSP_CMD_MUTE;
+    else
+        command = DSP_CMD_UNMUTE;
+    ret = dsp_protocol_send_command(dsp_protocol, command);
+    dsp_protocol->mute = mute;
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol dsp_protocol_t structure.
+ *
+ * It returns mute state of DSP task node.
+ *
+ * @return zero if success, it returns current state of mute.
+ * 0 means not muted. 1 means muted. otherwise a negative error code.
+ */
+int dsp_protocol_get_mute(dsp_protocol_t *dsp_protocol) {
+    int ret = 0;
+
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    ret = dsp_protocol_update_state(dsp_protocol);
+    if (ret >= 0)
+        ret = dsp_protocol->mute;
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol dsp_protocol_t structure.
+ * @param device dsp task node file name.
+ *
+ * It opens a dsp task node and queries for its states.
+ *
+ * @return if success, it returns number of channels whose dsp task is
+ * currently using (1 - mono. 2 stero). otherwise a negative error code.
+ */
+int dsp_protocol_probe_node(dsp_protocol_t *dsp_protocol, const char *device) {
+    int ret;
+
+    if (dsp_protocol->state != STATE_UNINITIALISED) {
+        report_dsp_protocol ("Trying to send open node from a non-valid state", dsp_protocol);
+        ret = -EIO;
+        goto out;
+    }
+
+    dsp_protocol->fd = open(device, O_RDWR);
+    if (dsp_protocol->fd < 0) {
+        pa_log_error("Could not open pcm device file %s\n", device);
+        ret = errno;
+        goto out;
+    }
+    dsp_protocol->device = strdup(device);
+    dsp_protocol_get_sem(dsp_protocol);
+
+    if ((ret = dsp_protocol_lock_dev(dsp_protocol)) < 0)
+        goto out;
+    dsp_protocol->device = strdup(device);
+    ret = dsp_protocol_update_state(dsp_protocol);
+    if (ret != CHANNELS_1 && ret != CHANNELS_2)
+        ret = CHANNELS_1;
+    dsp_protocol_unlock_dev(dsp_protocol);
+ out:
+    return ret;
+
+}
+
+/**
+ * @param str string with a number.
+ * @param val holder for the conversion result.
+ *
+ * It converts a string to a number (long).
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+int safe_strtol(const char *str, long *val) {
+    char *end;
+    long v;
+    int ret;
+
+    if (!*str) {
+        ret = -EINVAL;
+        goto out;
+    }
+    errno = 0;
+    v = strtol(str, &end, 0);
+    if (errno) {
+        ret = -errno;
+        goto out;
+    }
+    if (*end) {
+        ret = -EINVAL;
+        goto out;
+    }
+    *val = v;
+    ret = 0;
+ out:
+    return ret;
+}
+
+/* internal features definitions */
+/**
+ * @param dsp_protocol  dsp_protocol_t structure.
+ *
+ * Tries to read all the pending data.
+ *
+ * @return zero. success
+ */
+static int dsp_protocol_flush(dsp_protocol_t *dsp_protocol) {
+    struct pollfd pollf;
+    int ret = 0;
+    int tmp;
+
+    pollf.fd = dsp_protocol->fd;
+    pollf.events = POLLIN;
+    while (poll(&pollf, 1, 0) > 0) {
+        if (read(dsp_protocol->fd, &tmp, sizeof(short int)) == 0)
+            /* Test end of file */
+            break;
+    }
+    return ret;
+}
+
+/**
+ * @param dsp_protocol  dsp_protocol_t structure.
+ * @param command command value to be sent to the pcm task node.
+ *
+ * Send the command to pcm task node and checks if
+ * it was sent properly.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+static int dsp_protocol_send_command(dsp_protocol_t *dsp_protocol, const short int command) {
+    dsp_cmd_status_t audio_cmd_status;
+    int ret = 0;
+    short int tmp;
+
+    report_command("Sending", command);
+    tmp = command;
+    if (write(dsp_protocol->fd, &tmp, sizeof(short int)) < 0) {
+        report_dsp_protocol("Could not send", dsp_protocol);
+        ret = -EIO;
+    }
+
+    if (read(dsp_protocol->fd, &audio_cmd_status,
+             sizeof(dsp_cmd_status_t)) < 0) {
+        ret = -1;
+        report_dsp_protocol("Could not receive DSP_CMD_STATUS", dsp_protocol);
+        goto out;
+    }
+    /*    report_command("Received", audio_cmd_status.dsp_cmd);
+          report_return_value("Received",  audio_cmd_status.status);*/
+    pa_log_debug("audio_cmd_status.dsp_cmd: 0x%x\n", audio_cmd_status.dsp_cmd);
+    pa_log_debug("audio_cmd_status.status: 0x%x\n", audio_cmd_status.status);
+    if (audio_cmd_status.status != DSP_OK)
+        ret = -EIO;
+ out:
+    return ret;
+}
+
+/**
+ * @param input 0 - 100 value to be converted to Q15.
+ * @param scale scale value of Q15 format.
+ * @param power2 power of 2 value of Q15 format.
+ *
+ * Converts a 0 - 100 value to a Q15 format value.
+ *
+ */
+static void dsp_protocol_linear2Q15(const unsigned short int input, unsigned short int *scale, unsigned short int *power2) {
+    unsigned long int val = MAGIC_NUMBER * input;
+
+    if (input == 0) {
+        *scale = 0;
+        *power2 = 0;
+    } else {
+        *power2 = 1;
+        while (val < 0x40000000) {
+            (*power2)--;
+            val <<= 1;
+        }
+        *scale = val >> 16;
+    }
+    pa_log_debug("Resulted scale %d and power2 %d from input %d\n", *scale, *power2, input);
+}
+
+/**
+ * @param scale scale value of Q15 format.
+ * @param power2 power of 2 value of Q15 format.
+ * @param output 0 - 100 resulted value.
+ *
+ * Converts a Q15 format value to a 0 - 100 value.
+ *
+ */
+static void dsp_protocol_Q152linear(const unsigned short int scale, const unsigned short int power2, unsigned short int *output) {
+    float result = scale * 1.0 / 0x8000 * pow(2.0, 1.0 * power2) * 100.0;
+
+    *output = (short int)(result);
+    if ((result - *output) > 0.5)
+        (*output)++;
+    pa_log_debug("Resulted linear: %d from scale %d and power2 %d\n", *output,
+		 scale, power2);
+}
+
+/**
+ * @param dsp_protocol  dsp_protocol_t structure.
+ *
+ * Update dsp_protocol_t structure info. Queries dsp task
+ * for a audio_status_info structure.
+ *
+ * @return if success, it returns number of channels whose dsp task is
+ * currently using. otherwise a negative error code.
+ */
+static int dsp_protocol_update_state(dsp_protocol_t *dsp_protocol) {
+    int ret;
+    short int tmp;
+    audio_status_info_t audio_status_info;
+
+
+    if ((ret = dsp_protocol_flush(dsp_protocol)) < 0)
+        goto out;
+    tmp = DSP_CMD_STATE;
+    if (write(dsp_protocol->fd, &tmp, sizeof(short int)) < 0) {
+        ret = -EIO;
+        goto out;
+    }
+    if ((ret = read(dsp_protocol->fd, &audio_status_info, sizeof(audio_status_info_t))) < 0) {
+        report_dsp_protocol("Could not read audio_status_info", dsp_protocol);
+        goto out;
+    }
+    report_audio_status_info("Received:", audio_status_info);
+    dsp_protocol->stream_id = audio_status_info.stream_id;
+    dsp_protocol->bridge_buffer_size = audio_status_info.bridge_buffer_size;
+    dsp_protocol->mmap_buffer_size = audio_status_info.mmap_buffer_size;
+    dsp_protocol->state = audio_status_info.status;
+#ifndef NORMAL_DSP_TASK
+    dsp_protocol->mute = audio_status_info.mute;
+#endif
+    report_dsp_protocol("connection stablished:", dsp_protocol);
+    ret = audio_status_info.number_channels;
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol  dsp_protocol_t structure.
+ *
+ * It produces the semaphore ID and connects to it.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+static inline int dsp_protocol_get_sem(dsp_protocol_t * dsp_protocol) {
+    union semun sem_val; /* semaphore value, for semctl(). */
+
+    int rc;
+    int ret;
+    /* identifier returned by ftok() */
+    key_t set_key;
+
+    /* generate a "unique" key for our set, using the */
+    /* directory "/dev/dsptask/xxxx".      */
+    set_key = ftok(dsp_protocol->device, 0);
+    if (set_key == -1) {
+        pa_log_debug("ftok: %d\n", errno);
+        ret = -ENODEV;
+        goto out;
+    }
+    pa_log_debug("key %d\n", set_key);
+
+    /* now we can use 'set_key' to generate a set id, for example. */
+    dsp_protocol->sem_set_id = semget(set_key, 1, 0666);
+    if (dsp_protocol->sem_set_id == -1) {
+        pa_log_debug("semget %d\n", errno);
+        dsp_protocol->sem_set_id = semget(set_key, 1, IPC_CREAT | 0666);
+        if (dsp_protocol->sem_set_id == -1) {
+            pa_log_debug("semget: IPC_CREAT: %d\n", errno);
+            ret = -ENODEV;
+            goto out;
+        }
+        pa_log_debug("Initialising the semaphore\n");
+        sem_val.val = 1;
+        rc = semctl(dsp_protocol->sem_set_id, 0, SETVAL, sem_val);
+        if (rc == -1) {
+            pa_log_debug("semctl %d\n", errno);
+            ret = -ENODEV;
+            goto out;
+        }
+    }
+    ret = 0;
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol  dsp_protocol_t structure.
+ *
+ * It waits until be able to hold the semaphore to access the dsp task node.
+ * If the current process already has the semaphore, returns success.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+static inline int dsp_protocol_lock_dev(dsp_protocol_t *dsp_protocol) {
+    int ret;
+    struct sembuf sem_op;
+
+    ret = pthread_mutex_trylock(&(dsp_protocol->mutex));
+    if (ret != 0) {
+        pa_log_debug("No lock %d\n", ret);
+        if (errno == EBUSY)
+            ret = 0;
+        goto out;
+    }
+    sem_op.sem_num = 0;
+    sem_op.sem_op = -1;
+    sem_op.sem_flg = 0;
+    pa_log_debug("requesting semaphore (dev)\n");
+    if (semop(dsp_protocol->sem_set_id, &sem_op, 1) == -1) {
+        pa_log_debug("semop %d\n", errno);
+        pthread_mutex_unlock(&(dsp_protocol->mutex));
+        ret = -errno;
+    }
+ out:
+    return ret;
+}
+
+/**
+ * @param dsp_protocol  dsp_protocol_t structure.
+ *
+ * It releases the semaphore.
+ *
+ * @return zero if success, otherwise a negative error code.
+ */
+static inline int dsp_protocol_unlock_dev(dsp_protocol_t *dsp_protocol) {
+    struct sembuf sem_op;
+
+    sem_op.sem_num = 0;
+    sem_op.sem_op = 1;
+    sem_op.sem_flg = 0;
+    pa_log_debug("Releasing\n");
+    semop(dsp_protocol->sem_set_id, &sem_op, 1);
+
+    pthread_mutex_unlock(&(dsp_protocol->mutex));
+    return 0;
+}
+
+
+static int rate_to_dsp_rate(unsigned int *rate) {
+
+    static const unsigned int rate_trans[] = {
+	8000, SAMPLE_RATE_8KHZ,
+	11025, SAMPLE_RATE_11_025KHZ,
+	12000, SAMPLE_RATE_12KHZ,
+	16000, SAMPLE_RATE_16KHZ,
+	22050, SAMPLE_RATE_22_05KHZ,
+	24000, SAMPLE_RATE_24KHZ,
+	32000, SAMPLE_RATE_32KHZ,
+	44100, SAMPLE_RATE_44_1KHZ,
+	48000, SAMPLE_RATE_48KHZ
+    };
+
+    for (unsigned int i = 0; i < PA_ELEMENTSOF(rate_trans); i += 2) {
+	if (*rate <= rate_trans[i]) {
+	    *rate = rate_trans[i];
+	    return rate_trans[i + 1];
+	}
+    }
+
+    return SAMPLE_RATE_48KHZ;
+}
+
+static int format_to_dsp_format(pa_sample_format_t *format) {
+
+    static const int format_trans[] = {
+        [PA_SAMPLE_U8] = DSP_AFMT_U8,
+        [PA_SAMPLE_ALAW] = DSP_AFMT_ALAW,
+        [PA_SAMPLE_ULAW] = DSP_AFMT_ULAW,
+        [PA_SAMPLE_S16LE] = DSP_AFMT_S16_LE,
+        [PA_SAMPLE_S16BE] = DSP_AFMT_S16_BE,
+        [PA_SAMPLE_FLOAT32LE] = DSP_AFMT_S16_LE,
+        [PA_SAMPLE_FLOAT32BE] = DSP_AFMT_S16_LE,
+    };
+
+    for (unsigned int i = 0; i < PA_ELEMENTSOF(format_trans); i += 2) {
+	if (*format == format_trans[i]) {
+	    *format = i;
+	    return format_trans[i];
+	}
+    }
+
+    *format = PA_SAMPLE_S16LE;
+    return DSP_AFMT_S16_LE;
+}
+
+int dsp_protocol_set_params(dsp_protocol_t *dsp_protocol, pa_sample_spec *ss) {
+
+    audio_params_data_t params;
+    pa_sample_format_t format;
+    unsigned int rate, channels;
+
+    rate = ss->rate;
+    format = ss->format;
+
+    channels = ss->channels;
+    channels = CLAMP(channels, 1, 2);
+
+    params.dsp_cmd = DSP_CMD_SET_PARAMS;
+    params.dsp_audio_fmt = format_to_dsp_format(&format);
+    params.sample_rate = rate_to_dsp_rate(&rate);;
+    params.number_channels = channels;
+    params.ds_stream_id = 0;
+    params.stream_priority = 0;
+
+    if (dsp_protocol_send_audio_params(dsp_protocol, &params) < 0) {
+      pa_log("Failed to set DSP audio parameters");
+      return -1;
+    }
+
+    if (ss->rate != rate) {
+      pa_log_warn("maemo DSP doesn't support %u Hz, changed to %u Hz.", ss->rate, rate);
+
+      /* FIXME?: If the sample rate deviates too much, we need to resample */
+      if (rate < ss->rate*.95 || rate > ss->rate*1.05)
+	ss->rate = rate;
+    }
+
+    if (ss->channels != channels) {
+      pa_log_warn("maemo DSP doesn't support %u channels, changed to %u.", ss->channels, channels);
+      ss->channels = channels;
+    }
+
+    if (ss->format != format) {
+      pa_log_warn("maemo DSP doesn't support sample format %s, changed to %s.", pa_sample_format_to_string(ss->format), pa_sample_format_to_string(format));
+      ss->format = format;
+    }
+
+    return 0;
+}
diff --git a/src/modules/maemo-dsp-util.h b/src/modules/maemo-dsp-util.h
new file mode 100644
index 0000000..29bad18
--- /dev/null
+++ b/src/modules/maemo-dsp-util.h
@@ -0,0 +1,263 @@
+#ifndef foomaemodsputilfoo
+#define foomaemodsputilfoo
+
+/* $Id$ */
+
+/***
+    Definition of functions whose represents an interface to the DSP
+    PCM Task node protocol.
+
+    Copyright (C) 2006, 2008 Nokia Corporation
+    Author: Marc-Andre Lureau <marc-andre.lureau@nokia.com>
+    Based on ALSA plugin by Eduardo Bezerra Valentin <eduardo.valentin@indt.org.br>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the
+    Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+    Boston, MA 02111-1307, USA.
+***/
+
+#include <features.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <pulse/sample.h>
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+typedef struct {
+    int fd;
+    char *device;
+    int state;
+    int mute;
+    unsigned int stream_id;
+    unsigned int bridge_buffer_size; /* in bytes */
+    unsigned int mmap_buffer_size; /* in bytes */
+    short int *mmap_buffer;
+    pthread_mutex_t mutex;
+    int sem_set_id;
+} dsp_protocol_t;
+
+typedef struct {
+    unsigned short dsp_cmd;
+    unsigned short init_status;
+    unsigned short stream_id;
+    unsigned short bridge_buffer_size;
+    unsigned short mmap_buffer_size;
+} audio_init_status_t;
+
+typedef struct {
+    unsigned short dsp_cmd;
+    unsigned short dsp_audio_fmt;
+    unsigned short sample_rate;
+    unsigned short number_channels;
+    unsigned short ds_stream_id;
+    unsigned short stream_priority;
+} audio_params_data_t;
+
+typedef struct {
+    unsigned short dsp_cmd; //DSP_CMD_SET_SPEECH_PARAMS
+    unsigned short audio_fmt;       //S16_LE,ALAW,ULAW,ILBC
+    unsigned short sample_rate;
+    unsigned short ds_stream_id;    //Stream ID from EAP mixer
+    unsigned short stream_priority; //N/A
+    unsigned short frame_size;
+} speech_params_data_t;
+
+typedef struct {
+    unsigned short dsp_cmd;
+    unsigned short stream_id;
+    unsigned short ds_stream_id;
+    unsigned short bridge_buffer_size;
+    unsigned short mmap_buffer_size;
+    unsigned short status;
+    unsigned int num_frames;
+    unsigned short sample_rate;
+    unsigned short number_channels;
+    unsigned short vol_scale;
+    unsigned short vol_power2;
+    unsigned short left_gain;
+    unsigned short right_gain;
+    unsigned short dsp_audio_fmt;
+#ifndef NORMAL_DSP_TASK
+    unsigned short mute;
+    unsigned long int samples_played_high;
+    unsigned long int samples_played_low;
+#endif
+} audio_status_info_t;
+
+typedef struct {
+    unsigned short int dsp_cmd;
+    unsigned short int status;
+} dsp_cmd_status_t;
+
+/* data write status structure */
+typedef struct {
+    unsigned short int dsp_cmd;
+    unsigned short int status;
+    unsigned short int buffer_bytes_free;
+} write_status_t;
+
+typedef struct {
+    unsigned short dsp_cmd;
+    unsigned short data_size;
+} data_write_t;
+
+typedef struct {
+    unsigned short int dsp_cmd;
+    unsigned short int status;
+    unsigned short int frame_size;
+    unsigned int stream_time_ms;
+} read_status_t;
+
+/* get time data structure */
+typedef struct {
+    unsigned short int dsp_cmd;
+    unsigned short int status;
+    unsigned short int stream_ID;
+    long int time_ms;
+} time_data_t;
+
+/* general stream command data structure */
+typedef struct {
+    unsigned short int dsp_cmd;
+    unsigned short int stream_ID;
+} stream_cmd_data_t;
+
+typedef struct {
+    unsigned short dsp_cmd;
+    unsigned short scale;
+    unsigned short power2;
+} volume_data_t;
+
+typedef struct {
+    unsigned short dsp_cmd;
+    unsigned short left_gain;
+    unsigned short right_gain;
+    unsigned short steps;
+} panning_data_t;
+
+/**
+ * Audio formats
+ * */
+/** Unsigned 8 bits per sample PCM */
+#define DSP_AFMT_U8             0x01
+/** Signed 16 bits per sample PCM, little endian */
+#define DSP_AFMT_S16_LE         0x02
+/** Signed 16 bits per sample PCM, big endian */
+#define DSP_AFMT_S16_BE         0x03
+/** Signed 8 bits per sample PCM */
+#define DSP_AFMT_S8             0x04
+/** Unsigned 16 bits per sample PCM, little endian */
+#define DSP_AFMT_U16_LE         0x05
+/** Unsigned 16 bits per sample PCM, big endian */
+#define DSP_AFMT_U16_BE         0x06
+/** A-law encoded PCM */
+#define DSP_AFMT_ALAW           0x07
+/** μ-Law encoded PCM */
+#define DSP_AFMT_ULAW           0x08
+/** MP3 stream */
+#define DSP_AFMT_MP3            0x09
+/** AAC stream */
+#define DSP_AFMT_AAC            0x0A
+/** AMR stream */
+#define DSP_AFMT_AMR            0x0B
+/** MP2 stream */
+#define DSP_AFMT_MP2            0x0C
+/** iLBC stream */
+#define DSP_AFMT_ILBC           0x0D
+/** G.729 stream */
+#define DSP_AFMT_G729           0x0E
+
+/**
+ * Supported Sample rates
+ * */
+/** 96KHz sampling rate */
+#define SAMPLE_RATE_96KHZ       0x00
+/** 88.2KHz sampling rate */
+#define SAMPLE_RATE_88_2KHZ     0x01
+/** 64KHz sampling rate */
+#define SAMPLE_RATE_64KHZ       0x02
+/** 48KHz sampling rate */
+#define SAMPLE_RATE_48KHZ       0x03
+/** 44.1KHz sampling rate */
+#define SAMPLE_RATE_44_1KHZ     0x04
+/** 32KHz sampling rate */
+#define SAMPLE_RATE_32KHZ       0x05
+/** 24KHz sampling rate */
+#define SAMPLE_RATE_24KHZ       0x06
+/** 22.05KHz sampling rate */
+#define SAMPLE_RATE_22_05KHZ    0x07
+/** 16KHz sampling rate */
+#define SAMPLE_RATE_16KHZ       0x08
+/** 12KHz sampling rate */
+#define SAMPLE_RATE_12KHZ       0x09
+/** 11.025KHz sampling rate */
+#define SAMPLE_RATE_11_025KHZ   0x0A
+/** 8KHz sampling rate */
+#define SAMPLE_RATE_8KHZ        0x0B
+/** 5.5125Khz sampling rate */
+#define SAMPLE_RATE_5_5125KHZ   0X0C
+
+/**
+ * Audio Task node states
+ * */
+/** Initialised */
+#define STATE_INITIALISED       0x00
+/** Playing/recording */
+#define STATE_PLAYING           0x01
+/** Stopped */
+#define STATE_STOPPED           0x02
+/** Paused */
+#define STATE_PAUSED            0x03
+/** Not initialised */
+#define STATE_UNINITIALISED     0x04
+/** Reseted */
+#define STATE_RESET             0x05
+/** Muted */
+#define STATE_MUTED             0x06
+
+/* Initialisation */
+int dsp_protocol_create(dsp_protocol_t **dsp_protocol);
+int dsp_protocol_open_node(dsp_protocol_t *dsp_protocol, const char *device);
+int dsp_protocol_send_audio_params(dsp_protocol_t *dsp_protocol, audio_params_data_t *audio_params_data);
+int dsp_protocol_send_speech_params(dsp_protocol_t *dsp_protocol, speech_params_data_t *audio_params_data);
+int dsp_protocol_set_params(dsp_protocol_t *dsp_protocol, pa_sample_spec *ss);
+
+/* Execution */
+int dsp_protocol_send_play(dsp_protocol_t *dsp_protocol);
+int dsp_protocol_send_audio_data(dsp_protocol_t *dsp_protocol, void *data, unsigned short int count);
+int dsp_protocol_receive_audio_data(dsp_protocol_t *dsp_protocol, void *data, int count);
+
+int dsp_protocol_send_pause(dsp_protocol_t *dsp_protocol);
+int dsp_protocol_send_stop(dsp_protocol_t *dsp_protocol);
+
+/* Deletion */
+int dsp_protocol_close_node(dsp_protocol_t *dsp_protocol);
+int dsp_protocol_destroy(dsp_protocol_t **dsp_protocol);
+
+/* controls */
+int dsp_protocol_set_volume(dsp_protocol_t *dsp_protocol,
+                            unsigned char left, unsigned char right);
+int dsp_protocol_get_volume(dsp_protocol_t *dsp_protocol,
+                            unsigned char *left, unsigned char *right);
+int dsp_protocol_set_mute(dsp_protocol_t *dsp_protocol, unsigned char mute);
+int dsp_protocol_get_mute(dsp_protocol_t *dsp_protocol);
+
+/* misc */
+int dsp_protocol_set_mic_enabled(dsp_protocol_t *dsp_protocol, int enabled);
+int dsp_protocol_probe_node(dsp_protocol_t *dsp_protocol, const char *device);
+int safe_strtol(const char *str, long *val);
+
+#endif
diff --git a/src/modules/module-maemo-dsp-sink-symdef.h b/src/modules/module-maemo-dsp-sink-symdef.h
new file mode 100644
index 0000000..b2c71c9
--- /dev/null
+++ b/src/modules/module-maemo-dsp-sink-symdef.h
@@ -0,0 +1,25 @@
+#ifndef foomodulemaemodspsinksymdeffoo
+#define foomodulemaemodspsinksymdeffoo
+
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/macro.h>
+
+#define pa__init module_maemo_dsp_sink_LTX_pa__init
+#define pa__done module_maemo_dsp_sink_LTX_pa__done
+#define pa__get_author module_maemo_dsp_sink_LTX_pa__get_author
+#define pa__get_description module_maemo_dsp_sink_LTX_pa__get_description
+#define pa__get_usage module_maemo_dsp_sink_LTX_pa__get_usage
+#define pa__get_version module_maemo_dsp_sink_LTX_pa__get_version
+#define pa__load_once module_maemo_dsp_sink_LTX_pa__load_once
+
+int pa__init(pa_module*m);
+void pa__done(pa_module*m);
+
+const char* pa__get_author(void);
+const char* pa__get_description(void);
+const char* pa__get_usage(void);
+const char* pa__get_version(void);
+pa_bool_t pa__load_once(void);
+
+#endif
diff --git a/src/modules/module-maemo-dsp-sink.c b/src/modules/module-maemo-dsp-sink.c
new file mode 100644
index 0000000..f322301
--- /dev/null
+++ b/src/modules/module-maemo-dsp-sink.c
@@ -0,0 +1,413 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright 2004-2007 Lennart Poettering
+  Copyright 2004-2007 Nokia
+
+  Author: Marc-Andre Lureau
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published
+  by the Free Software Foundation; either version 2 of the License,
+  or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with PulseAudio; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <poll.h>
+
+#include <pulse/xmalloc.h>
+
+#include <pulsecore/core-error.h>
+#include <pulsecore/sink.h>
+#include <pulsecore/module.h>
+#include <pulsecore/core-util.h>
+#include <pulsecore/modargs.h>
+#include <pulsecore/log.h>
+#include <pulsecore/thread.h>
+#include <pulsecore/thread-mq.h>
+#include <pulsecore/rtpoll.h>
+#include <pulsecore/macro.h>
+
+#include "maemo-dsp-util.h"
+
+#include "module-maemo-dsp-sink-symdef.h"
+
+PA_MODULE_AUTHOR("Marc-Andre Lureau");
+PA_MODULE_DESCRIPTION("Maemo DSP sink");
+PA_MODULE_VERSION(PACKAGE_VERSION);
+PA_MODULE_LOAD_ONCE(FALSE);
+PA_MODULE_USAGE(
+        "sink_name=<name for the sink> "
+        "file=<path of the playback task device> "
+        "format=<sample format> "
+        "channels=<number of channels> "
+        "rate=<sample rate>");
+
+#define DEFAULT_FILE_NAME "/dev/dsptask/pcm3"
+#define DEFAULT_SINK_NAME "maemo_dsp_output"
+
+struct userdata {
+    pa_core *core;
+    pa_module *module;
+    pa_sink *sink;
+
+    pa_thread *thread;
+    pa_thread_mq thread_mq;
+    pa_rtpoll *rtpoll;
+
+    dsp_protocol_t *dsp_protocol;
+    char *filename;
+
+    pa_memchunk memchunk;
+
+    pa_rtpoll_item *rtpoll_item;
+};
+
+static const char* const valid_modargs[] = {
+    "sink_name",
+    "file",
+    "format",
+    "channels",
+    "rate",
+    NULL
+};
+
+static int suspend(struct userdata *u) {
+    pa_assert(u);
+
+    if (u->dsp_protocol->state == STATE_PLAYING) {
+	dsp_protocol_send_stop(u->dsp_protocol);
+    }
+
+    if (u->dsp_protocol->state >= STATE_INITIALISED) {
+	dsp_protocol_close_node(u->dsp_protocol);
+    }
+
+    pa_log_info("Device suspended...");
+
+    return 0;
+}
+
+static int unsuspend(struct userdata *u) {
+
+    pa_sample_spec *ss;
+
+    pa_assert(u);
+    pa_assert(u->sink);
+
+    ss = &u->sink->sample_spec;
+
+    if (u->dsp_protocol->state == STATE_UNINITIALISED) {
+	if (dsp_protocol_open_node(u->dsp_protocol, u->filename) < 0) {
+	    pa_log("dsp_protocol_open_node('%s'): not available", u->filename);
+	    goto fail;
+	}
+
+	/* FIXME:	pa_fd_set_cloexec(u->dsp_protocol->fd, 1); */
+
+	if (dsp_protocol_set_params(u->dsp_protocol, ss) < 0) {
+	    pa_log("dsp_protocol_set_params() error");
+	    goto fail;
+	}
+    }
+
+    pa_log_info("Resumed successfully...");
+
+    return 0;
+
+ fail:
+    suspend(u);
+    return -1;
+}
+
+static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offset, pa_memchunk *chunk) {
+    struct userdata *u = PA_SINK(o)->userdata;
+
+    switch (code) {
+
+        case PA_SINK_MESSAGE_GET_LATENCY: {
+            *((pa_usec_t*) data) = 0; /* FIXME pa_bytes_to_usec(n, &u->sink->sample_spec); */
+            break;
+        }
+
+        case PA_SINK_MESSAGE_SET_STATE:
+
+            switch ((pa_sink_state_t) PA_PTR_TO_UINT(data)) {
+
+                case PA_SINK_SUSPENDED:
+                    pa_assert(PA_SINK_OPENED(u->sink->thread_info.state));
+
+                    if (suspend(u) < 0)
+                        return -1;
+
+                    break;
+
+                case PA_SINK_IDLE:
+                case PA_SINK_RUNNING:
+
+                    if (u->sink->thread_info.state == PA_SINK_SUSPENDED) {
+                        if (unsuspend(u) < 0)
+                            return -1;
+                    }
+
+                    break;
+
+                case PA_SINK_UNLINKED:
+                case PA_SINK_INIT:
+                    ;
+            }
+
+            break;
+    }
+
+    return pa_sink_process_msg(o, code, data, offset, chunk);
+}
+
+static void thread_func(void *userdata) {
+    struct userdata *u = userdata;
+
+    pa_assert(u);
+
+    pa_log_debug("Thread starting up");
+
+    pa_thread_mq_install(&u->thread_mq);
+    pa_rtpoll_install(u->rtpoll);
+
+    for (;;) {
+        int ret;
+        struct pollfd *pollfd;
+
+        pollfd = pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL);
+
+        /* Render some data and write it to the fifo */
+        if (u->sink->thread_info.state == PA_SINK_RUNNING && pollfd->revents) {
+            ssize_t l;
+            void *p;
+
+            if (u->memchunk.length <= 0)
+                pa_sink_render(u->sink, PIPE_BUF, &u->memchunk);
+
+            pa_assert(u->memchunk.length > 0);
+
+	    if (u->dsp_protocol->state != STATE_PLAYING) {
+		if (dsp_protocol_send_play(u->dsp_protocol) < 0) {
+		    pa_log("dsp_protocol_send_play() error");
+		    goto fail;
+		}
+	    }
+
+            p = pa_memblock_acquire(u->memchunk.memblock);
+	    l = dsp_protocol_send_audio_data(u->dsp_protocol,
+					     (uint8_t*) p + u->memchunk.index,
+					     u->memchunk.length / 2);
+	    l *= 2;
+            pa_memblock_release(u->memchunk.memblock);
+
+            pa_assert(l != 0);
+
+            if (l < 0) {
+
+                if (errno == EINTR)
+                    continue;
+                else if (errno != EAGAIN) {
+                    pa_log("Failed to write data to FIFO: %s", pa_cstrerror(errno));
+                    goto fail;
+                }
+
+            } else {
+
+                u->memchunk.index += l;
+                u->memchunk.length -= l;
+
+                if (u->memchunk.length <= 0) {
+                    pa_memblock_unref(u->memchunk.memblock);
+                    pa_memchunk_reset(&u->memchunk);
+                }
+
+                pollfd->revents = 0;
+            }
+        }
+
+        /* Hmm, nothing to do. Let's sleep */
+        pollfd->events = u->sink->thread_info.state == PA_SINK_RUNNING ? POLLOUT : 0;
+
+        if ((ret = pa_rtpoll_run(u->rtpoll, TRUE)) < 0)
+            goto fail;
+
+        if (ret == 0)
+            goto finish;
+
+        pollfd = pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL);
+
+        if (pollfd->revents & ~POLLOUT) {
+            pa_log("FIFO shutdown.");
+            goto fail;
+        }
+    }
+
+fail:
+    /* If this was no regular exit from the loop we have to continue
+     * processing messages until we received PA_MESSAGE_SHUTDOWN */
+    pa_asyncmsgq_post(u->thread_mq.outq, PA_MSGOBJECT(u->core), PA_CORE_MESSAGE_UNLOAD_MODULE, u->module, 0, NULL, NULL);
+    pa_asyncmsgq_wait_for(u->thread_mq.inq, PA_MESSAGE_SHUTDOWN);
+
+finish:
+    pa_log_debug("Thread shutting down");
+}
+
+int pa__init(pa_module*m) {
+    struct userdata *u;
+    pa_sample_spec ss;
+    pa_channel_map map;
+    pa_modargs *ma;
+    char *t;
+    struct pollfd *pollfd;
+
+    pa_assert(m);
+
+    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+        pa_log("Failed to parse module arguments.");
+        goto fail;
+    }
+
+    ss = m->core->default_sample_spec;
+    if (pa_modargs_get_sample_spec_and_channel_map(ma, &ss, &map, PA_CHANNEL_MAP_DEFAULT) < 0) {
+        pa_log("Invalid sample format specification or channel map");
+        goto fail;
+    }
+
+    u = pa_xnew0(struct userdata, 1);
+    u->core = m->core;
+    u->module = m;
+    m->userdata = u;
+    pa_memchunk_reset(&u->memchunk);
+    pa_thread_mq_init(&u->thread_mq, m->core->mainloop);
+    u->rtpoll = pa_rtpoll_new();
+    pa_rtpoll_item_new_asyncmsgq(u->rtpoll, PA_RTPOLL_EARLY, u->thread_mq.inq);
+
+    u->filename = pa_xstrdup(pa_modargs_get_value(ma, "file", DEFAULT_FILE_NAME));
+
+    if (dsp_protocol_create(&(u->dsp_protocol)) < 0) {
+        pa_log("dsp_protocol_create(): error");
+        goto fail;
+    }
+
+    if (!(u->sink = pa_sink_new(m->core, __FILE__, pa_modargs_get_value(ma, "sink_name", DEFAULT_SINK_NAME), 0, &ss, &map))) {
+        pa_log("Failed to create sink.");
+        goto fail;
+    }
+
+    if (unsuspend(u) < 0) {
+	pa_log("Failed to start DSP pcm task");
+	goto fail;
+    }
+
+    u->sink->parent.process_msg = sink_process_msg;
+    u->sink->userdata = u;
+    u->sink->flags = PA_SINK_LATENCY;
+
+    pa_sink_set_module(u->sink, m);
+    pa_sink_set_asyncmsgq(u->sink, u->thread_mq.inq);
+    pa_sink_set_rtpoll(u->sink, u->rtpoll);
+    pa_sink_set_description(u->sink, t = pa_sprintf_malloc("maemo DSP sink '%s'", u->filename));
+    pa_xfree(t);
+
+    u->rtpoll_item = pa_rtpoll_item_new(u->rtpoll, PA_RTPOLL_NEVER, 1);
+    pollfd = pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL);
+    pollfd->fd = u->dsp_protocol->fd;
+    pollfd->events = pollfd->revents = 0;
+
+    if (!(u->thread = pa_thread_new(thread_func, u))) {
+        pa_log("Failed to create thread.");
+        goto fail;
+    }
+
+    pa_sink_put(u->sink);
+
+    pa_modargs_free(ma);
+
+    return 0;
+
+fail:
+    if (u->sink && PA_SINK_LINKED(u->sink->state))
+        pa_sink_unlink(u->sink);
+
+    if (u->sink)
+        pa_sink_unref(u->sink);
+
+    if (ma)
+        pa_modargs_free(ma);
+
+    pa__done(m);
+
+    return -1;
+}
+
+void pa__done(pa_module*m) {
+    struct userdata *u;
+
+    pa_assert(m);
+
+    if (!(u = m->userdata))
+        return;
+
+    if (u->sink && PA_SINK_LINKED(u->sink->state))
+        pa_sink_unlink(u->sink);
+
+    if (u->thread) {
+        pa_asyncmsgq_send(u->thread_mq.inq, NULL, PA_MESSAGE_SHUTDOWN, NULL, 0, NULL);
+        pa_thread_free(u->thread);
+    }
+
+    pa_thread_mq_done(&u->thread_mq);
+
+    if (u->sink)
+        pa_sink_unref(u->sink);
+
+    if (u->memchunk.memblock)
+       pa_memblock_unref(u->memchunk.memblock);
+
+    if (u->rtpoll_item)
+        pa_rtpoll_item_free(u->rtpoll_item);
+
+    if (u->rtpoll)
+        pa_rtpoll_free(u->rtpoll);
+
+    if (u->filename) {
+        unlink(u->filename);
+        pa_xfree(u->filename);
+    }
+
+    if (u->dsp_protocol) {
+        dsp_protocol_close_node(u->dsp_protocol);
+	if (u->dsp_protocol->fd > 0) {
+	    close(u->dsp_protocol->fd);
+	    u->dsp_protocol->fd = 0;
+	}
+        dsp_protocol_destroy(&(u->dsp_protocol));
+    }
+
+    pa_xfree(u);
+}
-- 
1.6.0.2.514.g23abd3

