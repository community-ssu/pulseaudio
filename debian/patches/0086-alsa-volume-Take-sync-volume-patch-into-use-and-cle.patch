From b73977178c1441bcb415a8e53c7981a171b8e1a2 Mon Sep 17 00:00:00 2001
From: Jyri Sarha <jyri.sarha@nokia.com>
Date: Mon, 20 Jul 2009 11:50:17 +0300
Subject: [PATCH] alsa-volume: Take sync volume patch into use and clean up.

---
 src/modules/alsa/module-alsa-sink-volume.c |  848 +++++++++++++++-------------
 1 files changed, 457 insertions(+), 391 deletions(-)

diff --git a/src/modules/alsa/module-alsa-sink-volume.c b/src/modules/alsa/module-alsa-sink-volume.c
index bad9a18..3ad8e62 100644
--- a/src/modules/alsa/module-alsa-sink-volume.c
+++ b/src/modules/alsa/module-alsa-sink-volume.c
@@ -52,6 +52,8 @@
 #include <pulsecore/rtpoll.h>
 #include <pulsecore/atomic.h>
 #include <pulsecore/namereg.h>
+#include <pulsecore/semaphore.h>
+#include <pulsecore/mutex.h>
 #include <pulse/rtclock.h>
 
 #include "alsa-util.h"
@@ -152,6 +154,7 @@ typedef struct mixer_control_t {
     long hw_dB_max, hw_dB_min;
     pa_bool_t hw_dB_supported;
     pa_bool_t mixer_separate_channels;
+    pa_bool_t has_hw_mute;
 
     pa_cvolume hardware_volume;
 
@@ -188,6 +191,7 @@ struct userdata {
     pa_sink_flags_t original_flags;
     void (*original_get_volume)(pa_sink *s);
     void (*original_set_volume)(pa_sink *s);
+    void (*original_write_volume)(pa_sink *s);
     void (*original_get_mute)(pa_sink *s);
     void (*original_set_mute)(pa_sink *s);
 
@@ -201,7 +205,12 @@ struct userdata {
 
     pa_bool_t sw_vol_compensation;
 
-    pa_bool_t mixers_initialized;
+    struct mixer_lock {
+        pa_mutex *mutex;
+        pa_semaphore *reinitialize;
+        pa_atomic_t mixer_initialized;
+        pa_atomic_t usecount;
+    } lock;
 
     /* current audio mode */
     char *audio_mode;
@@ -216,13 +225,74 @@ struct userdata {
 
 static struct userdata *global_userdata = NULL;
 
-static void replace_chars(char *str, const char c, const char new_c) {
-    int ii = -1;
-    pa_assert(str);
-    while(str[++ii] != '\0') {
-        if (str[ii] == c)
-            str[ii] = new_c;
+static void init_mixer_lock(struct mixer_lock *lock) {
+    pa_assert(lock);
+    lock->mutex = pa_mutex_new(FALSE, FALSE);
+    lock->reinitialize = pa_semaphore_new(0);
+    pa_atomic_store(&lock->mixer_initialized, TRUE);
+    pa_atomic_store(&lock->usecount, 0);
+}
+
+static void free_mixer_lock(struct mixer_lock *lock) {
+    pa_assert(lock);
+    pa_mutex_free(lock->mutex);
+    pa_semaphore_free(lock->reinitialize);
+}
+
+/* Multi thread and multiple call safe */
+static pa_bool_t enter_callback(struct userdata *u) {
+    struct mixer_lock *lock = &u->lock;
+    pa_assert(u);
+    pa_mutex_lock(lock->mutex);
+    if (!pa_atomic_load(&lock->mixer_initialized)) {
+        pa_mutex_unlock(lock->mutex);
+        pa_log_debug("Mixer was not initalized");
+        return FALSE;
+    }
+    pa_atomic_store(&lock->usecount, pa_atomic_load(&lock->usecount)+1);
+    pa_mutex_unlock(lock->mutex);
+    return TRUE;
+}
+
+static void leave_callback(struct userdata *u) {
+    struct mixer_lock *lock = &u->lock;
+    int usecount;
+    pa_assert(u);
+    pa_mutex_lock(lock->mutex);
+    usecount = pa_atomic_load(&lock->usecount)-1;
+    pa_assert(usecount >= 0);
+    pa_atomic_store(&lock->usecount, usecount);
+    if (usecount == 0 && !pa_atomic_load(&lock->mixer_initialized)) {
+        pa_log_debug("Let the reinitializaion start");
+        pa_semaphore_post(lock->reinitialize);
+        pa_assert(0 == pa_atomic_load(&lock->usecount));
     }
+    pa_mutex_unlock(lock->mutex);
+}
+
+/* Can only hadle one caller */
+static void enter_initialization(struct userdata *u) {
+    struct mixer_lock *lock = &u->lock;
+    int usecount;
+    pa_assert(u);
+    pa_mutex_lock(lock->mutex);
+    pa_atomic_store(&lock->mixer_initialized, FALSE);
+    usecount = pa_atomic_load(&lock->usecount);
+    pa_mutex_unlock(lock->mutex);
+    if (usecount > 0) {
+        pa_log_debug("Waiting for all callback to exit");
+        pa_semaphore_wait(lock->reinitialize);
+        pa_log_debug("Continue with the initialization");
+    }
+}
+
+static void leave_initialization(struct userdata *u) {
+    struct mixer_lock *lock = &u->lock;
+    pa_assert(u);
+    pa_mutex_lock(lock->mutex);
+    pa_atomic_store(&lock->mixer_initialized, TRUE);
+    pa_assert(0 == pa_atomic_load(&lock->usecount));
+    pa_mutex_unlock(lock->mutex);
 }
 
 static int mixer_callback(snd_mixer_elem_t *elem, unsigned int mask) {
@@ -231,8 +301,6 @@ static int mixer_callback(snd_mixer_elem_t *elem, unsigned int mask) {
     pa_assert(u);
     pa_assert(u->mixer_handle);
 
-
-
     if (mask == SND_CTL_EVENT_MASK_REMOVE)
         return 0;
 
@@ -289,44 +357,6 @@ static long hw_mixer_to_mB_value(mixer_control_t *m, const int table, long hw_vo
     return m->tuning_data[table].tuning_table[hw_vol - m->tuning_data[table].tuned_volume_min];
 }
 
-static void fill_tuning_table_range(struct mixer_control_t *m, const int table, size_t start, size_t end,
-                                   long mBstart, long mBend) {
-    double mB_step;
-    int i;
-    pa_assert(m);
-    pa_assert(end > start);
-    mB_step  = (double)(mBend-mBstart)/(double)(end-start);
-
-    for (i = 0; i <= (int)(end - start); i++)
-        m->tuning_data[table].tuning_table[start + i] = lrint((double)mBstart + mB_step*i);
-}
-
-#ifdef DEBUG_VOLUME
-static void print_tuning_table(struct mixer_control_t *m, const int table) {
-    int i;
-    pa_assert(m);
-    pa_assert(m->tuning_data[table].tuning_table);
-
-    for(i=0; i<= m->tuning_data[table].tuning_table_max; i++)
-        pa_log_debug("%ld:%ld", i+m->tuning_data[table].tuned_volume_min, m->tuning_data[table].tuning_table[i]);
-}
-#endif
-
-static void fill_tuning_table_from_dB_info(struct mixer_control_t *m, const int table) {
-    tuning_data_t *td = &m->tuning_data[table];
-    pa_assert(m);
-    pa_assert(td->tuning_table);
-
-    td->tuned_volume_min = m->hw_volume_min;
-    td->tuned_volume_max = m->hw_volume_max;
-    td->tuning_table_max = td->tuning_table_allocated_length-1;
-    fill_tuning_table_range(m, table, 0, td->tuning_table_max, m->hw_dB_min - m->hw_dB_max, 0);
-    td->tuning_table_filled  = TRUE;
-}
-
-static int load_mixer_tuning(struct userdata *u, struct mixer_control_t *m, const int tuning_mode);
-static void fill_mixer_tuning(struct userdata *u, struct mixer_control_t *m, const int table);
-
 static void sink_get_volume_cb(pa_sink *s) {
     struct userdata *u = global_userdata;
     struct mixer_control_t *m = NULL;
@@ -336,6 +366,8 @@ static void sink_get_volume_cb(pa_sink *s) {
     const int active_tuning = u->active_tuning;
 
     pa_assert(u);
+    if (!enter_callback(u))
+        return;
     pa_assert(u->active_mixer);
     pa_assert(u->active_mixer->mixer_elem);
 
@@ -345,19 +377,12 @@ static void sink_get_volume_cb(pa_sink *s) {
     }
 
     if (s != u->sink) {
-        pa_log_debug("This in not my sink, what to do?");
+        pa_log_error("This in not my sink, what to do?");
+        return;
     }
 
     m = u->active_mixer;
 
-    if (!m->tuning_data[active_tuning].tuning_table_filled) {
-        load_mixer_tuning(u, m, active_tuning);
-        if (!m->tuning_data[active_tuning].tuning_table_filled) {
-            pa_log_info("No tuning table %d filled for %s mixer", active_tuning, m->name);
-            fill_mixer_tuning(u, m, active_tuning);
-        }
-    }
-
     if (m->mixer_separate_channels) {
 
         r.channels = u->sink->sample_spec.channels;
@@ -412,13 +437,14 @@ static void sink_get_volume_cb(pa_sink *s) {
 
         /* Hmm, so the hardware volume changed, let's reset our software volume */
         pa_cvolume_reset(&reset, u->sink->sample_spec.channels);
-        pa_sink_set_soft_volume(s, &reset);
     }
 
+    leave_callback(u);
     return;
 
  fail:
     pa_log_error("Unable to read volume: %s", snd_strerror(err));
+    leave_callback(u);
 }
 
 static pa_volume_t calculate_alsa_mixer_value(struct mixer_control_t *m, const int table, pa_volume_t pa_vol, long *hw_vol) {
@@ -439,10 +465,9 @@ static pa_volume_t calculate_alsa_mixer_value(struct mixer_control_t *m, const i
     return real_pa_vol;
 }
 
-
-static int set_alsa_mixer_volumes(struct userdata *u,
-                                  struct mixer_control_t *m,
-                                  pa_cvolume *vv) {
+static int write_alsa_mixer_volumes(struct userdata *u,
+                                    struct mixer_control_t *m,
+                                    pa_cvolume *vv)  {
     int err;
     unsigned i;
     pa_cvolume r;
@@ -468,7 +493,7 @@ static int set_alsa_mixer_volumes(struct userdata *u,
 
             if ((err = snd_mixer_selem_set_playback_volume(m->mixer_elem, m->mixer_map[i], hw_vol)) < 0)
                 goto fail;
-#if 1            /* Maybe I could check alsa mixer value once more ... */
+#if 1       /* Maybe I could check alsa mixer value once more ... */
             if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, m->mixer_map[i], &real_hw_vol)) < 0)
                 goto fail;
 
@@ -487,11 +512,10 @@ static int set_alsa_mixer_volumes(struct userdata *u,
         long hw_vol, real_hw_vol;
         pa_volume_t real_pa_vol = calculate_alsa_mixer_value(m, active_tuning, pa_cvolume_max(vv), &hw_vol);
 
-
         if ((err = snd_mixer_selem_set_playback_volume_all(m->mixer_elem, hw_vol)) < 0)
             goto fail;
 
-#if 1            /* Maybe I could check alsa mixer value once more ... */
+#if 1   /* Maybe I could check alsa mixer value once more ... */
         if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, SND_MIXER_SCHN_MONO, &real_hw_vol)) < 0)
             goto fail;
 
@@ -507,6 +531,48 @@ static int set_alsa_mixer_volumes(struct userdata *u,
         pa_cvolume_set(&r, u->sink->sample_spec.channels, real_pa_vol);
     }
 
+    return 0;
+
+ fail:
+    pa_log_error("Unable to set volume: %s", snd_strerror(err));
+
+    return 1;
+}
+
+static int set_alsa_mixer_volumes(struct userdata *u,
+                                  struct mixer_control_t *m,
+                                  pa_cvolume *vv) {
+    unsigned i;
+    pa_cvolume r;
+#ifdef SPAM_ALSA_SINK_VOLUME
+    char t[PA_CVOLUME_SNPRINT_MAX];
+#endif
+
+    tuning_data_t *td = &m->tuning_data[u->active_tuning];
+    const int active_tuning = u->active_tuning;
+
+    pa_assert(u);
+    pa_assert(m->mixer_elem);
+    pa_assert(td->tuning_table);
+    pa_assert(td->tuning_table_filled);
+
+    if (m->mixer_separate_channels) {
+
+        r.channels = u->sink->sample_spec.channels;
+
+        for (i = 0; i < u->sink->sample_spec.channels; i++) {
+            long hw_vol;
+            pa_volume_t real_pa_vol = calculate_alsa_mixer_value(m, active_tuning, vv->values[i], &hw_vol);
+
+            r.values[i] = real_pa_vol;
+        }
+    } else {
+        long hw_vol;
+        pa_volume_t real_pa_vol = calculate_alsa_mixer_value(m, active_tuning, pa_cvolume_max(vv), &hw_vol);
+
+        pa_cvolume_set(&r, u->sink->sample_spec.channels, real_pa_vol);
+    }
+
     m->hardware_volume = r;
 
     log_spam("Requested volume: %s", pa_cvolume_snprint(t, sizeof(t), vv));
@@ -524,163 +590,75 @@ static int set_alsa_mixer_volumes(struct userdata *u,
     }
 
     return 0;
-
- fail:
-    pa_log_error("Unable to set volume: %s", snd_strerror(err));
-
-    return 1;
 }
 
-static void set_alsa_mixer_volume_timer_cb(pa_mainloop_api *a, pa_time_event *e, pa_usec_t usec, void *userdata) {
-    struct userdata *u = (struct userdata *)userdata;
-
-    u->core->mainloop->time_free(e);
-    u->delayed_mixer_ctrl.time = 0;
-
-    if (u->active_mixer != u->delayed_mixer_ctrl.m)
-        pa_log_warn("Active mixer has changed during compensation delay.");
+static void sink_set_volume_cb(pa_sink *s) {
+    struct userdata *u = global_userdata;
 
-    if (!u->sink) {
-        pa_log_debug("This sink does not exist any more, go away.");
+    pa_assert(u);
+    if (!enter_callback(u))
         return;
-    }
+    pa_assert(u->active_mixer);
 
-    if (!u->active_mixer) {
-        pa_log_warn("%s: no active mixer (sink_set_volume_cb)", u->device_name);
-        return;
+    if (s != u->sink) {
+        pa_log_error("This in not my sink, what to do?");
+        goto leave;
     }
 
-    if (!u->active_mixer->tuning_data[u->active_tuning].tuning_table_filled) {
-        load_mixer_tuning(u, u->active_mixer, u->active_tuning);
-        if (!u->active_mixer->tuning_data[u->active_tuning].tuning_table_filled) {
-            pa_log_info("No tuning table %d filled for %s mixer", u->active_tuning, u->active_mixer->name);
-            fill_mixer_tuning(u, u->active_mixer, u->active_tuning);
-        }
+    if (!u->sink) {
+        pa_log_debug("This sink does not exist any more, go away.");
+        goto leave;
     }
 
     log_spam("set volume to active mixer %s", u->active_mixer->name);
 
-    set_alsa_mixer_volumes(u, u->delayed_mixer_ctrl.m, u->delayed_mixer_ctrl.vv);
-}
-
-static int set_alsa_mixer_volumes_delay_compensated(struct userdata *u,
-                                                    struct mixer_control_t *m,
-                                                    pa_cvolume *vv) {
-    pa_usec_t new_time, delay = 0;
-    long hw_vol;
-
-    pa_assert(u);
-    pa_assert(m);
-    pa_assert(vv);
-
-    PA_MSGOBJECT(u->sink)->process_msg(
-            PA_MSGOBJECT(u->sink), PA_SINK_MESSAGE_GET_LATENCY, &delay, (int64_t)0, NULL);
-
-    /* pa_volume_t real_pa_vol = */ calculate_alsa_mixer_value(m, u->active_tuning, pa_cvolume_max(vv), &hw_vol);
-
-    if (hw_vol > u->delayed_mixer_ctrl.hw_vol_current)
-        delay += 13000;
-    else
-        delay += 5000;
-
-    /* in theory we should compare to all out time events...,
-       but because last time is the last time, that is fine */
-    new_time = pa_rtclock_now() + delay;
-    if (u->delayed_mixer_ctrl.time != 0 &&
-        new_time < u->delayed_mixer_ctrl.time)
-        new_time = u->delayed_mixer_ctrl.time + 1000; /* give it at least some time to take effect */
-
-    u->delayed_mixer_ctrl.hw_vol_current = hw_vol;
-    u->delayed_mixer_ctrl.m = m;
-    u->delayed_mixer_ctrl.vv = vv;
-    u->delayed_mixer_ctrl.time = new_time;
-
-    u->core->mainloop->rtclock_time_new(u->core->mainloop, u->delayed_mixer_ctrl.time, set_alsa_mixer_volume_timer_cb, u);
-    pa_log_debug("Mixer volume control delayed by %llu us", (unsigned long long)delay);
-
-    return 0;
+    set_alsa_mixer_volumes(u, u->active_mixer, &s->virtual_volume);
+leave:
+    leave_callback(u);
 }
 
-static void fill_mixer_tuning(struct userdata *u, struct mixer_control_t *m, const int table) {
-    tuning_data_t *td;
-    pa_assert(u);
-    pa_assert(m);
-    td = &m->tuning_data[table];
-
-    if (m->hw_dB_supported) {
-        pa_log_info("Using ALSA dB info to fill tuning table for %s mixer", m->name);
-        fill_tuning_table_from_dB_info(m, table);
-        td->tuning_table_filled = TRUE;
-    } else {
-        pa_log_warn("No tuning table or ALSA dB info for %s, this is bad (assuming 0 - -60dB range)",
-                m->name);
-        td->tuning_table_max = td->tuning_table_allocated_length-1;
-        fill_tuning_table_range(m, table, 0, td->tuning_table_max, -6000, 0);
-        td->tuning_table_filled = TRUE;
-        u->sink->n_volume_steps = td->tuning_table_max+1;
-    }
-}
-
-static void sink_set_volume_cb(pa_sink *s) {
-    //struct userdata *u = s->userdata;
+static void sink_write_volume_cb(pa_sink *s) {
     struct userdata *u = global_userdata;
 
     pa_assert(u);
+    if (!enter_callback(u))
+        return;
     pa_assert(u->active_mixer);
 
     if (s != u->sink) {
         pa_log_debug("This in not my sink, what to do?");
+        goto leave;
     }
 
-    /* These checks are probably unnecessary here because they are done again after timer
-       expiration, but I do not dare to remove them just yet. */
     if (!u->sink) {
         pa_log_debug("This sink does not exist any more, go away.");
-        return;
-    }
-
-    if (!u->active_mixer) {
-        pa_log_warn("%s: no active mixer (sink_set_volume_cb)", u->device_name);
-        return;
-    }
-
-    if (u->active_mixer->slaves) {
-        pa_log_error("SET SLAVE VOLUMES NOT IMPLEMENTED");
-    }
-
-    if (!u->active_mixer->tuning_data[u->active_tuning].tuning_table_filled) {
-        load_mixer_tuning(u, u->active_mixer, u->active_tuning);
-        if (!u->active_mixer->tuning_data[u->active_tuning].tuning_table_filled) {
-            pa_log_info("No tuning table %d filled for %s mixer", u->active_tuning, u->active_mixer->name);
-            fill_mixer_tuning(u, u->active_mixer, u->active_tuning);
-        }
-    }
+        goto leave;
+   }
 
     log_spam("set volume to active mixer %s", u->active_mixer->name);
 
-    set_alsa_mixer_volumes_delay_compensated(u, u->active_mixer, &s->virtual_volume);
-}
-
-static int get_mute(struct mixer_control_t *m, int *sw) {
-    int err;
-
-    if ((err = snd_mixer_selem_get_playback_switch(m->mixer_elem, 0, sw)) < 0) {
-        pa_log_error("Unable to get switch: %s", snd_strerror(err));
-        return 1;
-    }
-
-    return 0;
+    write_alsa_mixer_volumes(u, u->active_mixer, &s->thread_info.current_hw_volume);
+leave:
+    leave_callback(u);
 }
 
 static void sink_get_mute_cb(pa_sink *s) {
-    int sw;
     struct userdata *u = global_userdata;
+    int sw;
+    int err;
 
     pa_assert(u);
+    if (!enter_callback(u))
+        return;
     pa_assert(u->active_mixer);
+    pa_assert(u->active_mixer->mixer_elem);
 
-    if (!get_mute(u->active_mixer, &sw))
+    if ((err = snd_mixer_selem_get_playback_switch(u->active_mixer->mixer_elem, 0, &sw)) < 0)
+        pa_log_error("Unable to get switch: %s", snd_strerror(err));
+    else
         s->muted = !sw;
+
+    leave_callback(u);
 }
 
 static void sink_set_mute_cb(pa_sink *s) {
@@ -688,217 +666,91 @@ static void sink_set_mute_cb(pa_sink *s) {
     int err;
 
     pa_assert(u);
+    if (!enter_callback(u))
+        return;
     pa_assert(u->active_mixer);
     pa_assert(u->active_mixer->mixer_elem);
 
-    if ((err = snd_mixer_selem_set_playback_switch_all(u->active_mixer->mixer_elem, !s->muted)) < 0) {
+    if ((err = snd_mixer_selem_set_playback_switch_all(u->active_mixer->mixer_elem, !s->muted)) < 0)
         pa_log_error("Unable to set switch: %s", snd_strerror(err));
-        return;
-    }
+
+    leave_callback(u);
 }
 
-static struct mixer_control_t* get_mixer_elem_by_name(struct userdata *u, const char *mixer) {
-    struct mixer_control_t *m = NULL;
+static pa_hook_result_t sink_unlink_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
+    if (s != u->sink)
+        return PA_HOOK_OK;
 
-    for (m = u->mixer_list; m; m = m->next) {
-        if (strcmp(mixer, m->name) == 0)
-            return m;
-    }
+    u->sink = NULL;
 
-    return NULL;
+    return PA_HOOK_OK;
 }
 
-static int set_control_mixer_elem(struct userdata *u, struct mixer_control_t *m) {
-    const int active_tuning = u->active_tuning;
-    tuning_data_t *td = NULL;
-    pa_assert(u);
+/* Functions only called from sink_proplist_changed_hook_callback() start from here */
+static void fill_tuning_table_range(struct mixer_control_t *m, const int table, size_t start, size_t end,
+                                   long mBstart, long mBend) {
+    double mB_step;
+    int i;
     pa_assert(m);
+    pa_assert(end > start);
+    mB_step  = (double)(mBend-mBstart)/(double)(end-start);
 
-    pa_log_info("%s: setting active mixer to %s", u->device_name, m->name);
-    load_mixer_tuning(u, m, active_tuning);
-    td = &m->tuning_data[active_tuning];
-
-    if (!td->tuning_table_filled) {
-        pa_log_info("No tuning table filled for %s mixer", m->name);
-        fill_mixer_tuning(u, m, active_tuning);
-    }
-
-    if (snd_mixer_selem_has_playback_switch(m->mixer_elem)) {
-        u->sink->get_mute = sink_get_mute_cb;
-        u->sink->set_mute = sink_set_mute_cb;
-        u->sink->flags |= PA_SINK_HW_MUTE_CTRL;
-    } else {
-        pa_log_info("Using software mute control for mixer %s.", m->name);
-        u->sink->flags &= ~PA_SINK_HW_MUTE_CTRL;
-        u->sink->get_mute = NULL;
-        u->sink->set_mute = NULL;
-    }
-
-    log_spam("%s--> tuning %d filled %d", m->name, active_tuning, td->tuning_table_filled);
-
-    u->active_mixer = m;
-    return 0;
+    for (i = 0; i <= (int)(end - start); i++)
+        m->tuning_data[table].tuning_table[start + i] = lrint((double)mBstart + mB_step*i);
 }
 
-static struct mixer_control_t* get_mixer_element(struct userdata *u, const char *mixer) {
-    struct mixer_control_t *m = NULL;
-    snd_mixer_elem_t *mixer_elem;
-    tuning_data_t *td = NULL;
-    unsigned i;
-    pa_channel_map map;
-    pa_assert(u);
-    pa_assert(u->sink);
-
-    if (u->mixer_handle) {
-        /* Try using mixer as both primary and fallback mixer, to ensure mixer selection
-         * even when mixer doesn't have both volume and mute switches */
-        if (!(mixer_elem = pa_alsa_find_elem(u->mixer_handle, mixer, mixer, TRUE))) {
-            pa_log_error("%s: could not select mixer %s at all", u->device_name, mixer);
-            goto fail;
-        }
-    } else {
-        pa_log_error("%s: No mixer handle.", u->device_name);
-        goto fail;
-    }
-
-    m = pa_xnew0(struct mixer_control_t, 1);
-    PA_LLIST_INIT(struct mixer_control_t, m);
-
-    m->name = pa_xstrdup(mixer);
-    m->mixer_elem = mixer_elem;
-
-    if (!snd_mixer_selem_has_playback_volume(m->mixer_elem)) {
-        pa_log_error("%s: Mixer %s has no playback volume", u->device_name, mixer);
-        goto fail;
-    }
-
-    if (snd_mixer_selem_get_playback_volume_range(m->mixer_elem, &m->hw_volume_min, &m->hw_volume_max) < 0) {
-        pa_log_info("Failed to get volume range. Falling back to software volume control.");
-        goto fail;
-    }
-
-    if (m->hw_volume_min >= m->hw_volume_max) {
-        pa_log_warn("Bad mixer range: %ld - %ld.", m->hw_volume_min, m->hw_volume_max);
-        goto fail;
-    }
+#if 0
+static void print_tuning_table(struct mixer_control_t *m, const int table) {
+    int i;
+    pa_assert(m);
+    pa_assert(m->tuning_data[table].tuning_table);
 
-    if (snd_mixer_selem_get_playback_dB_range(m->mixer_elem, &m->hw_dB_min, &m->hw_dB_max) < 0) {
-        pa_log_info("Mixer doesn't not have dB information.");
-    }
-    else {
-#ifdef HAVE_VALGRIND_MEMCHECK_H
-        VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_min, sizeof(m->hw_dB_min));
-        VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_max, sizeof(m->hw_dB_max));
+    for(i=0; i<= m->tuning_data[table].tuning_table_max; i++)
+        pa_log_debug("%ld:%ld", i+m->tuning_data[table].tuned_volume_min, m->tuning_data[table].tuning_table[i]);
+}
 #endif
-        if (m->hw_dB_min >= m->hw_dB_max)
-            pa_log_warn("Bad dB range: %0.2f dB - %0.2f dB.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
-        else {
-            pa_log_info("Volume dB range: %0.2f dB - %0.2f dB.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
-            m->hw_dB_supported = TRUE;
-        }
-    }
-
-    map = u->sink->channel_map;
-    m->mixer_separate_channels = (pa_alsa_calc_mixer_map(m->mixer_elem, &map, m->mixer_map, TRUE) >= 0);
-
-    /* Initalize some sane values to hardware_volume */
-    pa_cvolume_set(&m->hardware_volume, u->sink->sample_spec.channels, PA_VOLUME_MUTED);
-
-    m->mixer_fdl = pa_alsa_fdlist_new();
-
-    if (pa_alsa_fdlist_set_mixer(m->mixer_fdl, u->mixer_handle, u->core->mainloop) < 0) {
-        pa_log_error("Failed to initialize file descriptor monitoring");
-        goto fail;
-    }
-
-    for (i = 0; i < MAX_TUNING_TABLES; i++) {
-        td = &m->tuning_data[i];
-        td->tuning_table_filled = FALSE;
-        td->tuning_table_allocated_length = m->hw_volume_max - m->hw_volume_min + 1;
-        if (td->tuning_table_allocated_length > MAX_VALUE_STEPS) {
-            pa_log_error("Too many mixer steps: %ld - %ld", m->hw_volume_max, m->hw_volume_min);
-            goto fail;
-        }
-
-        td->tuning_table_max = 0;
-        td->tuning_table = pa_xmalloc0(td->tuning_table_allocated_length * sizeof(long));
-        pa_assert(td->tuning_table);
-    }
 
-    snd_mixer_elem_set_callback(m->mixer_elem, mixer_callback);
-    snd_mixer_elem_set_callback_private(m->mixer_elem, u);
-
-    pa_log_info("%s: new mixer accepted: %s", u->device_name, m->name);
-    pa_log_debug("%s: mixer %s hw range %ld - %ld, alsa mB range %ld - %ld", u->device_name, m->name,
-                 m->hw_volume_min, m->hw_volume_max, m->hw_dB_min, m->hw_dB_max);
-
-    return m;
- fail:
-    if (m) {
-        if (m->name)
-            pa_xfree(m->name);
-
-        if (m->mixer_fdl) {
-            pa_alsa_fdlist_free(m->mixer_fdl);
-            m->mixer_fdl = NULL;
-        }
-
-        pa_xfree(m);
-    }
+static void fill_tuning_table_from_dB_info(struct mixer_control_t *m, const int table) {
+    tuning_data_t *td = &m->tuning_data[table];
+    pa_assert(m);
+    pa_assert(td->tuning_table);
 
-    return NULL;
+    td->tuned_volume_min = m->hw_volume_min;
+    td->tuned_volume_max = m->hw_volume_max;
+    td->tuning_table_max = td->tuning_table_allocated_length-1;
+    fill_tuning_table_range(m, table, 0, td->tuning_table_max, m->hw_dB_min - m->hw_dB_max, 0);
+    td->tuning_table_filled  = TRUE;
 }
 
-/** Load mixers using comma separated string list.
- *
- * return number of successfully loaded mixer elements
- */
-static int get_mixer_elements(struct userdata *u, const char *mixer_list) {
-    const char *state = NULL;
-    struct mixer_control_t *m = NULL;
-    int count = 0;
-    char *mixer;
+static void fill_mixer_tuning(struct userdata *u, struct mixer_control_t *m, const int table) {
+    tuning_data_t *td;
     pa_assert(u);
-    pa_assert(mixer_list);
+    pa_assert(m);
+    td = &m->tuning_data[table];
 
-    while ((mixer = pa_split(mixer_list, ",", &state))) {
-        m = get_mixer_element(u, mixer);
-        if (m) {
-            PA_LLIST_PREPEND(struct mixer_control_t, u->mixer_list, m);
-            count++;
-        }
-        pa_xfree(mixer);
+    if (m->hw_dB_supported) {
+        pa_log_info("Using ALSA dB info to fill tuning table for %s mixer", m->name);
+        fill_tuning_table_from_dB_info(m, table);
+        td->tuning_table_filled = TRUE;
+    } else {
+        pa_log_warn("No tuning table or ALSA dB info for %s, this is bad (assuming 0 - -60dB range)",
+                m->name);
+        td->tuning_table_max = td->tuning_table_allocated_length-1;
+        fill_tuning_table_range(m, table, 0, td->tuning_table_max, -6000, 0);
+        td->tuning_table_filled = TRUE;
+        u->sink->n_volume_steps = td->tuning_table_max+1;
     }
-
-    return count;
 }
 
-static void free_mixer_element(struct mixer_control_t *m) {
-    unsigned i;
-    pa_xfree(m->name);
-    pa_alsa_fdlist_free(m->mixer_fdl);
-    m->mixer_elem = NULL;
+static struct mixer_control_t* get_mixer_elem_by_name(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
 
-    for (i = 0; i < MAX_TUNING_TABLES; i++) {
-        if (m->tuning_data[i].tuning_table) {
-            pa_xfree(m->tuning_data[i].tuning_table);
-            m->tuning_data[i].tuning_table = NULL;
-        }
+    for (m = u->mixer_list; m; m = m->next) {
+        if (strcmp(mixer, m->name) == 0)
+            return m;
     }
 
-    pa_xfree(m);
-}
-
-static void free_mixer_elements(struct userdata *u) {
-    struct mixer_control_t *m;
-    log_spam("free mixer elements");
-
-    u->active_mixer = NULL;
-
-    while ((m = u->mixer_list)) {
-        PA_LLIST_REMOVE(struct mixer_control_t, u->mixer_list, m);
-        free_mixer_element(m);
-    }
+    return NULL;
 }
 
 static void my_split(const char *src, const char *separator, const char **left, const char **right) {
@@ -936,6 +788,10 @@ static int load_mixer_tuning(struct userdata *u, struct mixer_control_t *m, cons
     td->tuning_table_filled = FALSE;
 
     tuning = pa_proplist_gets(u->sink->proplist, PROP_MIXER_TUNING[tuning_mode]);
+    if (!tuning && PROP_MIXER_TUNING_ALT == tuning_mode) {
+        pa_log_debug("Could not find alternate tuning, loading primary instead");
+        tuning = pa_proplist_gets(u->sink->proplist, PROP_MIXER_TUNING[PROP_MIXER_TUNING_PRI]);
+    }
     if (!tuning) {
         pa_log_debug("Could not find mixer tuning");
         return -1;
@@ -1031,6 +887,26 @@ static int load_mixer_tuning(struct userdata *u, struct mixer_control_t *m, cons
     return 0;
 }
 
+static int set_control_mixer_elem(struct userdata *u, struct mixer_control_t *m, const int active_tuning) {
+    tuning_data_t *td = NULL;
+    pa_assert(u);
+    pa_assert(m);
+
+    pa_log_info("%s: setting active mixer to %s", u->device_name, m->name);
+    load_mixer_tuning(u, m, active_tuning);
+    td = &m->tuning_data[active_tuning];
+
+    if (!td->tuning_table_filled) {
+        pa_log_info("No tuning table filled for %s mixer", m->name);
+        fill_mixer_tuning(u, m, active_tuning);
+    }
+
+    log_spam("%s--> tuning %d filled %d", m->name, active_tuning, td->tuning_table_filled);
+
+    u->active_mixer = m;
+    return 0;
+}
+
 /** Set mixer state using colon separated MIXER:STATE pair.
  */
 static int set_mixer_state(struct userdata *u, const char *value_str) {
@@ -1044,7 +920,8 @@ static int set_mixer_state(struct userdata *u, const char *value_str) {
     if (mixer && mode && (m = get_mixer_elem_by_name(u, mixer))) {
 
         if (strcmp(mode, PROP_MIXER_CONTROL) == 0) {
-            if (set_control_mixer_elem(u, m)) {
+            if (set_control_mixer_elem(u, m, PROP_MIXER_TUNING_PRI) ||
+                set_control_mixer_elem(u, m, PROP_MIXER_TUNING_ALT) ) {
                 pa_log_error("%s: Setting control mixer %s failed", u->device_name, mixer);
                 ret = -1;
             }
@@ -1135,15 +1012,33 @@ static int update_mixer_setup(struct userdata *u, const char *value_list) {
         pa_log_warn("Setting mixer state for %d mixers failed", ret);
 
     if (u->active_mixer) {
-        if (!u->active_mixer->tuning_data[u->active_tuning].tuning_table_filled) {
-            load_mixer_tuning(u, u->active_mixer, u->active_tuning);
-            if (!u->active_mixer->tuning_data[u->active_tuning].tuning_table_filled) {
-                pa_log_info("No tuning table %d filled for %s mixer", u->active_tuning, u->active_mixer->name);
-                fill_mixer_tuning(u, u->active_mixer, u->active_tuning);
-            }
+        if (u->active_mixer->has_hw_mute) {
+            u->sink->get_mute = sink_get_mute_cb;
+            u->sink->set_mute = sink_set_mute_cb;
+            u->sink->flags |= PA_SINK_HW_MUTE_CTRL;
+        } else {
+            pa_log_info("Using software mute control for mixer %s.", u->active_mixer->name);
+            u->sink->flags &= ~PA_SINK_HW_MUTE_CTRL;
+            u->sink->get_mute = NULL;
+            u->sink->set_mute = NULL;
         }
+
+        u->sink->flags |= PA_SINK_HW_VOLUME_CTRL | PA_SINK_DECIBEL_VOLUME | PA_SINK_SYNC_VOLUME;
+        u->sink->get_volume = sink_get_volume_cb;
+        u->sink->set_volume = sink_set_volume_cb;
+        u->sink->write_volume = sink_write_volume_cb
+        log_spam("%s setting new volume callbacks", u->device_name);
+
         log_spam("update mixer volume (vol was %d) sink->refresh_volume %d", vol->values[0], u->sink->refresh_volume);
-        set_alsa_mixer_volumes(u, u->active_mixer, &volume);
+    }
+    else {
+        /* No active mixer, set all call backs to NULL */
+        u->sink->flags &= ~(PA_SINK_HW_MUTE_CTRL | PA_SINK_HW_VOLUME_CTRL | PA_SINK_SYNC_VOLUME);
+        u->sink->get_volume = NULL;
+        u->sink->set_volume = NULL;
+        u->sink->write_volume = NULL;
+        u->sink->get_mute = NULL;
+        u->sink->set_mute = NULL;
     }
 
     return ret;
@@ -1153,6 +1048,7 @@ static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink
     const char *v = NULL;
     int tmp;
     pa_bool_t full_update = TRUE;
+    pa_bool_t update_volume = FALSE;
 
     if (s != u->sink) {
         return PA_HOOK_OK;
@@ -1183,38 +1079,203 @@ static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink
     if (v) {
         if (!pa_atoi(v, &tmp)) {
             if (u->active_tuning != tmp) {
-                log_spam("change tuning mode to %d", tmp);
                 u->active_tuning = tmp;
+                log_spam("change tuning mode to %d", tmp);
+                update_volume = TRUE;
             }
         }
     }
 
     if (full_update) {
+        enter_initialization(u);
         v = pa_proplist_gets(s->proplist, PROP_MIXER);
         if (v) {
             update_mixer_setup(u, v);
         }
+        update_volume = FALSE;
+        pa_sink_set_mute(u->sink, u->sink->muted);
+        pa_sink_set_volume(u->sink, &u->sink->virtual_volume, FALSE, TRUE, FALSE);
+        leave_initialization(u);
+    }
+
+    if (update_volume)
+        pa_sink_set_volume(u->sink, &u->sink->virtual_volume, FALSE, TRUE, FALSE);
 
-        if (u->active_mixer && !u->mixers_initialized) {
-            /* Everything should be in order, write new volume callbacks */
-            u->sink->flags = u->original_flags | PA_SINK_HW_VOLUME_CTRL | PA_SINK_DECIBEL_VOLUME;
-            u->sink->get_volume = sink_get_volume_cb;
-            u->sink->set_volume = sink_set_volume_cb;
-            log_spam("%s setting new volume callbacks", u->device_name);
-            u->mixers_initialized = TRUE;
+    return PA_HOOK_OK;
+}
+
+/* Functions only called from init and unload start from here */
+static struct mixer_control_t* get_mixer_element(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
+    snd_mixer_elem_t *mixer_elem;
+    tuning_data_t *td = NULL;
+    unsigned i;
+    pa_channel_map map;
+    pa_assert(u);
+    pa_assert(u->sink);
+
+    if (u->mixer_handle) {
+        /* Try using mixer as both primary and fallback mixer, to ensure mixer selection
+         * even when mixer doesn't have both volume and mute switches */
+        if (!(mixer_elem = pa_alsa_find_elem(u->mixer_handle, mixer, mixer, TRUE))) {
+            pa_log_error("%s: could not select mixer %s at all", u->device_name, mixer);
+            goto fail;
         }
+    } else {
+        pa_log_error("%s: No mixer handle.", u->device_name);
+        goto fail;
     }
 
-    return PA_HOOK_OK;
+    m = pa_xnew0(struct mixer_control_t, 1);
+    PA_LLIST_INIT(struct mixer_control_t, m);
+
+    m->name = pa_xstrdup(mixer);
+    m->mixer_elem = mixer_elem;
+
+    if (!snd_mixer_selem_has_playback_volume(m->mixer_elem)) {
+        pa_log_error("%s: Mixer %s has no playback volume", u->device_name, mixer);
+        goto fail;
+    }
+
+    if (snd_mixer_selem_get_playback_volume_range(m->mixer_elem, &m->hw_volume_min, &m->hw_volume_max) < 0) {
+        pa_log_info("Failed to get volume range. Falling back to software volume control.");
+        goto fail;
+    }
+
+    if (m->hw_volume_min >= m->hw_volume_max) {
+        pa_log_warn("Bad mixer range: %ld - %ld.", m->hw_volume_min, m->hw_volume_max);
+        goto fail;
+    }
+
+    if (snd_mixer_selem_get_playback_dB_range(m->mixer_elem, &m->hw_dB_min, &m->hw_dB_max) < 0) {
+        pa_log_info("Mixer doesn't not have dB information.");
+    }
+    else {
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+        VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_min, sizeof(m->hw_dB_min));
+        VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_max, sizeof(m->hw_dB_max));
+#endif
+        if (m->hw_dB_min >= m->hw_dB_max)
+            pa_log_warn("Bad dB range: %0.2f dB - %0.2f dB.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
+        else {
+            pa_log_info("Volume dB range: %0.2f dB - %0.2f dB.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
+            m->hw_dB_supported = TRUE;
+        }
+    }
+
+    map = u->sink->channel_map;
+    m->mixer_separate_channels = (pa_alsa_calc_mixer_map(m->mixer_elem, &map, m->mixer_map, TRUE) >= 0);
+    m->has_hw_mute = snd_mixer_selem_has_playback_switch(m->mixer_elem);
+
+    /* Initalize some sane values to hardware_volume */
+    pa_cvolume_set(&m->hardware_volume, u->sink->sample_spec.channels, PA_VOLUME_MUTED);
+
+    m->mixer_fdl = pa_alsa_fdlist_new();
+
+    if (pa_alsa_fdlist_set_mixer(m->mixer_fdl, u->mixer_handle, u->core->mainloop) < 0) {
+        pa_log_error("Failed to initialize file descriptor monitoring");
+        goto fail;
+    }
+
+    for (i = 0; i < MAX_TUNING_TABLES; i++) {
+        td = &m->tuning_data[i];
+        td->tuning_table_filled = FALSE;
+        td->tuning_table_allocated_length = m->hw_volume_max - m->hw_volume_min + 1;
+        if (td->tuning_table_allocated_length > MAX_VALUE_STEPS) {
+            pa_log_error("Too many mixer steps: %ld - %ld", m->hw_volume_max, m->hw_volume_min);
+            goto fail;
+        }
+
+        td->tuning_table_max = 0;
+        td->tuning_table = pa_xmalloc0(td->tuning_table_allocated_length * sizeof(long));
+        pa_assert(td->tuning_table);
+    }
+
+    snd_mixer_elem_set_callback(m->mixer_elem, mixer_callback);
+    snd_mixer_elem_set_callback_private(m->mixer_elem, u);
+
+    pa_log_info("%s: new mixer accepted: %s", u->device_name, m->name);
+    pa_log_debug("%s: mixer %s hw range %ld - %ld, alsa mB range %ld - %ld", u->device_name, m->name,
+                 m->hw_volume_min, m->hw_volume_max, m->hw_dB_min, m->hw_dB_max);
+
+    return m;
+ fail:
+    if (m) {
+        if (m->name)
+            pa_xfree(m->name);
+
+        if (m->mixer_fdl) {
+            pa_alsa_fdlist_free(m->mixer_fdl);
+            m->mixer_fdl = NULL;
+        }
+
+        pa_xfree(m);
+    }
+
+    return NULL;
 }
 
-static pa_hook_result_t sink_unlink_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
-    if (s != u->sink)
-        return PA_HOOK_OK;
+/** Load mixers using comma separated string list.
+ *
+ * return number of successfully loaded mixer elements
+ */
+static int get_mixer_elements(struct userdata *u, const char *mixer_list) {
+    const char *state = NULL;
+    struct mixer_control_t *m = NULL;
+    int count = 0;
+    char *mixer;
+    pa_assert(u);
+    pa_assert(mixer_list);
 
-    u->sink = NULL;
+    while ((mixer = pa_split(mixer_list, ",", &state))) {
+        if (mixer) {
+            m = get_mixer_element(u, mixer);
+            if (m) {
+                PA_LLIST_PREPEND(struct mixer_control_t, u->mixer_list, m);
+                count++;
+            }
+            pa_xfree(mixer);
+        }
+    }
 
-    return PA_HOOK_OK;
+    return count;
+}
+
+static void free_mixer_element(struct mixer_control_t *m) {
+    unsigned i;
+    pa_xfree(m->name);
+    pa_alsa_fdlist_free(m->mixer_fdl);
+    m->mixer_elem = NULL;
+
+    for (i = 0; i < MAX_TUNING_TABLES; i++) {
+        if (m->tuning_data[i].tuning_table) {
+            pa_xfree(m->tuning_data[i].tuning_table);
+            m->tuning_data[i].tuning_table = NULL;
+        }
+    }
+
+    pa_xfree(m);
+}
+
+static void free_mixer_elements(struct userdata *u) {
+    struct mixer_control_t *m;
+    log_spam("free mixer elements");
+
+    u->active_mixer = NULL;
+
+    while ((m = u->mixer_list)) {
+        PA_LLIST_REMOVE(struct mixer_control_t, u->mixer_list, m);
+        free_mixer_element(m);
+    }
+}
+
+static void replace_chars(char *str, const char c, const char new_c) {
+    int ii = -1;
+    pa_assert(str);
+    while(str[++ii] != '\0') {
+        if (str[ii] == c)
+            str[ii] = new_c;
+    }
 }
 
 int pa__init(pa_module*m) {
@@ -1272,7 +1333,7 @@ int pa__init(pa_module*m) {
 
     global_userdata = u;
 
-    u->mixers_initialized = FALSE;
+    init_mixer_lock(&u->lock);
     u->sink = hw_sink;
     u->active_tuning = PROP_MIXER_TUNING_PRI;
 
@@ -1280,6 +1341,7 @@ int pa__init(pa_module*m) {
     u->original_flags = u->sink->flags;
     u->original_get_volume = u->sink->get_volume;
     u->original_set_volume = u->sink->set_volume;
+    u->original_write_volume = u->sink->write_volume;
     u->original_get_mute = u->sink->get_mute;
     u->original_set_mute = u->sink->set_mute;
 
@@ -1363,6 +1425,9 @@ void pa__done(pa_module*m) {
     if (!(u = m->userdata))
         return;
 
+    enter_initialization(u);
+    free_mixer_lock(&u->lock);
+
     if (u->sink_proplist_changed_slot)
         pa_hook_slot_free(u->sink_proplist_changed_slot);
     if (u->sink_unlink_slot)
@@ -1382,6 +1447,7 @@ void pa__done(pa_module*m) {
         u->sink->flags = u->original_flags;
         u->sink->get_volume = u->original_get_volume;
         u->sink->set_volume = u->original_set_volume;
+        u->sink->write_volume = u->original_write_volume;
         u->sink->get_mute = u->original_get_mute;
         u->sink->set_mute = u->original_set_mute;
         pa_sink_get_volume(u->sink, TRUE, FALSE);
-- 
1.5.6.3

