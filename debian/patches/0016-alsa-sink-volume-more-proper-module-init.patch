From cc5716873462ec356480f2b7b478ad39a67a812a Mon Sep 17 00:00:00 2001
From: Juho Hamalainen <ext-juho.hamalainen@nokia.com>
Date: Thu, 5 Mar 2009 16:54:02 +0200
Subject: [PATCH 16/49] alsa-sink-volume: more proper module init

---
 src/modules/alsa/module-alsa-sink-volume.c |   64 +++++++++++++++-------------
 1 files changed, 34 insertions(+), 30 deletions(-)

diff --git a/src/modules/alsa/module-alsa-sink-volume.c b/src/modules/alsa/module-alsa-sink-volume.c
index f10bf98..101f9dd 100644
--- a/src/modules/alsa/module-alsa-sink-volume.c
+++ b/src/modules/alsa/module-alsa-sink-volume.c
@@ -57,30 +57,17 @@
 #include "module-alsa-sink-volume-symdef.h"
 #include "module-alsa-sink-old.h"
 
-PA_MODULE_AUTHOR("Lennart Poettering");
-PA_MODULE_DESCRIPTION("ALSA Sink");
+PA_MODULE_AUTHOR("Juho Hamalainen");
+PA_MODULE_DESCRIPTION("ALSA Mixer Control");
 PA_MODULE_VERSION(PACKAGE_VERSION);
 PA_MODULE_LOAD_ONCE(FALSE);
 PA_MODULE_USAGE(
-        "sink_name=<name for the sink> "
+        "sink_name=<name of the sink to connect> "
         "device=<ALSA device> "
-        "device_id=<ALSA device id> "
-        "format=<sample format> "
-        "channels=<number of channels> "
-        "rate=<sample rate> "
         "mixer=<initial ALSA mixer> "
         "mixer_load=<load mixer controls in startup> "
-        "fragments=<number of fragments> "
-        "fragment_size=<fragment size> "
-        "alt_fragments=<number of fragments> "
-        "alt_fragment_size=<fragment size> "
-        "channel_map=<channel map> "
-        "mmap=<enable memory mapping?>");
+        "ignore_dB=<ignore dB info from ALSA>");
 
-#define DEFAULT_DEVICE "default"
-
-#define SINK_SWITCH_PRIMARY (0)
-#define SINK_SWITCH_ALTERNATIVE (1)
 
 struct gain_step_t {
     int step;
@@ -151,10 +138,10 @@ struct entry {
 
 static const char* const valid_modargs[] = {
     "device",
-    "device_id",
     "sink_name",
     "mixer",
     "mixer_load",
+    "ignore_dB",
     NULL
 };
 
@@ -1268,6 +1255,18 @@ int pa__init(pa_module*m) {
         goto fail;
     }
 
+    sink_name = pa_modargs_get_value(ma, "sink_name", NULL);
+    if (!sink_name) {
+        pa_log("No sink_name defined.");
+        goto fail;
+    }
+
+    hw_sink = pa_namereg_get(m->core, sink_name, PA_NAMEREG_SINK);
+    if (!hw_sink) {
+        pa_log("Couldn't get sink with name %s", sink_name);
+        goto fail;
+    }
+
     if (pa_modargs_get_value_boolean(ma, "ignore_dB", &ignore_dB) < 0) {
         pa_log("Failed to parse ignore_dB argument.");
         goto fail;
@@ -1285,9 +1284,6 @@ int pa__init(pa_module*m) {
         mixer_load = pa_xstrdup(alsa_mixer);
     }
 
-    sink_name = pa_modargs_get_value(ma, "sink_name", NULL);
-    pa_log("sink_name %s", sink_name);
-    hw_sink = pa_namereg_get(m->core, sink_name, PA_NAMEREG_SINK);
 
 
     u = pa_xnew0(struct userdata, 1);
@@ -1299,18 +1295,24 @@ int pa__init(pa_module*m) {
     global_userdata = u;
 
     u->sink = hw_sink;
+
+    /* get variables from sink */
     u->channel_map = u->sink->channel_map;
+    u->default_flags = u->sink->flags; 
 
-    pa_log("get device_name from sink");
-    if (pa_proplist_gets(u->sink->proplist, PA_PROP_DEVICE_STRING)) {
+    if (pa_modargs_get_value(ma, "device", NULL))
+        u->device_name = pa_xstrdup(pa_modargs_get_value(ma, "device", NULL));
+    else if (pa_proplist_gets(u->sink->proplist, PA_PROP_DEVICE_STRING))
         u->device_name = pa_xstrdup(pa_proplist_gets(u->sink->proplist, PA_PROP_DEVICE_STRING));
-    }
 
-    pa_assert(u->device_name);
-    pa_log_info("Successfully opened device %s.", u->device_name);
+    if (!u->device_name) {
+        pa_log("No device name defined or detected from sink");
+        goto fail;
+    }
 
     if ((err = snd_mixer_open(&u->mixer_handle, 0)) < 0) {
         pa_log("Error opening mixer: %s", snd_strerror(err));
+        goto fail;
     } else {
         pa_bool_t found = FALSE;
 
@@ -1346,6 +1348,11 @@ int pa__init(pa_module*m) {
         }
     }
 
+    if (!u->mixer_handle) {
+        /* this is mixer module, no reason to continue */
+        goto fail;
+    }
+
     if (mixer_load)
         mixer_count = get_mixer_elements(u, mixer_load);
 
@@ -1353,16 +1360,13 @@ int pa__init(pa_module*m) {
 
     pa_proplist_sets(u->sink->proplist, PA_ALSA_SINK_PROP_MIXER, "(none)");
 
-    /* hook for buffer & mixer switching, only if either buffer switching or
-     * mixer gain step modification is possible. */
+    /* hook for mixer switching */
     if (mixer_load)
         u->sink_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_PROPLIST_CHANGED],
                                                         PA_HOOK_LATE,
                                                         (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
 
 
-    /* pa_sink_put modifies sink flags */
-    u->default_flags = u->sink->flags; 
 
 #if 0
     /* allow stream restore to apply old volumes */
-- 
1.6.2.rc1.13.gfd76c.dirty

