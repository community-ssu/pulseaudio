From d6e7f84ad22df36ac54f1cd29cd06a4e6b4c8526 Mon Sep 17 00:00:00 2001
From: Juho Hamalainen <ext-juho.hamalainen@nokia.com>
Date: Tue, 31 Mar 2009 14:26:08 +0300
Subject: [PATCH 15/16] alsa: sink-volume, a complex mixer module

---
 src/Makefile.am                                   |    7 +
 src/modules/alsa/module-alsa-sink-volume-symdef.h |   27 +
 src/modules/alsa/module-alsa-sink-volume.c        | 1412 +++++++++++++++++++++
 3 files changed, 1446 insertions(+), 0 deletions(-)
 create mode 100644 src/modules/alsa/module-alsa-sink-volume-symdef.h
 create mode 100644 src/modules/alsa/module-alsa-sink-volume.c

diff --git a/src/Makefile.am b/src/Makefile.am
index 1489fd8..016c9fd 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1005,6 +1005,7 @@ modlibexec_LTLIBRARIES += \
 		module-alsa-source.la \
 		module-alsa-card.la \
 		module-alsa-sink-old.la \
+		module-alsa-sink-volume.la \
 		module-alsa-source-old.la
 endif
 
@@ -1117,6 +1118,7 @@ SYMDEF_FILES = \
 		modules/alsa/module-alsa-source-symdef.h \
 		modules/alsa/module-alsa-card-symdef.h \
 		modules/alsa/module-alsa-sink-old-symdef.h \
+		modules/alsa/module-alsa-sink-volume-symdef.h \
 		modules/alsa/module-alsa-source-old-symdef.h \
 		modules/module-solaris-symdef.h \
 		modules/module-waveout-symdef.h \
@@ -1362,6 +1364,11 @@ module_alsa_sink_old_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_alsa_sink_old_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
 module_alsa_sink_old_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
 
+module_alsa_sink_volume_la_SOURCES = modules/alsa/module-alsa-sink-volume.c
+module_alsa_sink_volume_la_LDFLAGS = $(MODULE_LDFLAGS)
+module_alsa_sink_volume_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
+module_alsa_sink_volume_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
+
 module_alsa_source_old_la_SOURCES = modules/alsa/module-alsa-source-old.c
 module_alsa_source_old_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_alsa_source_old_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
diff --git a/src/modules/alsa/module-alsa-sink-volume-symdef.h b/src/modules/alsa/module-alsa-sink-volume-symdef.h
new file mode 100644
index 0000000..30c44c1
--- /dev/null
+++ b/src/modules/alsa/module-alsa-sink-volume-symdef.h
@@ -0,0 +1,27 @@
+#ifndef foomodulealsasinkvolumesymdeffoo
+#define foomodulealsasinkvolumesymdeffoo
+
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/macro.h>
+
+#define pa__init module_alsa_sink_volume_LTX_pa__init
+#define pa__done module_alsa_sink_volume_LTX_pa__done
+#define pa__get_author module_alsa_sink_volume_LTX_pa__get_author
+#define pa__get_description module_alsa_sink_volume_LTX_pa__get_description
+#define pa__get_usage module_alsa_sink_volume_LTX_pa__get_usage
+#define pa__get_version module_alsa_sink_volume_LTX_pa__get_version
+#define pa__load_once module_alsa_sink_volume_LTX_pa__load_once
+#define pa__get_n_used module_alsa_sink_volume_LTX_pa__get_n_used
+
+int pa__init(pa_module*m);
+void pa__done(pa_module*m);
+int pa__get_n_used(pa_module*m);
+
+const char* pa__get_author(void);
+const char* pa__get_description(void);
+const char* pa__get_usage(void);
+const char* pa__get_version(void);
+pa_bool_t pa__load_once(void);
+
+#endif
diff --git a/src/modules/alsa/module-alsa-sink-volume.c b/src/modules/alsa/module-alsa-sink-volume.c
new file mode 100644
index 0000000..fac5804
--- /dev/null
+++ b/src/modules/alsa/module-alsa-sink-volume.c
@@ -0,0 +1,1412 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright (C) 2008-2009 Nokia Corporation and/or its subsidiary(-ies).
+  Copyright 2004-2006 Lennart Poettering
+  Copyright 2006 Pierre Ossman <ossman@cendio.se> for Cendio AB
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published
+  by the Free Software Foundation; either version 2 of the License,
+  or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with PulseAudio; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <gdbm.h>
+
+#include <asoundlib.h>
+
+#include <pulse/xmalloc.h>
+#include <pulse/util.h>
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/memchunk.h>
+#include <pulsecore/sink.h>
+#include <pulsecore/modargs.h>
+#include <pulsecore/core-util.h>
+#include <pulsecore/sample-util.h>
+#include <pulsecore/log.h>
+#include <pulsecore/macro.h>
+#include <pulsecore/thread.h>
+#include <pulsecore/core-error.h>
+#include <pulsecore/thread-mq.h>
+#include <pulsecore/rtpoll.h>
+#include <pulsecore/atomic.h>
+#include <pulsecore/namereg.h>
+
+#include "alsa-util.h"
+#include "module-alsa-sink-volume-symdef.h"
+
+PA_MODULE_AUTHOR("Juho Hamalainen & Jyri Sarha");
+PA_MODULE_DESCRIPTION("ALSA Mixer Control from Nokia");
+PA_MODULE_VERSION(PACKAGE_VERSION);
+PA_MODULE_LOAD_ONCE(FALSE);
+PA_MODULE_USAGE(
+        "sink_name=<name of the sink to connect> "
+        "device=<ALSA device> "
+        "mixer=<initial ALSA mixer> "
+        "mixer_load=<load mixer controls in startup> ");
+
+static const char* const valid_modargs[] = {
+    "device",
+    "sink_name",
+    "mixer",
+    "mixer_load",
+    NULL
+};
+
+/* Update mixer states,
+ * max       0dB
+ * off       mute
+ * control   sink volume controlled
+ *
+ * eg. "HP DAC:max,Headphone:off,Earphone:control"
+ */
+#define PROP_MIXER         "x-maemo.alsa_sink.mixer_control"
+#define PROP_MIXER_OFF     "off"
+#define PROP_MIXER_MAX     "max"
+#define PROP_MIXER_CONTROL "control"
+#define PROP_MIXER_SLAVE   "slave"
+
+/* String of comma separated numbers defining alsa volumes
+ *
+ * MIXER LIST|GAIN STEPS
+ * eg. without dB "HP DAC,Earphone#0,0|50,30|60,40"
+ * with dB "HP DAC,Earphone#-500,-400|-300,-200|-100,0"
+ *
+ */
+#define PROP_MIXER_TUNING "x-maemo.alsa_sink.mixer_tuning"
+
+struct slave_mixer_t;
+typedef struct slave_mixer_t slave_mixer_t;
+
+typedef struct mixer_control_t {
+    char *name;
+    pa_alsa_fdlist *mixer_fdl;
+    snd_mixer_elem_t *mixer_elem;
+    snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
+    unsigned channels;
+
+    long hw_volume_max, hw_volume_min;
+    long hw_dB_max, hw_dB_min;
+    pa_bool_t hw_dB_supported;
+    pa_bool_t mixer_separate_channels;
+
+    pa_cvolume hardware_volume;
+
+    enum { MM_UNUSED=0, MM_CONTROL, MM_STATIC, MM_SLAVE } mode;
+    pa_bool_t tuning_table_filled;
+    long *tuning_table;
+    int tuning_table_allocated_length;
+    int tuning_table_max;
+    long tuned_volume_max, tuned_volume_min;
+
+    struct slave_mixer_t **slaves;
+
+    /* store mixer volumes when mixer not in use */
+    pa_cvolume cache_volume;
+    pa_bool_t cache_muted;
+
+    PA_LLIST_FIELDS(struct mixer_control_t);
+} mixer_control_t;
+
+struct slave_mixer_t {
+    struct mixer_control_t *mixer;
+    long *tuning_table;
+};
+
+#define DEFAULT_MIXER_DB_VALUE_ON_FIRST_BOOT (-12)
+#define MAX_VALUE_STEPS (1024)
+#define MAX_MIXER_COUNT (16)
+
+struct userdata {
+    pa_core *core;
+    pa_module *module;
+
+    /* controlled sink and properties */
+    pa_sink *sink;
+    pa_sink_flags_t original_flags;
+    void (*original_get_volume)(pa_sink *s);
+    void (*original_set_volume)(pa_sink *s);
+    void (*original_get_mute)(pa_sink *s);
+    void (*original_set_mute)(pa_sink *s);
+
+    char *device_name;
+
+    snd_mixer_t *mixer_handle;
+
+    /* store for all loaded mixers */
+    PA_LLIST_HEAD(struct mixer_control_t, mixer_list);
+    struct mixer_control_t *active_mixer;
+
+    /* TODO: remove: gain step cache */
+    pa_bool_t gain_step_enabled;
+    int gain_step_pos;
+
+    pa_bool_t sw_vol_compensation;
+
+    /* store mixer volumes */
+    GDBM_FILE gdbm_file;
+    pa_bool_t cache_volumes;
+
+    pa_hook_slot *sink_proplist_changed_slot;
+    pa_hook_slot *sink_unlink_slot;
+};
+
+static struct userdata *global_userdata = NULL;
+
+#define ENTRY_VERSION 1
+
+struct entry {
+    uint8_t version;
+    pa_bool_t muted:1;
+    pa_cvolume volume;
+} PA_GCC_PACKED;
+
+static void replace_chars(char *str, const char c, const char new_c) {
+    unsigned ii = 0;
+    pa_assert(str);
+    while(str[ii++] != '\0') { // is there a pa function for this?
+        if (str[ii] == c)
+            str[ii] = new_c;
+    }
+}
+
+static int mixer_callback(snd_mixer_elem_t *elem, unsigned int mask) {
+    struct userdata *u = snd_mixer_elem_get_callback_private(elem);
+
+    pa_assert(u);
+    pa_assert(u->mixer_handle);
+
+
+
+    if (mask == SND_CTL_EVENT_MASK_REMOVE)
+        return 0;
+
+    if (mask & SND_CTL_EVENT_MASK_VALUE) {
+        if (!u->sink) {
+            return 0;
+        }
+
+        pa_sink_get_volume(u->sink, TRUE);
+        pa_sink_get_mute(u->sink, TRUE);
+    }
+
+    return 0;
+}
+
+static size_t mB_to_hw_mixer_find(mixer_control_t *m, long mB, size_t l, size_t h) {
+
+    if (l + 1 == h)
+        return l;
+
+    if (mB > m->tuning_table[(l+h)/2])
+        return mB_to_hw_mixer_find(m, mB, (l+h)/2, h);
+    else
+        return mB_to_hw_mixer_find(m, mB, l, (l+h)/2);
+}
+
+static long mB_to_hw_mixer_value(mixer_control_t *m, long mB) {
+    int element;
+    long ret;
+    pa_assert(m);
+    pa_assert(m->tuning_table_filled);
+
+    if (mB <= m->tuning_table[0])
+        return m->tuned_volume_min;
+
+    if (mB >= m->tuning_table[m->tuning_table_max])
+        return m->tuned_volume_max;
+
+    element = mB_to_hw_mixer_find(m, mB, 0, m->tuning_table_max);
+
+    if ((mB - m->tuning_table[element]) < (m->tuning_table[element+1] - mB))
+        ret = element + m->tuned_volume_min;
+    else
+        ret = element + 1 + m->tuned_volume_min;
+
+    return ret;
+}
+
+static long hw_mixer_to_mB_value(mixer_control_t *m, long hw_vol) {
+    pa_assert(m);
+    pa_assert(m->tuning_table_filled);
+
+    return m->tuning_table[hw_vol - m->tuned_volume_min];
+}
+
+static void fill_tuning_table_range(struct mixer_control_t *m, size_t start, size_t end,
+                                   long mBstart, long mBend) {
+    double mB_step;
+    int i;
+    pa_assert(m);
+    pa_assert(end > start);
+    mB_step  = (double)(mBend-mBstart)/(double)(end-start);
+
+    for (i = 0; i <= (int)(end - start); i++)
+        m->tuning_table[start + i] = lrint((double)mBstart + mB_step*i);
+}
+
+static void print_tuning_table(struct mixer_control_t *m) {
+    int i;
+    pa_assert(m);
+    pa_assert(m->tuning_table);
+
+    for(i=0; i<= m->tuning_table_max; i++)
+        pa_log_debug("%ld:%ld", i+m->tuned_volume_min, m->tuning_table[i]);
+}
+
+static void fill_tuning_table_from_dB_info(struct mixer_control_t *m) {
+    pa_assert(m);
+    pa_assert(m->tuning_table);
+    m->tuned_volume_min = m->hw_volume_min;
+    m->tuned_volume_max = m->hw_volume_max;
+    m->tuning_table_max = m->tuning_table_allocated_length-1;
+    fill_tuning_table_range(m, 0, m->tuning_table_max, m->hw_dB_min - m->hw_dB_max, 0);
+    m->tuning_table_filled = TRUE;
+}
+
+static void sink_get_volume_cb(pa_sink *s) {
+    struct userdata *u = global_userdata;
+    struct mixer_control_t *m = NULL;
+    int err;
+    unsigned i;
+    pa_cvolume r;
+    char t[PA_CVOLUME_SNPRINT_MAX];
+
+    pa_assert(u);
+    pa_assert(u->active_mixer);
+    pa_assert(u->active_mixer->mixer_elem);
+
+    if (!u->sink) {
+        pa_log_debug("This sink does not exist any more, go away.");
+        return;
+    }
+
+    if (s != u->sink) {
+        pa_log_debug("This in not my sink, what to do?");
+    }
+
+    m = u->active_mixer;
+
+    if (m->mixer_separate_channels) {
+
+        r.channels = u->sink->sample_spec.channels;
+
+        for (i = 0; i < u->sink->sample_spec.channels; i++) {
+            long hw_vol;
+            long mB;
+
+            if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, m->mixer_map[i], &hw_vol)) < 0)
+                goto fail;
+
+            pa_log_debug("Got hw volume %s ch %d: %ld", m->name, i, hw_vol);
+
+            mB = hw_mixer_to_mB_value(m, hw_vol);
+
+            r.values[i] = pa_sw_volume_from_dB((double) mB / 100.0);
+
+            pa_log_debug("Alsa %ld hw = tuned mB %ld = %d PA volume", hw_vol, mB, r.values[i]);
+        }
+
+    } else {
+        long hw_vol;
+        long mB;
+        pa_volume_t pa_vol;
+        if ((err = snd_mixer_selem_get_playback_volume(u->active_mixer->mixer_elem, SND_MIXER_SCHN_MONO, &hw_vol)) < 0)
+            goto fail;
+
+        pa_log_debug("Got mono alsa volume %s: %ld", m->name, hw_vol);
+
+        mB = hw_mixer_to_mB_value(m, hw_vol);
+
+        pa_vol = pa_sw_volume_from_dB((double) mB / 100.0);
+
+        pa_log_debug("Alsa %ld hw = tuned mB %ld = %d PA volume", hw_vol, mB, pa_vol);
+
+        pa_cvolume_set(&r, u->sink->sample_spec.channels, pa_vol);
+    }
+
+    pa_log_debug("Read hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &r));
+
+    if (!pa_cvolume_equal(&u->active_mixer->hardware_volume, &r)) {
+        pa_cvolume reset;
+
+        pa_log_debug("Active mixer value has changed, updatng sink value");
+
+        s->virtual_volume = u->active_mixer->hardware_volume = r;
+
+        /* Hmm, so the hardware volume changed, let's reset our software volume */
+        pa_cvolume_reset(&reset, u->sink->sample_spec.channels);
+        pa_sink_set_soft_volume(s, &reset);
+    }
+
+    return;
+
+ fail:
+    pa_log_error("Unable to read volume: %s", snd_strerror(err));
+}
+
+static pa_volume_t calculate_alsa_mixer_value(struct mixer_control_t *m, pa_volume_t pa_vol, long *hw_vol) {
+    long mB_vol;
+    long real_mB_vol;
+    pa_volume_t real_pa_vol;
+    pa_assert(m);
+    pa_assert(hw_vol);
+
+    mB_vol = (long) (pa_sw_volume_to_dB(pa_vol) * 100);
+    *hw_vol = mB_to_hw_mixer_value(m, mB_vol);
+    real_mB_vol = hw_mixer_to_mB_value(m, *hw_vol);
+    real_pa_vol = pa_sw_volume_from_dB((double) real_mB_vol / 100.0);
+
+    pa_log_debug("Setting pa vol %d = %ld mB -> %s: %ld = %ld mB = %d pa vol",
+                 pa_vol, mB_vol, m->name, *hw_vol, real_mB_vol, real_pa_vol);
+
+    return real_pa_vol;
+}
+
+
+static int set_alsa_mixer_volumes(struct userdata *u,
+                                  struct mixer_control_t *m,
+                                  pa_cvolume *vv) {
+    char t[PA_CVOLUME_SNPRINT_MAX];
+    int err;
+    unsigned i;
+    pa_cvolume r;
+
+    pa_assert(u);
+    pa_assert(m->mixer_elem);
+    pa_assert(m->tuning_table);
+    pa_assert(m->tuning_table_filled);
+
+    if (m->mixer_separate_channels) {
+
+        r.channels = u->sink->sample_spec.channels;
+
+        for (i = 0; i < u->sink->sample_spec.channels; i++) {
+            long hw_vol, real_hw_vol;
+            pa_volume_t real_pa_vol = calculate_alsa_mixer_value(m, vv->values[i], &hw_vol);
+
+            if ((err = snd_mixer_selem_set_playback_volume(m->mixer_elem, m->mixer_map[i], hw_vol)) < 0)
+                goto fail;
+#if 1            /* Maybe I could check alsa mixer value once more ... */
+            if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, m->mixer_map[i], &real_hw_vol)) < 0)
+                goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&real_hw_vol, sizeof(real_hw_vol));
+#endif
+            if (hw_vol != real_hw_vol) {
+                pa_log_warn("Can not set tuned hw vol %s ch %d to %ld, hw value is %ld",
+                            m->name, i, hw_vol, real_hw_vol);
+            }
+#endif
+
+            r.values[i] = real_pa_vol;
+        }
+    } else {
+        long hw_vol, real_hw_vol;
+        pa_volume_t real_pa_vol = calculate_alsa_mixer_value(m, pa_cvolume_max(vv), &hw_vol);
+
+
+        if ((err = snd_mixer_selem_set_playback_volume_all(m->mixer_elem, hw_vol)) < 0)
+            goto fail;
+
+#if 1            /* Maybe I could check alsa mixer value once more ... */
+        if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, SND_MIXER_SCHN_MONO, &real_hw_vol)) < 0)
+            goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&real_hw_vol, sizeof(real_hw_vol));
+#endif
+        if (hw_vol != real_hw_vol) {
+            pa_log_warn("Can not set tuned mono hw vol %s to %ld, hw value is %ld",
+                        m->name, hw_vol, real_hw_vol);
+        }
+#endif
+
+        pa_cvolume_set(&r, u->sink->sample_spec.channels, real_pa_vol);
+    }
+
+    m->hardware_volume = r;
+
+    pa_log_debug("Requested volume: %s", pa_cvolume_snprint(t, sizeof(t), vv));
+    pa_log_debug("Got hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &m->hardware_volume));
+
+    if (u->sw_vol_compensation)  {
+        /* Match exactly what the user requested by software */
+        pa_sw_cvolume_divide(&u->sink->soft_volume, vv, &m->hardware_volume);
+        pa_log_debug("Calculated software volume: %s", pa_cvolume_snprint(t, sizeof(t), &u->sink->soft_volume));
+    } else {
+        /* We can't match exactly what the user requested, hence let's
+         * at least tell the user about it */
+            pa_log_debug("Skip software volume calculation");
+        *vv = r;
+    }
+
+    return 0;
+
+ fail:
+    pa_log_error("Unable to set volume: %s", snd_strerror(err));
+
+    return 1;
+}
+
+static void sink_set_volume_cb(pa_sink *s) {
+    //struct userdata *u = s->userdata;
+    struct userdata *u = global_userdata;
+
+    pa_assert(u);
+    pa_assert(u->active_mixer);
+
+    if (!u->sink) {
+        pa_log_debug("This sink does not exist any more, go away.");
+        return;
+    }
+
+    if (s != u->sink) {
+        pa_log_debug("This in not my sink, what to do?");
+    }
+
+    if (!u->active_mixer) {
+        pa_log_warn("%s: no active mixer (sink_set_volume_cb)", u->device_name);
+        return;
+    }
+
+    if (u->active_mixer->slaves) {
+        pa_log("SET SLAVE VOLUMES NOT IMPLEMENTED");
+    }
+
+    pa_log_debug("set volume to active mixer %s", u->active_mixer->name);
+
+    set_alsa_mixer_volumes(u, u->active_mixer, &s->virtual_volume);
+}
+
+static int get_mute(struct mixer_control_t *m, int *sw) {
+    int err;
+
+    if ((err = snd_mixer_selem_get_playback_switch(m->mixer_elem, 0, sw)) < 0) {
+        pa_log_error("Unable to get switch: %s", snd_strerror(err));
+        return 1;
+    }
+
+    return 0;
+}
+
+static void sink_get_mute_cb(pa_sink *s) {
+    int sw;
+    struct userdata *u = global_userdata;
+
+    pa_assert(u);
+    pa_assert(u->active_mixer);
+
+    if (!get_mute(u->active_mixer, &sw))
+        s->muted = !sw;
+}
+
+static void sink_set_mute_cb(pa_sink *s) {
+    struct userdata *u = global_userdata;
+    int err;
+
+    pa_assert(u);
+    pa_assert(u->active_mixer);
+    pa_assert(u->active_mixer->mixer_elem);
+
+    if ((err = snd_mixer_selem_set_playback_switch_all(u->active_mixer->mixer_elem, !s->muted)) < 0) {
+        pa_log_error("Unable to set switch: %s", snd_strerror(err));
+        return;
+    }
+}
+
+static struct mixer_control_t* get_mixer_elem_by_name(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
+
+    for (m = u->mixer_list; m; m = m->next) {
+        if (strcmp(mixer, m->name) == 0)
+            return m;
+    }
+
+    return NULL;
+}
+
+static int load_mixer_tuning(struct userdata *u, struct mixer_control_t *m);
+
+static int set_control_mixer_elem(struct userdata *u, struct mixer_control_t *m) {
+    pa_assert(u);
+    pa_assert(m);
+
+    pa_log_info("%s: setting active mixer to %s", u->device_name, m->name);
+    load_mixer_tuning(u, m);
+
+    if (!m->tuning_table_filled) {
+        pa_log_info("No tuning table filled for %s mixer", m->name);
+        if (m->hw_dB_supported) {
+            pa_log_info("Using ALSA dB info to fill tuning table for %s mixer", m->name);
+            fill_tuning_table_from_dB_info(m);
+            m->tuning_table_filled = TRUE;
+        }
+        else {
+            pa_log_warn("No tuning table or ALSA dB info for %s, this is bad (assuming 0 - -60dB range)",
+                        m->name);
+            m->tuning_table_max = m->tuning_table_allocated_length-1;
+            fill_tuning_table_range(m, 0, m->tuning_table_max, -6000, 0);
+            m->tuning_table_filled = TRUE;
+            u->sink->n_volume_steps = m->tuning_table_max+1;
+        }
+    }
+
+    if (snd_mixer_selem_has_playback_switch(m->mixer_elem)) {
+        u->sink->get_mute = sink_get_mute_cb;
+        u->sink->set_mute = sink_set_mute_cb;
+        u->sink->flags |= PA_SINK_HW_MUTE_CTRL;
+    } else {
+        pa_log_info("Using software mute control for mixer %s.", m->name);
+        u->sink->flags &= ~PA_SINK_HW_MUTE_CTRL;
+        u->sink->get_mute = NULL;
+        u->sink->set_mute = NULL;
+    }
+
+    u->active_mixer = m;
+    return 0;
+}
+
+static int set_control_mixer_elem_by_name(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
+
+    m = get_mixer_elem_by_name(u, mixer);
+
+    if (!m) {
+        pa_log_info("%s: no preloaded mixer %s found", u->device_name, mixer);
+
+        return 1;
+    }
+
+    return set_control_mixer_elem(u, m);
+}
+
+static struct mixer_control_t* get_mixer_element(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
+    snd_mixer_elem_t *mixer_elem;
+    pa_channel_map map;
+    pa_assert(u);
+    pa_assert(u->sink);
+
+    if (u->mixer_handle) {
+        /* Try using mixer as both primary and fallback mixer, to ensure mixer selection
+         * even when mixer doesn't have both volume and mute switches */
+        if (!(mixer_elem = pa_alsa_find_elem(u->mixer_handle, mixer, mixer, TRUE))) {
+            pa_log_error("%s: could not select mixer %s at all", u->device_name, mixer);
+            goto fail;
+        }
+    } else {
+        pa_log_error("%s: No mixer handle.", u->device_name);
+        goto fail;
+    }
+
+    m = pa_xnew0(struct mixer_control_t, 1);
+    PA_LLIST_INIT(struct mixer_control_t, m);
+
+    m->name = pa_xstrdup(mixer);
+    m->mixer_elem = mixer_elem;
+
+    if (!snd_mixer_selem_has_playback_volume(m->mixer_elem)) {
+        pa_log_error("%s: Mixer %s has no playback volume", u->device_name, mixer);
+        goto fail;
+    }
+
+    if (snd_mixer_selem_get_playback_volume_range(m->mixer_elem, &m->hw_volume_min, &m->hw_volume_max) < 0) {
+        pa_log_info("Failed to get volume range. Falling back to software volume control.");
+        goto fail;
+    }
+
+    if (m->hw_volume_min >= m->hw_volume_max) {
+        pa_log_warn("Bad mixer range: %ld - %ld.", m->hw_volume_min, m->hw_volume_max);
+        goto fail;
+    }
+
+    if (snd_mixer_selem_get_playback_dB_range(m->mixer_elem, &m->hw_dB_min, &m->hw_dB_max) < 0) {
+        pa_log_info("Mixer doesn't not have dB information.");
+    }
+    else {
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+        VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_min, sizeof(m->hw_dB_min));
+        VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_max, sizeof(m->hw_dB_max));
+#endif
+        if (m->hw_dB_min >= m->hw_dB_max)
+            pa_log_warn("Bad dB range: %0.2f dB - %0.2f dB.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
+        else {
+            pa_log_info("Volume dB range: %0.2f dB - %0.2f dB.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
+            m->hw_dB_supported = TRUE;
+        }
+    }
+
+    map = u->sink->channel_map;
+    m->mixer_separate_channels = (pa_alsa_calc_mixer_map(m->mixer_elem, &map, m->mixer_map, TRUE) >= 0);
+
+    /* Initalize some sane values to hardware_volume */
+    pa_cvolume_set(&m->hardware_volume, u->sink->sample_spec.channels, PA_VOLUME_MUTED);
+
+    m->mixer_fdl = pa_alsa_fdlist_new();
+
+    if (pa_alsa_fdlist_set_mixer(m->mixer_fdl, u->mixer_handle, u->core->mainloop) < 0) {
+        pa_log("Failed to initialize file descriptor monitoring");
+        goto fail;
+    }
+
+    m->tuning_table_filled = FALSE;
+    m->tuning_table_allocated_length = m->hw_volume_max - m->hw_volume_min + 1;
+    if (m->tuning_table_allocated_length > MAX_VALUE_STEPS) {
+        pa_log_error("Too many mixer steps: %ld - %ld", m->hw_volume_max, m->hw_volume_min);
+        goto fail;
+    }
+
+    m->tuning_table_max = 0;
+    m->tuning_table = pa_xmalloc0(m->tuning_table_allocated_length * sizeof(long));
+    pa_assert(m->tuning_table);
+
+    snd_mixer_elem_set_callback(m->mixer_elem, mixer_callback);
+    snd_mixer_elem_set_callback_private(m->mixer_elem, u);
+
+    pa_log_info("%s: new mixer accepted: %s", u->device_name, m->name);
+    pa_log_debug("%s: mixer %s hw range %ld - %ld, alsa mB range %ld - %ld", u->device_name, m->name,
+                 m->hw_volume_min, m->hw_volume_max, m->hw_dB_min, m->hw_dB_max);
+
+    return m;
+ fail:
+    if (m) {
+        if (m->mixer_fdl) {
+            pa_alsa_fdlist_free(m->mixer_fdl);
+            m->mixer_fdl = NULL;
+        }
+
+        pa_xfree(m);
+    }
+
+    return NULL;
+}
+
+/** Load mixers using comma separated string list.
+ *
+ * return number of successfully loaded mixer elements
+ */
+static int get_mixer_elements(struct userdata *u, const char *mixer_list) {
+    const char *state = NULL;
+    struct mixer_control_t *m = NULL;
+    int count = 0;
+    char *mixer;
+    pa_assert(u);
+    pa_assert(mixer_list);
+
+    while ((mixer = pa_split(mixer_list, ",", &state))) {
+        if (mixer) {
+            m = get_mixer_element(u, mixer);
+            if (m) {
+                PA_LLIST_PREPEND(struct mixer_control_t, u->mixer_list, m);
+                count++;
+            }
+            pa_xfree(mixer);
+        }
+    }
+
+    return count;
+}
+
+static void free_mixer_element(struct mixer_control_t *m) {
+    pa_xfree(m->name);
+    pa_alsa_fdlist_free(m->mixer_fdl);
+    m->mixer_elem = NULL;
+
+    if (m->tuning_table) {
+        pa_xfree(m->tuning_table);
+        m->tuning_table = NULL;
+    }
+
+    pa_xfree(m);
+}
+
+static void free_mixer_elements(struct userdata *u) {
+    struct mixer_control_t *m;
+    pa_log_debug("free mixer elements");
+
+    u->active_mixer = NULL;
+
+    while ((m = u->mixer_list)) {
+        PA_LLIST_REMOVE(struct mixer_control_t, u->mixer_list, m);
+        free_mixer_element(m);
+    }
+}
+
+static void my_split(const char *src, const char *separator, const char **left, const char **right) {
+    const char *state = NULL;
+    char *str;
+
+    while ((str = pa_split(src, separator, &state))) {
+        if (str) {
+            if (!*left)
+                *left = str;
+            else if (!*right)
+                *right = str;
+            else
+                pa_xfree(str);
+        }
+    }
+}
+
+static int load_mixer_tuning(struct userdata *u, struct mixer_control_t *m) {
+    const char *tuning = NULL;
+    const char *element = NULL;
+    const char *mixer_name = NULL;
+    const char *element_state = NULL;
+    uint element_count = 0;
+    const char *error = NULL;
+    /* Gcc is not clever enough to see these are initialized before use. */
+    long prev_hw_vol = -1;
+    long prev_mB_vol = -1;
+    long hw_vol = -1;
+    long mB_vol = -1;
+    pa_assert(u);
+    pa_assert(m);
+
+    m->tuning_table_filled = FALSE;
+
+    tuning = pa_proplist_gets(u->sink->proplist, PROP_MIXER_TUNING);
+    if (!tuning) {
+        pa_log_debug("Could not find mixer tuning");
+        return -1;
+    }
+
+    pa_log_debug("Parsing mixer tuning: %s", tuning);
+
+    /* The mixer tuning should look like this "HP DAC=5:-6000,50:-3000,110:0" where the
+       first value in ":" separated pair is HW register value and the second value
+       is the corresponding millibel value. The register valued should be in
+       increasing order. First HW value is lowes allowed volume and the last is the
+       highest. The millibel values between specified end points are interpolated. */
+    if ((mixer_name = pa_split(tuning, "=" , &element_state))) {
+        if (strcmp(mixer_name, m->name) != 0) {
+            pa_log_info("Found tuning table is not for this mixer %s != %s",
+                        mixer_name, m->name);
+            return -1;
+        }
+    } else {
+        pa_log_info("Can not extract mixer name from tuning, assuming it is for %s", m->name);
+        element_state = NULL;
+    }
+
+    while ((element = pa_split(tuning, "," , &element_state))) {
+        const char *value = NULL;
+        const char *value_state = NULL;
+        enum { FIELD_HW_VOL = 0, FIELD_MB_VOL, FIELD_END } field = FIELD_HW_VOL;
+        int hw = -1, mB = -1;
+        element_count++;
+        while ((value = pa_split(element, ":" , &value_state))) {
+            switch (field) {
+            case FIELD_HW_VOL:
+                if (pa_atoi(value, &hw))
+                    error = value;
+                break;
+            case FIELD_MB_VOL:
+                if (pa_atoi(value, (int*)&mB))
+                    error = value;
+                break;
+                /* Add more fileds to implement slave mixers */
+            default:
+                pa_log_warn("Too many fields in element %d of mixer tuning: %s (ignoring)",
+                            element_count, element);
+            }
+            if (error)
+                break;
+            pa_xfree((void *)value);
+            field++;
+        }
+        if (error) {
+            pa_log_error("Can't parse \"%s\" in field %d of element %d in: %s",
+                         error, field, element_count, tuning);
+            pa_xfree((void *)error);
+            pa_xfree((void *)element);
+            return -1;
+        }
+
+        hw_vol = (long)hw;
+        mB_vol = (long)mB;
+
+        if (hw_vol < m->hw_volume_min || hw_vol > m->hw_volume_max) {
+            pa_log_error("Bad hw vol value %ld in element %d", hw_vol, element_count);
+            pa_xfree((void *)element);
+            return -1;
+        }
+
+        if (element_count == 1) {
+            m->tuned_volume_min = hw_vol;
+        } else {
+            if (prev_hw_vol > hw_vol || prev_mB_vol > mB_vol) {
+                pa_log_error("The tuning values should be in increasing order, problem with element %d of %s",
+                             element_count, tuning);
+                pa_xfree((void *)element);
+                return -1;
+            }
+            fill_tuning_table_range(m, prev_hw_vol - m->tuned_volume_min, hw_vol - m->tuned_volume_min,
+                                    prev_mB_vol, mB_vol);
+        }
+        prev_hw_vol = hw_vol;
+        prev_mB_vol = mB_vol;
+        pa_xfree((void *)element);
+    }
+    if (element_count < 2) {
+        pa_log_error("Too few element in tuning table %s", tuning);
+        return -1;
+    }
+
+    m->tuned_volume_max = hw_vol;
+    m->tuning_table_max = m->tuned_volume_max - m->tuned_volume_min;
+    m->tuning_table_filled = TRUE;
+    return 0;
+}
+
+/** Set mixer state using colon separated MIXER:STATE pair.
+ */
+static int set_mixer_state(struct userdata *u, const char *value_str) {
+    int ret = 0;
+    struct mixer_control_t *m = NULL;
+    const char *mode = NULL;
+    const char *mixer = NULL;
+
+    my_split(value_str, ":", &mixer, &mode);
+
+    if (mixer && mode && (m = get_mixer_elem_by_name(u, mixer))) {
+
+        if (strcmp(mode, PROP_MIXER_CONTROL) == 0) {
+            if (set_control_mixer_elem(u, m)) {
+                pa_log_error("%s: Setting control mixer %s failed", u->device_name, mixer);
+                ret = -1;
+            }
+        } else if (FALSE && strcmp(mode, PROP_MIXER_SLAVE) == 0) {
+            /* Implement slave mode here */
+        } else {
+            int err;
+            /* By default mute all mixers. */
+            int hw_volume = (long)m->hw_volume_min;
+            pa_bool_t mute_state = TRUE;
+            m->mode = MM_UNUSED;
+
+            if (strcmp(mode, PROP_MIXER_SLAVE) == 0) {
+                pa_log("%s: set mixer %s slave: slave mode unimplemented (muting)", u->device_name, mixer);
+                ret = 1;
+            } else if (strcmp(mode, PROP_MIXER_OFF) == 0) {
+                pa_log_debug("%s: set mixer %s off", u->device_name, mixer);
+                m->mode = MM_STATIC;
+            } else if (strcmp(mode, PROP_MIXER_MAX) == 0) {
+                pa_log_debug("%s: set mixer %s to max", u->device_name, mixer);
+                m->mode = MM_STATIC;
+                mute_state = FALSE;
+                hw_volume = m->hw_volume_max;
+            } else {
+                if (pa_atoi(mode, &hw_volume) == 0 &&
+                    hw_volume >= m->hw_volume_min && hw_volume <= m->hw_volume_max) {
+                    pa_log_debug("%s: set mixer %s to %d", u->device_name, mixer, hw_volume);
+                }
+                else {
+                    pa_log_error("%s: Bad mode for mixer %s: %s (muting)", u->device_name, mixer, mode);
+                    ret = 1;
+                }
+            }
+
+            if (snd_mixer_selem_has_playback_switch(m->mixer_elem))  {
+                if ((err = snd_mixer_selem_set_playback_switch_all(m->mixer_elem, !mute_state)) < 0) {
+                    pa_log_error("%s: Setting mute state of %s to %d failed: %s",
+                                 u->device_name, mixer, mute_state, snd_strerror(err));
+                }
+            }
+
+            if ((err = snd_mixer_selem_set_playback_volume_all(m->mixer_elem, (long)hw_volume)) < 0) {
+                pa_log_error("%s: Setting volume of %s to %d failed: %s",
+                             u->device_name, mixer, hw_volume, snd_strerror(err));
+            }
+        }
+    } else {
+        pa_log_error("%s: Bad mixer mode entry %s", u->device_name, value_str);
+    }
+
+    if (mixer)
+        pa_xfree((void*)mixer);
+    if (mode)
+        pa_xfree((void*)mode);
+
+    return ret;
+}
+
+static void store_active_mixer_volume(struct userdata *u);
+
+/** Parse mixer control list.
+ *
+ * Parses comma separated list of MIXER:STATE pairs.
+ */
+static int update_mixer_setup(struct userdata *u, const char *value_list) {
+    int ret = 0;
+    const char *state = NULL;
+    char *value;
+
+    pa_assert(u);
+    pa_assert(u->sink);
+
+    /* store volumes from currently active mixer */
+    store_active_mixer_volume(u);
+
+    while ((value = pa_split(value_list, ",", &state))) {
+        if (value) {
+            int err = set_mixer_state(u, value);
+            pa_xfree(value);
+            if (err < 0) {
+                ret = err;
+                break;
+            }
+            ret += err;
+        }
+    }
+
+    if (ret > 0)  {
+        pa_log_warn("Setting mixer state for %d mixers failed", ret);
+    }
+
+    /* update previously stored volumes to sink */
+    if (u->active_mixer) {
+        if (u->active_mixer->cache_volume.channels > 0) {
+            pa_sink_set_volume(u->sink, &u->active_mixer->cache_volume, TRUE, TRUE);
+            pa_sink_set_mute(u->sink, u->active_mixer->cache_muted);
+        } else {
+            /* no previously stored volumes, update volume from hw */
+            /* this should never happen, we set default for every mixer
+               in load_mixer_volumes(), but reading from hw is definately a bad
+               idea. Let's use default values.
+            */
+            pa_cvolume cvol;
+            pa_cvolume_set(&cvol, u->sink->sample_spec.channels,
+                           pa_sw_volume_from_dB(DEFAULT_MIXER_DB_VALUE_ON_FIRST_BOOT));
+            pa_sink_set_volume(u->sink, &cvol, TRUE, TRUE);
+            pa_sink_set_mute(u->sink, FALSE);
+        }
+    } else {
+        pa_log_error("No active mixer, THIS IS BAD!");
+        ret = -1;
+    }
+
+    return ret;
+}
+
+static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
+    const char *v = NULL;
+
+    if (s != u->sink) {
+        return PA_HOOK_OK;
+    }
+
+    pa_assert(u);
+    pa_assert(s);
+
+    v = pa_proplist_gets(s->proplist, PROP_MIXER);
+    if (v) {
+        update_mixer_setup(u, v);
+    }
+
+    return PA_HOOK_OK;
+}
+
+static int init_volume_cache(struct userdata *u) {
+    char *fn;
+    char *fname;
+    int gdbm_cache_size;
+
+    /* We include the host identifier in the file name because gdbm
+     * files are CPU dependant, and we don't want things to go wrong
+     * if we are on a multiarch system. */
+
+    fn = pa_sprintf_malloc("%s:mixer-volumes."CANONICAL_HOST".gdbm", u->device_name);
+    fname = pa_state_path(fn, TRUE);
+    pa_xfree(fn);
+
+    if (!fname)
+        return 1;
+
+    if (!(u->gdbm_file = gdbm_open(fname, 0, GDBM_WRCREAT|GDBM_NOLOCK, 0600, NULL))) {
+        pa_log("Failed to open volume database '%s': %s", fname, gdbm_strerror(gdbm_errno));
+        pa_xfree(fname);
+        return 1;
+    }
+
+    /* By default the cache of gdbm is rather large, let's reduce it a bit to save memory */
+    gdbm_cache_size = 10;
+    gdbm_setopt(u->gdbm_file, GDBM_CACHESIZE, &gdbm_cache_size, sizeof(gdbm_cache_size));
+
+    pa_log_info("%s: Sucessfully opened database file '%s'.", u->device_name, fname);
+    pa_xfree(fname);
+
+    u->cache_volumes = TRUE;
+
+    return 0;
+}
+
+static struct entry* read_entry(struct userdata *u, const char *name) {
+    datum key, data;
+    struct entry *e;
+
+    pa_assert(u);
+    pa_assert(name);
+
+    key.dptr = (char*) name;
+    key.dsize = (int) strlen(name);
+
+    data = gdbm_fetch(u->gdbm_file, key);
+
+    if (!data.dptr)
+        goto fail;
+
+    if (data.dsize != sizeof(struct entry)) {
+        pa_log_debug("Database contains entry for device %s of wrong size %lu != %lu. Probably due to upgrade, ignoring.", name, (unsigned long) data.dsize, (unsigned long) sizeof(struct entry));
+        goto fail;
+    }
+
+    e = (struct entry*) data.dptr;
+
+    if (e->version != ENTRY_VERSION) {
+        pa_log_debug("Version of database entry for device %s doesn't match our version. Probably due to upgrade, ignoring.", name);
+        goto fail;
+    }
+
+    if (!(pa_cvolume_valid(&e->volume))) {
+        pa_log_warn("Invalid volume stored in database for device %s", name);
+        goto fail;
+    }
+
+    return e;
+
+fail:
+
+    pa_xfree(data.dptr);
+    return NULL;
+}
+
+/* TODO: I don't think the active mixer name should be the key for stored volume,
+   audio mode ("x-maemo.mode") would serve purpose much better. */
+static int store_mixer_volume(struct userdata *u, struct mixer_control_t *m) {
+    struct entry entry;
+    char *name;
+    datum key, data;
+
+    pa_assert(u);
+    pa_assert(m);
+
+    memset(&entry, 0, sizeof(entry));
+    entry.version = ENTRY_VERSION;
+
+    name = pa_xstrdup(m->name);
+    entry.volume = m->cache_volume;
+    entry.muted = m->cache_muted;
+
+    key.dptr = name;
+    key.dsize = (int)strlen(name);
+
+    data.dptr = (void*) &entry;
+    data.dsize = sizeof(entry);
+
+    gdbm_store(u->gdbm_file, key, data, GDBM_REPLACE);
+
+    pa_xfree(name);
+
+    return 0;
+}
+
+/** Load mixer values either from gdbm or current hw mixer levels.
+ *
+ * Might leave active_mixer in different state than before calling,
+ * so make sure to set correct mixer after calling this.
+ */
+static int load_mixer_volumes(struct userdata *u) {
+    struct mixer_control_t *m = NULL;
+    struct entry *entry = NULL;
+    int values_read = 0;
+    pa_assert(u);
+    pa_assert(u->sink);
+
+    for (m = u->mixer_list; m; m = m->next) {
+
+        if (u->cache_volumes)
+            entry = read_entry(u, m->name);
+
+        if (entry && entry->volume.channels > 0) {
+            m->cache_volume = entry->volume;
+            m->cache_muted = entry->muted;
+            pa_log_info("%s: load volume for mixer %s: %d", u->device_name, m->name, m->cache_volume.values[0]);
+            values_read++;
+        } else {
+            /* Use default value if we have nothing in cache. */
+            pa_log_info("Value for mixer %s not found from cache, using default values.", m->name);
+            pa_cvolume_set(&m->cache_volume, u->sink->sample_spec.channels,
+                           pa_sw_volume_from_dB(DEFAULT_MIXER_DB_VALUE_ON_FIRST_BOOT));
+            m->cache_muted = FALSE;
+        }
+
+        if (entry)
+            pa_xfree(entry);
+    }
+
+    return values_read;
+}
+
+static void store_active_mixer_volume(struct userdata *u) {
+    struct mixer_control_t *m = u->active_mixer;
+    pa_assert(u);
+
+    if (!m) {
+        pa_log_warn("No active mixer, nothing to store");
+        return;
+    }
+
+    if (!u->sink) {
+        pa_log_debug("The sink was already unloaded, storing cached values");
+    }
+    else {
+        m->cache_volume = *pa_sink_get_volume(u->sink, TRUE);
+        m->cache_muted = pa_sink_get_mute(u->sink, TRUE);
+    }
+
+    if (u->cache_volumes) {
+        store_mixer_volume(u, m);
+        /* sync immediately */
+        gdbm_sync(u->gdbm_file);
+        pa_log_info("%s: Synced.", u->device_name);
+    }
+}
+
+
+static pa_hook_result_t sink_unlink_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
+
+    if (s != u->sink) {
+        return PA_HOOK_OK;
+    }
+
+    u->sink = NULL;
+
+    return PA_HOOK_OK;
+}
+
+int pa__init(pa_module*m) {
+
+    pa_sink *hw_sink = NULL;
+    pa_modargs *ma = NULL;
+    struct userdata *u = NULL;
+    char *alsa_mixer = NULL;
+    char *mixer_load = NULL;
+    int err;
+    const char *sink_name;
+
+    pa_assert(m);
+
+    if (global_userdata != NULL)  {
+        pa_log_error("There can only be one instance of module: %s", m->name);
+        pa_log_info("The existing instace is connected to: %s", global_userdata->sink->name);
+        goto fail;
+    }
+
+    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+        pa_log("Failed to parse module arguments");
+        goto fail;
+    }
+
+    sink_name = pa_modargs_get_value(ma, "sink_name", NULL);
+    if (!sink_name) {
+        pa_log("No sink_name defined.");
+        goto fail;
+    }
+
+    hw_sink = pa_namereg_get(m->core, sink_name, PA_NAMEREG_SINK);
+    if (!hw_sink) {
+        pa_log("Couldn't get sink with name %s", sink_name);
+        goto fail;
+    }
+
+    alsa_mixer = pa_xstrdup(pa_modargs_get_value(ma, "mixer", "Master"));
+    replace_chars(alsa_mixer, '_', ' ');
+
+    if (pa_modargs_get_value(ma, "mixer_load", NULL)) {
+        mixer_load = pa_xstrdup(pa_modargs_get_value(ma, "mixer_load", NULL));
+        replace_chars(mixer_load, '_', ' ');
+        pa_log_info("preload mixers %s", mixer_load);
+    } else {
+        /* Default to loading alsa_mixer, if mixer_load is not defined. */
+        mixer_load = pa_xstrdup(alsa_mixer);
+    }
+
+    u = pa_xnew0(struct userdata, 1);
+    u->core = m->core;
+    u->module = m;
+    m->userdata = u;
+
+    global_userdata = u;
+
+    u->sink = hw_sink;
+
+    /* get orignal variable values from sink */
+    u->original_flags = u->sink->flags;
+    u->original_get_volume = u->sink->get_volume;
+    u->original_set_volume = u->sink->set_volume;
+    u->original_get_mute = u->sink->get_mute;
+    u->original_set_mute = u->sink->set_mute;
+
+    if (pa_modargs_get_value(ma, "device", NULL))
+        u->device_name = pa_xstrdup(pa_modargs_get_value(ma, "device", NULL));
+    else if (pa_proplist_gets(u->sink->proplist, PA_PROP_DEVICE_STRING))
+        u->device_name = pa_xstrdup(pa_proplist_gets(u->sink->proplist, PA_PROP_DEVICE_STRING));
+
+    if (!u->device_name) {
+        pa_log("No device name defined or detected from sink");
+        goto fail;
+    }
+
+    if ((err = snd_mixer_open(&u->mixer_handle, 0)) < 0) {
+        pa_log("Error opening mixer: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if (pa_alsa_prepare_mixer(u->mixer_handle, u->device_name) < 0) {
+        pa_log("couldn't prepare mixer with %s", u->device_name);
+        snd_mixer_close(u->mixer_handle);
+        u->mixer_handle = NULL;
+        goto fail;
+    }
+
+    if (get_mixer_elements(u, mixer_load) <= 0) {
+        pa_log_error("No suitable mixer elements found, no point to continue");
+        goto fail;
+    }
+
+    /* TODO: Read from parameters and/or modargs */
+    u->sw_vol_compensation = TRUE;
+
+    init_volume_cache(u);
+    load_mixer_volumes(u);
+
+    /* This just breaks the default setup */
+    //pa_proplist_sets(u->sink->proplist, PROP_MIXER, "(none)");
+
+    /* hook in case the sink is unloaded */
+    u->sink_unlink_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_UNLINK],
+                                          PA_HOOK_LATE,
+                                          (pa_hook_cb_t)sink_unlink_hook_callback, u);
+
+    /* hook for mixer switching */
+    u->sink_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_PROPLIST_CHANGED],
+                                                    PA_HOOK_LATE,
+                                                    (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
+
+    /* Try to load the initial mixer settings. */
+    (void)sink_proplist_changed_hook_callback(u->core, u->sink, u);
+
+    if (!u->active_mixer) {
+        pa_log_info("No control mixer found from initial settings, selecting default %s", alsa_mixer);
+        if (set_control_mixer_elem_by_name(u, alsa_mixer)) {
+            pa_log_error("Unable set control mixer %s", alsa_mixer);
+            goto fail;
+        }
+        else {
+            char *tmp = pa_sprintf_malloc("%s:%s", u->active_mixer->name, PROP_MIXER_CONTROL);
+            pa_proplist_sets(u->sink->proplist, PROP_MIXER, tmp);
+            pa_xfree(tmp);
+            pa_log_debug("%s: update active mixer volume", u->device_name);
+            pa_sink_set_volume(u->sink, &u->active_mixer->cache_volume, TRUE, TRUE);
+            pa_sink_set_mute(u->sink, u->active_mixer->cache_muted);
+        }
+    }
+
+    /* Everything should be in order, write new volume callbacks */
+    u->sink->flags = u->original_flags | PA_SINK_HW_VOLUME_CTRL | PA_SINK_DECIBEL_VOLUME;
+    u->sink->get_volume = sink_get_volume_cb;
+    u->sink->set_volume = sink_set_volume_cb;
+
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
+    if (mixer_load)
+        pa_xfree(mixer_load);
+
+    pa_modargs_free(ma);
+
+    return 0;
+
+ fail:
+
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
+    if (mixer_load)
+        pa_xfree(mixer_load);
+
+    if (ma)
+        pa_modargs_free(ma);
+
+    pa__done(m);
+
+    return -1;
+}
+
+void pa__done(pa_module*m) {
+    struct userdata *u;
+
+    pa_assert(m);
+
+    if (!(u = m->userdata))
+        return;
+
+    if (u->sink_proplist_changed_slot)
+        pa_hook_slot_free(u->sink_proplist_changed_slot);
+    if (u->sink_unlink_slot)
+        pa_hook_slot_free(u->sink_unlink_slot);
+
+    if (u->cache_volumes)
+        store_active_mixer_volume(u);
+
+    if (u->mixer_list)
+        free_mixer_elements(u);
+
+    if (u->gdbm_file)
+        gdbm_close(u->gdbm_file);
+
+    if (u->mixer_handle)
+        snd_mixer_close(u->mixer_handle);
+
+    /* Restore original volume controls, if the sink is still there */
+    if (u->sink) {
+        u->sink->flags = u->original_flags;
+        u->sink->get_volume = u->original_get_volume;
+        u->sink->set_volume = u->original_set_volume;
+        u->sink->get_mute = u->original_get_mute;
+        u->sink->set_mute = u->original_set_mute;
+        pa_sink_get_volume(u->sink, TRUE);
+        pa_sink_get_mute(u->sink, TRUE);
+    }
+
+    global_userdata = NULL;
+
+    pa_xfree(u->device_name);
+    pa_xfree(u);
+
+    snd_config_update_free_global();
+}
-- 
1.6.2.rc1.13.gfd76c.dirty

