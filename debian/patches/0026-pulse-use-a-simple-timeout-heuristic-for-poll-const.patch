From cfb6584c963ebf48c6a297c90f576f40d8348b53 Mon Sep 17 00:00:00 2001
From: =?utf-8?q?Marc-Andr=C3=A9=20Lureau?= <marc-andre.lureau@nokia.com>
Date: Tue, 3 Mar 2009 15:50:46 +0200
Subject: [PATCH 26/27] pulse: use a simple timeout heuristic for poll construction

---
 src/pulse/mainloop.c |   84 ++++++++++++++++++++++++++++++++++++++++++++++++--
 1 files changed, 81 insertions(+), 3 deletions(-)

diff --git a/src/pulse/mainloop.c b/src/pulse/mainloop.c
index 3403a6f..69b3067 100644
--- a/src/pulse/mainloop.c
+++ b/src/pulse/mainloop.c
@@ -68,6 +68,8 @@ struct pa_io_event {
     void *userdata;
     pa_io_event_destroy_cb_t destroy_callback;
 
+    struct timeval last_wakeup_time;
+
     PA_LLIST_FIELDS(pa_io_event);
 };
 
@@ -109,6 +111,8 @@ struct pa_mainloop {
     pa_bool_t rebuild_pollfds:1;
     struct pollfd *pollfds;
     unsigned max_pollfds, n_pollfds;
+    pa_time_event *rebuild_full_pollfds_time;
+    pa_bool_t rebuild_full_pollfds;
 
     int prepared_timeout;
     pa_time_event *cached_next_time_event;
@@ -182,6 +186,8 @@ static pa_io_event* mainloop_io_new(
     e->userdata = userdata;
     e->destroy_callback = NULL;
 
+    pa_gettimeofday(&e->last_wakeup_time);
+
 #ifdef OS_IS_WIN32
     {
         fd_set xset;
@@ -447,8 +453,25 @@ static const pa_mainloop_api vtable = {
     .quit = mainloop_quit,
 };
 
+#define FULL_POLL_INTERVAL (100 * PA_USEC_PER_MSEC)
+
+static void rebuild_full_pollfds_cb(pa_mainloop_api *a, pa_time_event *e, const struct timeval *tv, void *userdata) {
+    pa_mainloop *m;
+    struct timeval now;
+
+    pa_assert_se(m = userdata);
+
+    pa_log("** timeout **");
+    /* make sure the full poll is rebuild */
+    m->rebuild_full_pollfds = TRUE;
+    m->rebuild_pollfds = TRUE;
+    
+    mainloop_time_restart(m->rebuild_full_pollfds_time, pa_timeval_add(pa_gettimeofday(&now), FULL_POLL_INTERVAL));
+}
+
 pa_mainloop *pa_mainloop_new(void) {
     pa_mainloop *m;
+    struct timeval now;
 
     pa_init_i18n();
 
@@ -493,6 +516,9 @@ pa_mainloop *pa_mainloop_new(void) {
     m->poll_func_userdata = NULL;
     m->poll_func_ret = -1;
 
+    m->rebuild_full_pollfds_time = mainloop_time_new(&m->api, pa_timeval_add(pa_gettimeofday(&now), FULL_POLL_INTERVAL), rebuild_full_pollfds_cb, m);
+    m->rebuild_full_pollfds = TRUE;
+
     return m;
 }
 
@@ -651,6 +677,41 @@ static void rebuild_pollfds(pa_mainloop *m) {
         m->n_pollfds++;
     }
 
+#if 1
+    {
+        struct timeval now;
+
+        pa_gettimeofday(&now);
+
+        /* we only check those who woke up under the 1/10th of second */
+        if (!m->rebuild_full_pollfds) {
+
+            for (e = m->io_events; e; e = e->next) {
+                if (e->dead) {
+                    e->pollfd = NULL;
+                    continue;
+                }
+
+                if (pa_timeval_diff(&now, &e->last_wakeup_time) >= FULL_POLL_INTERVAL) {
+                    e->pollfd = NULL;
+                    continue;
+                }
+
+                e->pollfd = p;
+                p->fd = e->fd;
+                p->events = map_flags_to_libc(e->events);
+                p->revents = 0;
+
+                p++;
+                m->n_pollfds++;
+            }
+
+            m->rebuild_pollfds = FALSE;
+            goto end;
+        }
+    }
+#endif
+
     for (e = m->io_events; e; e = e->next) {
         if (e->dead) {
             e->pollfd = NULL;
@@ -664,17 +725,33 @@ static void rebuild_pollfds(pa_mainloop *m) {
 
         p++;
         m->n_pollfds++;
+
+        m->rebuild_full_pollfds = FALSE;
     }
 
-    m->rebuild_pollfds = FALSE;
+    pa_log("full poll build: %d", m->n_pollfds);
+    m->rebuild_pollfds = TRUE;
+
+end:
+    if (m->n_pollfds >= m->n_io_events) {
+        pa_log("Disabling full rebuild timeout");
+        mainloop_time_restart(m->rebuild_full_pollfds_time, NULL);
+    } else if (!m->rebuild_full_pollfds_time->enabled) {
+        struct timeval now;
+        mainloop_time_restart(m->rebuild_full_pollfds_time, pa_timeval_add(pa_gettimeofday(&now), FULL_POLL_INTERVAL));
+    }
+    return;
 }
 
 static int dispatch_pollfds(pa_mainloop *m) {
     pa_io_event *e;
     int r = 0, k;
+    struct timeval now;
 
     pa_assert(m->poll_func_ret > 0);
 
+    pa_gettimeofday(&now);
+
     for (e = m->io_events, k = m->poll_func_ret; e && !m->quit && k > 0; e = e->next) {
         if (e->dead || !e->pollfd || !e->pollfd->revents)
             continue;
@@ -683,6 +760,7 @@ static int dispatch_pollfds(pa_mainloop *m) {
         pa_assert(e->callback);
         e->callback(&m->api, e, e->fd, map_flags_from_libc(e->pollfd->revents), e->userdata);
         e->pollfd->revents = 0;
+        e->last_wakeup_time = now;
         r++;
 
         k--;
@@ -852,7 +930,7 @@ int pa_mainloop_poll(pa_mainloop *m) {
     if (m->n_enabled_defer_events )
         m->poll_func_ret = 0;
     else {
-        pa_assert(!m->rebuild_pollfds);
+        /* pa_assert(!m->rebuild_pollfds); */
 
 #if 1
 	{
@@ -867,7 +945,7 @@ int pa_mainloop_poll(pa_mainloop *m) {
             } PA_ONCE_END;
 
             if (pa_timeval_diff(pa_gettimeofday(&now), &start) >= PA_USEC_PER_SEC) {
-                pa_log_debug("Before poll(): %d nfds, %d Hz", m->n_pollfds, hz);
+                pa_log_debug("Before poll(): %d/%d nfds, %d Hz", m->n_pollfds, m->n_io_events, hz);
                 hz = 0;
                 pa_gettimeofday(&start);
             }
-- 
1.6.2.rc1.13.gfd76c.dirty

