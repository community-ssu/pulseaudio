From d0c16f1b1ff1edf0f0e57edf69f0cdef06d68de6 Mon Sep 17 00:00:00 2001
From: Jyri Sarha <jyri.sarha@nokia.com>
Date: Mon, 25 Aug 2008 18:51:01 +0300
Subject: [PATCH] alsa-sink: fix the busy loop on arm (Nokia specific)

---
 src/modules/module-alsa-sink.c |   16 +++++++++++++---
 1 files changed, 13 insertions(+), 3 deletions(-)

diff --git a/src/modules/module-alsa-sink.c b/src/modules/module-alsa-sink.c
index 6dea172..a7a7cbd 100644
--- a/src/modules/module-alsa-sink.c
+++ b/src/modules/module-alsa-sink.c
@@ -72,7 +72,8 @@ PA_MODULE_USAGE(
         "mmap=<enable memory mapping?> "
         "tsched=<enable system timer based scheduling mode?> "
         "tsched_buffer_size=<buffer size when using timer based scheduling> "
-        "tsched_buffer_watermark=<lower fill watermark>");
+        "tsched_buffer_watermark=<lower fill watermark> "
+        "hwbuf_min_frames_to_write=<minimum number of available frames in hwbuf to fill>");
 
 static const char* const valid_modargs[] = {
     "sink_name",
@@ -88,6 +89,7 @@ static const char* const valid_modargs[] = {
     "tsched",
     "tsched_buffer_size",
     "tsched_buffer_watermark",
+    "hwbuf_min_frames_to_write",
     NULL
 };
 
@@ -136,6 +138,7 @@ struct userdata {
     uint64_t since_start;
 
     snd_pcm_sframes_t hwbuf_unused_frames;
+    snd_pcm_sframes_t hwbuf_min_frames_to_write;
 };
 
 static void fix_tsched_watermark(struct userdata *u) {
@@ -283,7 +286,7 @@ static int mmap_write(struct userdata *u, pa_usec_t *sleep_usec, pa_bool_t polle
                 pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= u->hwbuf_unused_frames)) {
+        if (PA_UNLIKELY(n <= u->hwbuf_min_frames_to_write || n <= u->hwbuf_unused_frames)) {
 
             if (polled)
                 pa_log("ALSA woke us up to write new data to the device, but there was actually nothing to write! "
@@ -405,7 +408,7 @@ static int unix_write(struct userdata *u, pa_usec_t *sleep_usec, pa_bool_t polle
                 pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= u->hwbuf_unused_frames)) {
+        if (PA_UNLIKELY(n <= u->hwbuf_min_frames_to_write || n <= u->hwbuf_unused_frames)) {
 
             if (polled)
                 pa_log("ALSA woke us up to write new data to the device, but there was actually nothing to write! "
@@ -1251,6 +1254,7 @@ int pa__init(pa_module*m) {
     pa_bool_t use_mmap = TRUE, b, use_tsched = TRUE, d;
     pa_usec_t usec;
     pa_sink_new_data data;
+    int32_t hwbuf_min_frames_to_write = 0;
 
     snd_pcm_info_alloca(&pcm_info);
 
@@ -1305,6 +1309,11 @@ int pa__init(pa_module*m) {
         use_tsched = FALSE;
     }
 
+    if (pa_modargs_get_value_s32(ma, "hwbuf_min_frames_to_write", &hwbuf_min_frames_to_write) < 0) {
+        pa_log("Failed to parse hwbuf_min_frames_to_write argument");
+        goto fail;
+    }
+
     u = pa_xnew0(struct userdata, 1);
     u->core = m->core;
     u->module = m;
@@ -1459,6 +1468,7 @@ int pa__init(pa_module*m) {
     u->fragment_size = frag_size = (uint32_t) (period_frames * frame_size);
     u->nfragments = nfrags;
     u->hwbuf_size = u->fragment_size * nfrags;
+    u->hwbuf_min_frames_to_write = hwbuf_min_frames_to_write;
     u->hwbuf_unused_frames = 0;
     u->tsched_watermark = tsched_watermark;
     u->frame_index = 0;
-- 
1.6.0.2.514.g23abd3

