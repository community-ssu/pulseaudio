From d9c96a07672e0a8e12f4242dd7e8bddc9366fa38 Mon Sep 17 00:00:00 2001
From: =?utf-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@gmail.com>
Date: Wed, 4 Feb 2009 17:57:15 +0200
Subject: [PATCH 22/22] alsa-old: support dB and 0.9.15

---
 src/modules/alsa/module-alsa-sink-old.c   |  474 +++++++++++++++++++----------
 src/modules/alsa/module-alsa-source-old.c |  327 ++++++++++++++++----
 2 files changed, 572 insertions(+), 229 deletions(-)

diff --git a/src/modules/alsa/module-alsa-sink-old.c b/src/modules/alsa/module-alsa-sink-old.c
index af631ae..4caa9d5 100644
--- a/src/modules/alsa/module-alsa-sink-old.c
+++ b/src/modules/alsa/module-alsa-sink-old.c
@@ -32,6 +32,10 @@
 #include <pulse/xmalloc.h>
 #include <pulse/util.h>
 
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
 #include <pulsecore/core.h>
 #include <pulsecore/module.h>
 #include <pulsecore/memchunk.h>
@@ -83,11 +87,15 @@ struct mixer_control_t {
     snd_mixer_elem_t *mixer_elem;
     snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
     unsigned channels;
-    long hw_volume_max;
-    long hw_volume_min;
     unsigned gain_step_count;
     long *gain_step;
 
+    long hw_volume_max, hw_volume_min;
+    long hw_dB_max, hw_dB_min;
+    pa_bool_t hw_dB_supported;
+    pa_bool_t mixer_seperate_channels;
+    pa_cvolume hardware_volume;
+
     /* cache proplist strings */
     char *prop_mixer_gain_step;
     char *prop_mixer_gain_step_count;
@@ -136,6 +144,7 @@ struct userdata {
     pa_bool_t use_mmap;
 
     pa_bool_t first;
+    pa_bool_t ignore_dB;
 
     pa_rtpoll_item *alsa_rtpoll_item;
 };
@@ -249,7 +258,7 @@ static int mmap_write(struct userdata *u) {
             return -1;
         }
 
-/*         pa_log("Got request for %i samples", (int) n); */
+        /*         pa_log("Got request for %i samples", (int) n); */
 
         frames = n - (n % u->period_size);
 
@@ -315,7 +324,7 @@ static int mmap_write(struct userdata *u) {
         if (frames >= (snd_pcm_uframes_t) n)
             return work_done;
 
-/*         pa_log("wrote %i samples", (int) frames); */
+        /*         pa_log("wrote %i samples", (int) frames); */
     }
 }
 
@@ -344,7 +353,7 @@ static int unix_write(struct userdata *u) {
 
         l = snd_pcm_status_get_avail(status) * u->frame_size;
 
-/*         pa_log("%u bytes to write", l); */
+        /*         pa_log("%u bytes to write", l); */
 
         l = l - (l % u->fragment_size);
 
@@ -360,7 +369,7 @@ static int unix_write(struct userdata *u) {
         t = snd_pcm_writei(u->pcm_handle, (const uint8_t*) p + u->memchunk.index, u->memchunk.length / u->frame_size);
         pa_memblock_release(u->memchunk.memblock);
 
-/*         pa_log("wrote %i bytes of %u (%u)", t*u->frame_size, u->memchunk.length, l); */
+        /*         pa_log("wrote %i bytes of %u (%u)", t*u->frame_size, u->memchunk.length, l); */
 
         pa_assert(t != 0);
 
@@ -522,7 +531,7 @@ static int unsuspend(struct userdata *u) {
 
     return 0;
 
-fail:
+ fail:
     if (u->pcm_handle) {
         snd_pcm_close(u->pcm_handle);
         u->pcm_handle = NULL;
@@ -613,153 +622,248 @@ static int mixer_callback(snd_mixer_elem_t *elem, unsigned int mask) {
     return 0;
 }
 
-static int get_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *mixer, pa_cvolume *volume) {
+static pa_volume_t from_alsa_volume(struct userdata *u, long alsa_vol) {
+
+    return (pa_volume_t) round(((double) (alsa_vol - u->active_mixer->hw_volume_min) * PA_VOLUME_NORM) /
+                               (double) (u->active_mixer->hw_volume_max - u->active_mixer->hw_volume_min));
+}
+
+static long to_alsa_volume(struct userdata *u, pa_volume_t vol) {
+    long alsa_vol;
+
+    alsa_vol = (long) round(((double) vol * (double) (u->active_mixer->hw_volume_max - u->active_mixer->hw_volume_min))
+                            / PA_VOLUME_NORM) + u->active_mixer->hw_volume_min;
+
+    return PA_CLAMP_UNLIKELY(alsa_vol, u->active_mixer->hw_volume_min, u->active_mixer->hw_volume_max);
+}
+
+static void sink_get_volume_cb(pa_sink *s) {
+    struct userdata *u = s->userdata;
     int err;
-    int i;
+    unsigned i;
+    pa_cvolume r;
+    char t[PA_CVOLUME_SNPRINT_MAX];
 
     pa_assert(u);
-    pa_assert(mixer);
-    pa_assert(volume);
+    pa_assert(u->active_mixer->mixer_elem);
 
-    for (i = 0; i < u->sink->sample_spec.channels; i++) {
-        long set_vol = 0, vol = 0;
+    if (u->active_mixer->mixer_seperate_channels) {
 
-        pa_assert(snd_mixer_selem_has_playback_channel(mixer->mixer_elem, mixer->mixer_map[i]));
+        r.channels = u->sink->sample_spec.channels;
 
-        if ((err = snd_mixer_selem_get_playback_volume(mixer->mixer_elem, mixer->mixer_map[i], &vol)) < 0) {
-            pa_log_error("Unable to read volume: %s", snd_strerror(err));
-            return 1;
+        for (i = 0; i < u->sink->sample_spec.channels; i++) {
+            long alsa_vol;
+
+            if (u->active_mixer->hw_dB_supported) {
+
+                if ((err = snd_mixer_selem_get_playback_dB(u->active_mixer->mixer_elem, u->active_mixer->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+                r.values[i] = pa_sw_volume_from_dB((double) (alsa_vol - u->active_mixer->hw_dB_max) / 100.0);
+            } else {
+
+                if ((err = snd_mixer_selem_get_playback_volume(u->active_mixer->mixer_elem, u->active_mixer->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+                r.values[i] = from_alsa_volume(u, alsa_vol);
+            }
         }
 
-        set_vol = (long) roundf(((float) volume->values[i] * (mixer->hw_volume_max - mixer->hw_volume_min)) / PA_VOLUME_NORM) + mixer->hw_volume_min;
+    } else {
+        long alsa_vol;
+
+        if (u->active_mixer->hw_dB_supported) {
 
-        /* Try to avoid superfluous volume changes */
-        if (set_vol != vol) {
-            volume->values[i] = (pa_volume_t) roundf(((float) (vol - mixer->hw_volume_min) * PA_VOLUME_NORM) / (mixer->hw_volume_max - mixer->hw_volume_min));
+            if ((err = snd_mixer_selem_get_playback_dB(u->active_mixer->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+            pa_cvolume_set(&r, u->sink->sample_spec.channels, pa_sw_volume_from_dB((double) (alsa_vol - u->active_mixer->hw_dB_max) / 100.0));
+
+        } else {
+
+            if ((err = snd_mixer_selem_get_playback_volume(u->active_mixer->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+            pa_cvolume_set(&r, u->sink->sample_spec.channels, from_alsa_volume(u, alsa_vol));
         }
     }
 
-    return 0;
-}
+    pa_log_debug("Read hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &r));
 
-static int sink_get_volume_cb(pa_sink *s) {
-    struct userdata *u = s->userdata;
+    if (!pa_cvolume_equal(&u->active_mixer->hardware_volume, &r)) {
 
-    if (get_alsa_mixer_volumes(u, u->active_mixer, &s->volume)) {
-        s->get_volume = NULL;
-        s->set_volume = NULL;
-        return -1;
-    } else {
-        return 0;
+        s->virtual_volume = u->active_mixer->hardware_volume = r;
+
+        if (u->active_mixer->hw_dB_supported) {
+            pa_cvolume reset;
+
+            /* Hmm, so the hardware volume changed, let's reset our software volume */
+            pa_cvolume_reset(&reset, u->sink->sample_spec.channels);
+            pa_sink_set_soft_volume(s, &reset);
+        }
     }
+
+    return;
+
+ fail:
+    pa_log_error("Unable to read volume: %s", snd_strerror(err));
 }
 
-static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *mixer, const pa_cvolume *volume) {
+static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m, pa_cvolume *vv) {
     int err;
-    int i;
-    int step;
+    unsigned i;
+    pa_cvolume r;
 
     pa_assert(u);
-    pa_assert(mixer->mixer_elem);
+    pa_assert(m->mixer_elem);
 
-    for (i = 0; i < u->sink->sample_spec.channels; i++) {
-        long alsa_vol;
-        pa_volume_t vol;
+    if (m->mixer_seperate_channels) {
+
+        r.channels = u->sink->sample_spec.channels;
+
+        for (i = 0; i < u->sink->sample_spec.channels; i++) {
+            long alsa_vol;
+            pa_volume_t vol;
 
-        pa_assert(snd_mixer_selem_has_playback_channel(mixer->mixer_elem, mixer->mixer_map[i]));
+            vol = vv->values[i];
 
-        vol = volume->values[i];
+            if (m->hw_dB_supported) {
 
-        if (vol > PA_VOLUME_NORM)
-            vol = PA_VOLUME_NORM;
+                alsa_vol = (long) (pa_sw_volume_to_dB(vol) * 100);
+                alsa_vol += m->hw_dB_max;
+                alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, m->hw_dB_min, m->hw_dB_max);
 
-        alsa_vol = (long) roundf(((float) vol * (mixer->hw_volume_max - mixer->hw_volume_min)) / PA_VOLUME_NORM) + mixer->hw_volume_min;
+                if ((err = snd_mixer_selem_set_playback_dB(m->mixer_elem, m->mixer_map[i], alsa_vol, 1)) < 0)
+                    goto fail;
 
-        if (mixer->gain_step) {
-            step = (mixer->hw_volume_max - mixer->hw_volume_min)/mixer->gain_step_count;
-            step = alsa_vol/step;
+                if ((err = snd_mixer_selem_get_playback_dB(m->mixer_elem, m->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
 
-            if (step < 0)
-                alsa_vol = mixer->gain_step[0];
-            else if (step >= (int)mixer->gain_step_count)
-                alsa_vol = mixer->gain_step[mixer->gain_step_count-1];
-            else
-                alsa_vol = mixer->gain_step[step];
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
 
-            pa_log_debug("%s: gain step %d vol %ld", mixer->name, step, alsa_vol);
+                r.values[i] = pa_sw_volume_from_dB((double) (alsa_vol - m->hw_dB_max) / 100.0);
+
+            } else {
+                alsa_vol = to_alsa_volume(u, vol);
+
+                if ((err = snd_mixer_selem_set_playback_volume(m->mixer_elem, m->mixer_map[i], alsa_vol)) < 0)
+                    goto fail;
+
+                if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, m->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+                r.values[i] = from_alsa_volume(u, alsa_vol);
+            }
         }
 
-        if ((err = snd_mixer_selem_set_playback_volume(mixer->mixer_elem, mixer->mixer_map[i], alsa_vol)) < 0) {
-            pa_log_error("Unable to set volume: %s", snd_strerror(err));
-            return 1;
+    } else {
+        pa_volume_t vol;
+        long alsa_vol;
+
+        vol = pa_cvolume_max(vv);
+
+        if (m->hw_dB_supported) {
+            alsa_vol = (long) (pa_sw_volume_to_dB(vol) * 100);
+            alsa_vol += m->hw_dB_max;
+            alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, m->hw_dB_min, m->hw_dB_max);
+
+            if ((err = snd_mixer_selem_set_playback_dB_all(m->mixer_elem, alsa_vol, 1)) < 0)
+                goto fail;
+
+            if ((err = snd_mixer_selem_get_playback_dB(m->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+            pa_cvolume_set(&r, u->sink->sample_spec.channels, pa_sw_volume_from_dB((double) (alsa_vol - m->hw_dB_max) / 100.0));
+
+        } else {
+            alsa_vol = to_alsa_volume(u, vol);
+
+            if ((err = snd_mixer_selem_set_playback_volume_all(m->mixer_elem, alsa_vol)) < 0)
+                goto fail;
+
+            if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+            pa_cvolume_set(&r, u->sink->sample_spec.channels, from_alsa_volume(u, alsa_vol));
         }
     }
 
+    m->hardware_volume = r;
+
+    if (m->hw_dB_supported) {
+        char t[PA_CVOLUME_SNPRINT_MAX];
+
+        /* Match exactly what the user requested by software */
+        pa_sw_cvolume_divide(&u->sink->soft_volume, vv, &m->hardware_volume);
+
+        pa_log_debug("Requested volume: %s", pa_cvolume_snprint(t, sizeof(t), vv));
+        pa_log_debug("Got hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &m->hardware_volume));
+        pa_log_debug("Calculated software volume: %s", pa_cvolume_snprint(t, sizeof(t), &u->sink->soft_volume));
+
+    } else
+
+        /* We can't match exactly what the user requested, hence let's
+         * at least tell the user about it */
+
+        *vv = r;
+
     return 0;
+
+ fail:
+    pa_log_error("Unable to set volume: %s", snd_strerror(err));
+
+    return 1;
 }
 
-static int sink_set_volume_cb(pa_sink *s) {
+static void sink_set_volume_cb(pa_sink *s) {
     struct userdata *u = s->userdata;
 
-    if (set_alsa_mixer_volumes(u, u->active_mixer, &s->volume)) {
+    if (set_alsa_mixer_volumes(u, u->active_mixer, &s->virtual_volume)) {
         s->get_volume = NULL;
         s->set_volume = NULL;
-        return -1;
     }
-
-    return 0;
 }
 
-static int get_alsa_mixer_mute(struct userdata *u, struct mixer_control_t *mixer, pa_bool_t *muted) {
+static void sink_get_mute_cb(pa_sink *s) {
+    struct userdata *u = s->userdata;
     int err, sw;
 
     pa_assert(u);
-    pa_assert(mixer->mixer_elem);
+    pa_assert(u->active_mixer->mixer_elem);
 
-    if ((err = snd_mixer_selem_get_playback_switch(mixer->mixer_elem, 0, &sw)) < 0) {
+    if ((err = snd_mixer_selem_get_playback_switch(u->active_mixer->mixer_elem, 0, &sw)) < 0) {
         pa_log_error("Unable to get switch: %s", snd_strerror(err));
-        return -1;
+        return;
     }
 
-    *muted = !sw;
-
-    return 0;
+    s->muted = !sw;
 }
 
-static int sink_get_mute_cb(pa_sink *s) {
+static void sink_set_mute_cb(pa_sink *s) {
     struct userdata *u = s->userdata;
-
-    if (get_alsa_mixer_mute(u, u->active_mixer, &s->muted)) {
-        s->get_mute = NULL;
-        s->set_mute = NULL;
-        return -1;
-    }
-    return 0;
-}
-
-static int set_alsa_mixer_mute(struct userdata *u, struct mixer_control_t *mixer, pa_bool_t muted) {
     int err;
 
     pa_assert(u);
-    pa_assert(mixer->mixer_elem);
+    pa_assert(u->active_mixer->mixer_elem);
 
-    if ((err = snd_mixer_selem_set_playback_switch_all(mixer->mixer_elem, !muted)) < 0) {
+    if ((err = snd_mixer_selem_set_playback_switch_all(u->active_mixer->mixer_elem, !s->muted)) < 0) {
         pa_log_error("Unable to set switch: %s", snd_strerror(err));
-        return -1;
-    }
-
-    return 0;
-}
-
-static int sink_set_mute_cb(pa_sink *s) {
-    struct userdata *u = s->userdata;
-
-    if (set_alsa_mixer_mute(u, u->active_mixer, s->muted)) {
-        s->get_mute = NULL;
-        s->set_mute = NULL;
-        return -1;
+        return;
     }
-    return 0;
 }
 
 static void thread_func(void *userdata) {
@@ -863,13 +967,13 @@ static void thread_func(void *userdata) {
         }
     }
 
-fail:
+ fail:
     /* If this was no regular exit from the loop we have to continue
      * processing messages until we received PA_MESSAGE_SHUTDOWN */
     pa_asyncmsgq_post(u->thread_mq.outq, PA_MSGOBJECT(u->core), PA_CORE_MESSAGE_UNLOAD_MODULE, u->module, 0, NULL, NULL);
     pa_asyncmsgq_wait_for(u->thread_mq.inq, PA_MESSAGE_SHUTDOWN);
 
-finish:
+ finish:
     pa_log_debug("Thread shutting down");
 }
 
@@ -945,53 +1049,10 @@ static int set_mixer_elem_by_name(struct userdata *u, const char *mixer) {
     return 0;
 }
 
-static struct mixer_control_t* mixer_control_new(const char *name,
-                                                 pa_alsa_fdlist *mixer_fdl,
-                                                 snd_mixer_elem_t *mixer_elem,
-                                                 snd_mixer_selem_channel_id_t *mixer_map,
-                                                 const unsigned channels,
-                                                 long hw_volume_min,
-                                                 long hw_volume_max,
-                                                 unsigned gain_step_count,
-                                                 long *gain_step) {
+static struct mixer_control_t* get_mixer_element(struct userdata *u, const char *mixer) {
     struct mixer_control_t *m = NULL;
-    m = pa_xnew0(struct mixer_control_t, 1);
-    PA_LLIST_INIT(struct mixer_control_t, m);
-
-    m->name = pa_xstrdup(name);
-    m->mixer_fdl = mixer_fdl;
-    m->mixer_elem = mixer_elem;
-    memcpy(&m->mixer_map, mixer_map, sizeof(snd_mixer_selem_channel_id_t)*SND_MIXER_SCHN_LAST);
-    m->channels = channels;
-    m->hw_volume_min = hw_volume_min;
-    m->hw_volume_max = hw_volume_max;
-    m->gain_step_count = gain_step_count;
-    if (gain_step_count > 0) {
-        m->gain_step = pa_xnew0(long, gain_step_count);
-        memcpy(&m->gain_step, gain_step, sizeof(long)*gain_step_count);
-    } else {
-        m->gain_step_count = 0;
-        m->gain_step = NULL;
-    }
-
-    /* cache proplist strings */
-    m->prop_mixer_gain_step_count = pa_sprintf_malloc(PA_ALSA_SINK_PROP_MIXER_GAIN_STEP_COUNT, m->name);
-    replace_chars(m->prop_mixer_gain_step_count, ' ', '_');
-    m->prop_mixer_gain_step = pa_sprintf_malloc(PA_ALSA_SINK_PROP_MIXER_GAIN_STEP, m->name);
-    replace_chars(m->prop_mixer_gain_step, ' ', '_');
-
-    return m;
-}
-
-
-static struct mixer_control_t* get_mixer_element(struct userdata *u,
-                                                 const char *mixer) {
-    struct mixer_control_t *m = NULL;
-    snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
-    pa_alsa_fdlist *mixer_fdl = NULL;
-    snd_mixer_elem_t *mixer_elem = NULL;
-    long hw_volume_min;
-    long hw_volume_max;
+    snd_mixer_elem_t *mixer_elem;
+    pa_channel_map map;
 
     if (u->mixer_handle) {
         /* Try using mixer as both primary and fallback mixer, to ensure mixer selection
@@ -1006,43 +1067,113 @@ static struct mixer_control_t* get_mixer_element(struct userdata *u,
     }
 
     if (u->mixer_handle && mixer_elem) {
-        pa_assert(mixer_elem);
 
-        if (snd_mixer_selem_has_playback_volume(mixer_elem))
-            if (pa_alsa_calc_mixer_map(mixer_elem, &u->channel_map, mixer_map, TRUE) >= 0) {
-                snd_mixer_selem_get_playback_volume_range(mixer_elem, &hw_volume_min, &hw_volume_max);
+        m = pa_xnew0(struct mixer_control_t, 1);
+        PA_LLIST_INIT(struct mixer_control_t, m);
+
+        m->name = pa_xstrdup(mixer);
+        m->mixer_elem = mixer_elem;
+
+        if (snd_mixer_selem_has_playback_volume(m->mixer_elem)) {
+            pa_bool_t suitable = FALSE;
+
+            if (snd_mixer_selem_get_playback_volume_range(m->mixer_elem, &m->hw_volume_min, &m->hw_volume_max) < 0)
+                pa_log_info("Failed to get volume range. Falling back to software volume control.");
+            else if (m->hw_volume_min >= m->hw_volume_max)
+                pa_log_warn("Your kernel driver is broken: it reports a volume range from %li to %li which makes no sense.", m->hw_volume_min, m->hw_volume_max);
+            else {
+                pa_log_info("Volume ranges from %li to %li.", m->hw_volume_min, m->hw_volume_max);
+                suitable = TRUE;
             }
 
-        mixer_fdl = pa_alsa_fdlist_new();
+            if (suitable) {
+                if (u->ignore_dB || snd_mixer_selem_get_playback_dB_range(m->mixer_elem, &m->hw_dB_min, &m->hw_dB_max) < 0)
+                    pa_log_info("Mixer doesn't support dB information or data is ignored.");
+                else {
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                    VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_min, sizeof(m->hw_dB_min));
+                    VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_max, sizeof(m->hw_dB_max));
+#endif
+
+                    if (m->hw_dB_min >= m->hw_dB_max)
+                        pa_log_warn("Your kernel driver is broken: it reports a volume range from %0.2f dB to %0.2f dB which makes no sense.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
+                    else {
+                        pa_log_info("Volume ranges from %0.2f dB to %0.2f dB.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
+                        m->hw_dB_supported = TRUE;
+
+                        if (m->hw_dB_max > 0) {
+                            u->sink->base_volume = pa_sw_volume_from_dB(- (double) m->hw_dB_max/100.0);
+                            pa_log_info("Fixing base volume to %0.2f dB", pa_sw_volume_to_dB(u->sink->base_volume));
+                        } else
+                            pa_log_info("No particular base volume set, fixing to 0 dB");
+                    }
+                }
+
+                if (!m->hw_dB_supported &&
+                    m->hw_volume_max - m->hw_volume_min < 3) {
+
+                    pa_log_info("Device doesn't do dB volume and has less than 4 volume levels. Falling back to software volume control.");
+                    suitable = FALSE;
+                }
+            }
+
+            if (suitable) {
+                m->mixer_seperate_channels = pa_alsa_calc_mixer_map(m->mixer_elem, &map, m->mixer_map, TRUE) >= 0;
+
+                u->sink->get_volume = sink_get_volume_cb;
+                u->sink->set_volume = sink_set_volume_cb;
 
-        if (pa_alsa_fdlist_set_mixer(mixer_fdl, u->mixer_handle, u->module->core->mainloop) < 0) {
+                /* FIXME: Hmmm.. mouhahaha! */
+                u->sink->flags |= PA_SINK_HW_VOLUME_CTRL | (u->active_mixer->hw_dB_supported ? PA_SINK_DECIBEL_VOLUME : 0);
+                pa_log_info("Using hardware volume control. Hardware dB scale %s.", u->active_mixer->hw_dB_supported ? "supported" : "not supported");
+
+                if (!m->hw_dB_supported)
+                    u->sink->n_volume_steps = m->hw_volume_max - m->hw_volume_min + 1;
+            } else
+                pa_log_info("Using software volume control.");
+        }
+
+        if (snd_mixer_selem_has_playback_switch(m->mixer_elem)) {
+            u->sink->get_mute = sink_get_mute_cb;
+            u->sink->set_mute = sink_set_mute_cb;
+            /* FIXME: Hmmm.. mouhahaha! */
+            u->sink->flags |= PA_SINK_HW_MUTE_CTRL;
+        } else
+            pa_log_info("Using software mute control.");
+
+        m->mixer_fdl = pa_alsa_fdlist_new();
+
+        if (pa_alsa_fdlist_set_mixer(m->mixer_fdl, u->mixer_handle, u->core->mainloop) < 0) {
             pa_log("Failed to initialize file descriptor monitoring");
             goto fail;
         }
 
-        snd_mixer_elem_set_callback(mixer_elem, mixer_callback);
-        snd_mixer_elem_set_callback_private(mixer_elem, u);
+        snd_mixer_elem_set_callback(m->mixer_elem, mixer_callback);
+        snd_mixer_elem_set_callback_private(m->mixer_elem, u);
 
-        m = mixer_control_new(mixer,
-                              mixer_fdl,
-                              mixer_elem,
-                              mixer_map,
-                              u->sink->sample_spec.channels,
-                              hw_volume_min,
-                              hw_volume_max,
-                              0, NULL);
+        /* FIXME: Juho? */
+        /* if (m->gain_step_count > 0) { */
+        /*     m->gain_step = pa_xnew0(long, m->gain_step_count); */
+        /*     memcpy(&m->gain_step, gain_step, sizeof(long)*gain_step_count); */
+        /* } */
+
+        /* cache proplist strings */
+        m->prop_mixer_gain_step_count = pa_sprintf_malloc(PA_ALSA_SINK_PROP_MIXER_GAIN_STEP_COUNT, m->name);
+        replace_chars(m->prop_mixer_gain_step_count, ' ', '_');
+        m->prop_mixer_gain_step = pa_sprintf_malloc(PA_ALSA_SINK_PROP_MIXER_GAIN_STEP, m->name);
+        replace_chars(m->prop_mixer_gain_step, ' ', '_');
 
         pa_log_info("%s: new mixer found: %s", u->device_name, m->name);
 
     } else {
-        mixer_fdl = NULL;
+        m->mixer_fdl = NULL;
     }
 
     return m;
-fail:
-    if (mixer_fdl) {
-        pa_alsa_fdlist_free(mixer_fdl);
-        mixer_fdl = NULL;
+ fail:
+    if (m->mixer_fdl) {
+        pa_alsa_fdlist_free(m->mixer_fdl);
+        m->mixer_fdl = NULL;
     }
 
     return NULL;
@@ -1133,7 +1264,7 @@ static int update_mixer_gain_steps(struct userdata *u,
     pa_log_info("%s: updated gain steps (%u)", u->device_name, count);
     return 0;
 
-bad_data:
+ bad_data:
     pa_xfree(m->gain_step);
     m->gain_step = NULL;
     m->gain_step_count = 0;
@@ -1217,7 +1348,7 @@ static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink
     }
 
     if (update_volumes) {
-        pa_sink_set_volume(u->sink, vol);
+        pa_sink_set_volume(u->sink, vol, TRUE, TRUE);
         pa_sink_set_mute(u->sink, muted);
     }
 
@@ -1251,6 +1382,7 @@ int pa__init(pa_module*m) {
     pa_sink_new_data data;
     const pa_alsa_profile_info *profile;
     unsigned i;
+    pa_bool_t ignore_dB = FALSE;
 
     snd_pcm_info_alloca(&pcm_info);
 
@@ -1267,6 +1399,11 @@ int pa__init(pa_module*m) {
         goto fail;
     }
 
+    if (pa_modargs_get_value_boolean(ma, "ignore_dB", &ignore_dB) < 0) {
+        pa_log("Failed to parse ignore_dB argument.");
+        goto fail;
+    }
+
     alsa_mixer = pa_xstrdup(pa_modargs_get_value(ma, "mixer", "Master"));
     replace_chars(alsa_mixer, '_', ' ');
 
@@ -1319,6 +1456,7 @@ int pa__init(pa_module*m) {
     }
 
     u = pa_xnew0(struct userdata, 1);
+    u->ignore_dB = ignore_dB;
     u->switch_mode = SINK_SWITCH_PRIMARY;
     if (alt_nfrags != 0)
         u->switching_enabled = TRUE;
@@ -1413,7 +1551,7 @@ int pa__init(pa_module*m) {
     pa_sink_new_data_set_sample_spec(&data, &ss);
     pa_sink_new_data_set_channel_map(&data, &map);
 
-    pa_alsa_init_proplist_pcm(data.proplist, pcm_info);
+    pa_alsa_init_proplist_pcm(m->core, data.proplist, pcm_info);
     pa_proplist_sets(data.proplist, PA_PROP_DEVICE_STRING, u->device_name);
     pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE, "%lu", (unsigned long) (period_size * frame_size * nfrags));
     pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE, "%lu", (unsigned long) (period_size * frame_size));
@@ -1516,7 +1654,7 @@ int pa__init(pa_module*m) {
 
     return 0;
 
-fail:
+ fail:
 
     if (alsa_mixer)
         pa_xfree(alsa_mixer);
diff --git a/src/modules/alsa/module-alsa-source-old.c b/src/modules/alsa/module-alsa-source-old.c
index df873d3..814f2f3 100644
--- a/src/modules/alsa/module-alsa-source-old.c
+++ b/src/modules/alsa/module-alsa-source-old.c
@@ -29,6 +29,10 @@
 
 #include <asoundlib.h>
 
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
 #include <pulse/xmalloc.h>
 #include <pulse/util.h>
 
@@ -90,6 +94,11 @@ struct userdata {
     snd_mixer_t *mixer_handle;
     snd_mixer_elem_t *mixer_elem;
     long hw_volume_max, hw_volume_min;
+    long hw_dB_max, hw_dB_min;
+    pa_bool_t hw_dB_supported;
+    pa_bool_t mixer_seperate_channels;
+
+    pa_cvolume hardware_volume;
 
     size_t frame_size, fragment_size, hwbuf_size;
     snd_pcm_uframes_t period_size;
@@ -567,75 +576,214 @@ static int mixer_callback(snd_mixer_elem_t *elem, unsigned int mask) {
     return 0;
 }
 
-static int source_get_volume_cb(pa_source *s) {
+static pa_volume_t from_alsa_volume(struct userdata *u, long alsa_vol) {
+
+    return (pa_volume_t) round(((double) (alsa_vol - u->hw_volume_min) * PA_VOLUME_NORM) /
+                               (double) (u->hw_volume_max - u->hw_volume_min));
+}
+
+static long to_alsa_volume(struct userdata *u, pa_volume_t vol) {
+    long alsa_vol;
+
+    alsa_vol = (long) round(((double) vol * (double) (u->hw_volume_max - u->hw_volume_min))
+                            / PA_VOLUME_NORM) + u->hw_volume_min;
+
+    return PA_CLAMP_UNLIKELY(alsa_vol, u->hw_volume_min, u->hw_volume_max);
+}
+
+static void source_get_volume_cb(pa_source *s) {
     struct userdata *u = s->userdata;
     int err;
-    int i;
+    unsigned i;
+    pa_cvolume r;
+    char t[PA_CVOLUME_SNPRINT_MAX];
 
     pa_assert(u);
     pa_assert(u->mixer_elem);
 
-    for (i = 0; i < s->sample_spec.channels; i++) {
-        long set_vol, vol;
+    if (u->mixer_seperate_channels) {
 
-        pa_assert(snd_mixer_selem_has_capture_channel(u->mixer_elem, u->mixer_map[i]));
+        r.channels = s->sample_spec.channels;
 
-        if ((err = snd_mixer_selem_get_capture_volume(u->mixer_elem, u->mixer_map[i], &vol)) < 0)
-            goto fail;
+        for (i = 0; i < s->sample_spec.channels; i++) {
+            long alsa_vol;
+
+            if (u->hw_dB_supported) {
+
+                if ((err = snd_mixer_selem_get_capture_dB(u->mixer_elem, u->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+                r.values[i] = pa_sw_volume_from_dB((double) (alsa_vol - u->hw_dB_max) / 100.0);
+            } else {
+
+                if ((err = snd_mixer_selem_get_capture_volume(u->mixer_elem, u->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+                r.values[i] = from_alsa_volume(u, alsa_vol);
+            }
+        }
+
+    } else {
+        long alsa_vol;
 
-        set_vol = (long) roundf(((float) s->volume.values[i] * (u->hw_volume_max - u->hw_volume_min)) / PA_VOLUME_NORM) + u->hw_volume_min;
+        if (u->hw_dB_supported) {
+
+            if ((err = snd_mixer_selem_get_capture_dB(u->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+            pa_cvolume_set(&r, s->sample_spec.channels, pa_sw_volume_from_dB((double) (alsa_vol - u->hw_dB_max) / 100.0));
+
+        } else {
+
+            if ((err = snd_mixer_selem_get_capture_volume(u->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
 
-        /* Try to avoid superfluous volume changes */
-        if (set_vol != vol)
-            s->volume.values[i] = (pa_volume_t) roundf(((float) (vol - u->hw_volume_min) * PA_VOLUME_NORM) / (u->hw_volume_max - u->hw_volume_min));
+            pa_cvolume_set(&r, s->sample_spec.channels, from_alsa_volume(u, alsa_vol));
+        }
     }
 
-    return 0;
+    pa_log_debug("Read hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &r));
 
-fail:
-    pa_log_error("Unable to read volume: %s", snd_strerror(err));
+    if (!pa_cvolume_equal(&u->hardware_volume, &r)) {
 
-    s->get_volume = NULL;
-    s->set_volume = NULL;
-    return -1;
+        s->virtual_volume = u->hardware_volume = r;
+
+        if (u->hw_dB_supported) {
+            pa_cvolume reset;
+
+            /* Hmm, so the hardware volume changed, let's reset our software volume */
+            pa_cvolume_reset(&reset, s->sample_spec.channels);
+            pa_source_set_soft_volume(s, &reset);
+        }
+    }
+
+    return;
+
+ fail:
+    pa_log_error("Unable to read volume: %s", snd_strerror(err));
 }
 
-static int source_set_volume_cb(pa_source *s) {
+static void source_set_volume_cb(pa_source *s) {
     struct userdata *u = s->userdata;
     int err;
-    int i;
+    unsigned i;
+    pa_cvolume r;
 
     pa_assert(u);
     pa_assert(u->mixer_elem);
 
-    for (i = 0; i < s->sample_spec.channels; i++) {
-        long alsa_vol;
+    if (u->mixer_seperate_channels) {
+
+        r.channels = s->sample_spec.channels;
+
+        for (i = 0; i < s->sample_spec.channels; i++) {
+            long alsa_vol;
+            pa_volume_t vol;
+
+            vol = s->virtual_volume.values[i];
+
+            if (u->hw_dB_supported) {
+
+                alsa_vol = (long) (pa_sw_volume_to_dB(vol) * 100);
+                alsa_vol += u->hw_dB_max;
+                alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, u->hw_dB_min, u->hw_dB_max);
+
+                if ((err = snd_mixer_selem_set_capture_dB(u->mixer_elem, u->mixer_map[i], alsa_vol, 1)) < 0)
+                    goto fail;
+
+                if ((err = snd_mixer_selem_get_capture_dB(u->mixer_elem, u->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+                r.values[i] = pa_sw_volume_from_dB((double) (alsa_vol - u->hw_dB_max) / 100.0);
+
+            } else {
+                alsa_vol = to_alsa_volume(u, vol);
+
+                if ((err = snd_mixer_selem_set_capture_volume(u->mixer_elem, u->mixer_map[i], alsa_vol)) < 0)
+                    goto fail;
+
+                if ((err = snd_mixer_selem_get_capture_volume(u->mixer_elem, u->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+                r.values[i] = from_alsa_volume(u, alsa_vol);
+            }
+        }
+
+    } else {
         pa_volume_t vol;
+        long alsa_vol;
 
-        pa_assert(snd_mixer_selem_has_capture_channel(u->mixer_elem, u->mixer_map[i]));
+        vol = pa_cvolume_max(&s->virtual_volume);
 
-        vol = s->volume.values[i];
+        if (u->hw_dB_supported) {
+            alsa_vol = (long) (pa_sw_volume_to_dB(vol) * 100);
+            alsa_vol += u->hw_dB_max;
+            alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, u->hw_dB_min, u->hw_dB_max);
 
-        if (vol > PA_VOLUME_NORM)
-            vol = PA_VOLUME_NORM;
+            if ((err = snd_mixer_selem_set_capture_dB_all(u->mixer_elem, alsa_vol, 1)) < 0)
+                goto fail;
 
-        alsa_vol = (long) roundf(((float) vol * (u->hw_volume_max - u->hw_volume_min)) / PA_VOLUME_NORM) + u->hw_volume_min;
+            if ((err = snd_mixer_selem_get_capture_dB(u->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
 
-        if ((err = snd_mixer_selem_set_capture_volume(u->mixer_elem, u->mixer_map[i], alsa_vol)) < 0)
-            goto fail;
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+            pa_cvolume_set(&r, s->sample_spec.channels, pa_sw_volume_from_dB((double) (alsa_vol - u->hw_dB_max) / 100.0));
+
+        } else {
+            alsa_vol = to_alsa_volume(u, vol);
+
+            if ((err = snd_mixer_selem_set_capture_volume_all(u->mixer_elem, alsa_vol)) < 0)
+                goto fail;
+
+            if ((err = snd_mixer_selem_get_capture_volume(u->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+            pa_cvolume_set(&r, s->sample_spec.channels, from_alsa_volume(u, alsa_vol));
+        }
     }
 
-    return 0;
+    u->hardware_volume = r;
 
-fail:
-    pa_log_error("Unable to set volume: %s", snd_strerror(err));
+    if (u->hw_dB_supported) {
+        char t[PA_CVOLUME_SNPRINT_MAX];
 
-    s->get_volume = NULL;
-    s->set_volume = NULL;
-    return -1;
+        /* Match exactly what the user requested by software */
+
+        pa_sw_cvolume_divide(&s->soft_volume, &s->virtual_volume, &u->hardware_volume);
+
+        pa_log_debug("Requested volume: %s", pa_cvolume_snprint(t, sizeof(t), &s->virtual_volume));
+        pa_log_debug("Got hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &u->hardware_volume));
+        pa_log_debug("Calculated software volume: %s", pa_cvolume_snprint(t, sizeof(t), &s->soft_volume));
+
+    } else
+
+        /* We can't match exactly what the user requested, hence let's
+         * at least tell the user about it */
+
+        s->virtual_volume = r;
+
+    return;
+
+ fail:
+    pa_log_error("Unable to set volume: %s", snd_strerror(err));
 }
 
-static int source_get_mute_cb(pa_source *s) {
+static void source_get_mute_cb(pa_source *s) {
     struct userdata *u = s->userdata;
     int err, sw;
 
@@ -644,18 +792,13 @@ static int source_get_mute_cb(pa_source *s) {
 
     if ((err = snd_mixer_selem_get_capture_switch(u->mixer_elem, 0, &sw)) < 0) {
         pa_log_error("Unable to get switch: %s", snd_strerror(err));
-
-        s->get_mute = NULL;
-        s->set_mute = NULL;
-        return -1;
+        return;
     }
 
     s->muted = !sw;
-
-    return 0;
 }
 
-static int source_set_mute_cb(pa_source *s) {
+static void source_set_mute_cb(pa_source *s) {
     struct userdata *u = s->userdata;
     int err;
 
@@ -664,13 +807,8 @@ static int source_set_mute_cb(pa_source *s) {
 
     if ((err = snd_mixer_selem_set_capture_switch_all(u->mixer_elem, !s->muted)) < 0) {
         pa_log_error("Unable to set switch: %s", snd_strerror(err));
-
-        s->get_mute = NULL;
-        s->set_mute = NULL;
-        return -1;
+        return;
     }
-
-    return 0;
 }
 
 static void thread_func(void *userdata) {
@@ -814,7 +952,7 @@ int pa__init(pa_module*m) {
     const char *name;
     char *name_buf = NULL;
     int namereg_fail;
-    pa_bool_t use_mmap = TRUE, b, d;
+    pa_bool_t use_mmap = TRUE, b, d, ignore_dB = FALSE;
     pa_source_new_data data;
     const pa_alsa_profile_info *profile;
 
@@ -876,6 +1014,11 @@ int pa__init(pa_module*m) {
         goto fail;
     }
 
+    if (pa_modargs_get_value_boolean(ma, "ignore_dB", &ignore_dB) < 0) {
+        pa_log("Failed to parse ignore_dB argument.");
+        goto fail;
+    }
+
     u = pa_xnew0(struct userdata, 1);
     u->switch_mode = SOURCE_SWITCH_PRIMARY;
     if (alt_nfrags != 0)
@@ -985,7 +1128,7 @@ int pa__init(pa_module*m) {
     pa_source_new_data_set_sample_spec(&data, &ss);
     pa_source_new_data_set_channel_map(&data, &map);
 
-    pa_alsa_init_proplist_pcm(data.proplist, pcm_info);
+    pa_alsa_init_proplist_pcm(m->core, data.proplist, pcm_info);
     pa_proplist_sets(data.proplist, PA_PROP_DEVICE_STRING, u->device_name);
     pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE, "%lu", (unsigned long) (period_size * frame_size * nfrags));
     pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE, "%lu", (unsigned long) (period_size * frame_size));
@@ -1041,19 +1184,70 @@ int pa__init(pa_module*m) {
     if (u->mixer_handle) {
         pa_assert(u->mixer_elem);
 
-        if (snd_mixer_selem_has_capture_volume(u->mixer_elem))
-            if (pa_alsa_calc_mixer_map(u->mixer_elem, &map, u->mixer_map, FALSE) >= 0) {
+        if (snd_mixer_selem_has_capture_volume(u->mixer_elem)) {
+            pa_bool_t suitable = FALSE;
+
+            if (snd_mixer_selem_get_capture_volume_range(u->mixer_elem, &u->hw_volume_min, &u->hw_volume_max) < 0)
+                pa_log_info("Failed to get volume range. Falling back to software volume control.");
+            else if (u->hw_volume_min >= u->hw_volume_max)
+                pa_log_warn("Your kernel driver is broken: it reports a volume range from %li to %li which makes no sense.", u->hw_volume_min, u->hw_volume_max);
+            else {
+                pa_log_info("Volume ranges from %li to %li.", u->hw_volume_min, u->hw_volume_max);
+                suitable = TRUE;
+            }
+
+            if (suitable) {
+                if (ignore_dB || snd_mixer_selem_get_capture_dB_range(u->mixer_elem, &u->hw_dB_min, &u->hw_dB_max) < 0)
+                    pa_log_info("Mixer doesn't support dB information or data is ignored.");
+                else {
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                    VALGRIND_MAKE_MEM_DEFINED(&u->hw_dB_min, sizeof(u->hw_dB_min));
+                    VALGRIND_MAKE_MEM_DEFINED(&u->hw_dB_max, sizeof(u->hw_dB_max));
+#endif
+
+                    if (u->hw_dB_min >= u->hw_dB_max)
+                        pa_log_warn("Your kernel driver is broken: it reports a volume range from %0.2f dB to %0.2f dB which makes no sense.", (double) u->hw_dB_min/100.0, (double) u->hw_dB_max/100.0);
+                    else {
+                        pa_log_info("Volume ranges from %0.2f dB to %0.2f dB.", (double) u->hw_dB_min/100.0, (double) u->hw_dB_max/100.0);
+                        u->hw_dB_supported = TRUE;
+
+                        if (u->hw_dB_max > 0) {
+                            u->source->base_volume = pa_sw_volume_from_dB(- (double) u->hw_dB_max/100.0);
+                            pa_log_info("Fixing base volume to %0.2f dB", pa_sw_volume_to_dB(u->source->base_volume));
+                        } else
+                            pa_log_info("No particular base volume set, fixing to 0 dB");
+
+                    }
+                }
+
+                if (!u->hw_dB_supported &&
+                    u->hw_volume_max - u->hw_volume_min < 3) {
+
+                    pa_log_info("Device has less than 4 volume levels. Falling back to software volume control.");
+                    suitable = FALSE;
+                }
+            }
+
+            if (suitable) {
+                u->mixer_seperate_channels = pa_alsa_calc_mixer_map(u->mixer_elem, &map, u->mixer_map, FALSE) >= 0;
+
                 u->source->get_volume = source_get_volume_cb;
                 u->source->set_volume = source_set_volume_cb;
-                snd_mixer_selem_get_capture_volume_range(u->mixer_elem, &u->hw_volume_min, &u->hw_volume_max);
-                u->source->flags |= PA_SOURCE_HW_VOLUME_CTRL;
-            }
+                u->source->flags |= PA_SOURCE_HW_VOLUME_CTRL | (u->hw_dB_supported ? PA_SOURCE_DECIBEL_VOLUME : 0);
+                pa_log_info("Using hardware volume control. Hardware dB scale %s.", u->hw_dB_supported ? "supported" : "not supported");
+
+                if (!u->hw_dB_supported)
+                    u->source->n_volume_steps = u->hw_volume_max - u->hw_volume_min + 1;
+            } else
+                pa_log_info("Using software volume control.");
+        }
 
         if (snd_mixer_selem_has_capture_switch(u->mixer_elem)) {
             u->source->get_mute = source_get_mute_cb;
             u->source->set_mute = source_set_mute_cb;
-            u->source->flags |= PA_SOURCE_HW_VOLUME_CTRL;
-        }
+            u->source->flags |= PA_SOURCE_HW_MUTE_CTRL;
+        } else
+            pa_log_info("Using software mute control.");
 
         u->mixer_fdl = pa_alsa_fdlist_new();
 
@@ -1072,10 +1266,21 @@ int pa__init(pa_module*m) {
         goto fail;
     }
     /* Get initial mixer settings */
-    if (u->source->get_volume)
-        u->source->get_volume(u->source);
-    if (u->source->get_mute)
-        u->source->get_mute(u->source);
+    if (data.volume_is_set) {
+        if (u->source->set_volume)
+            u->source->set_volume(u->source);
+    } else {
+        if (u->source->get_volume)
+            u->source->get_volume(u->source);
+    }
+
+    if (data.muted_is_set) {
+        if (u->source->set_mute)
+            u->source->set_mute(u->source);
+    } else {
+        if (u->source->get_mute)
+            u->source->get_mute(u->source);
+    }
 
     pa_proplist_sets(u->source->proplist, PA_ALSA_SOURCE_PROP_BUFFERS, PA_ALSA_SOURCE_PROP_BUFFERS_PRIMARY);
 
-- 
1.6.1.224.gb56c

