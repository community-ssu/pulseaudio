From 70401cc6cd9fc72dff53cbb1a738b5e57caf3af9 Mon Sep 17 00:00:00 2001
From: Janos Kovacs <janos.f.kovacs@nokia.com>
Date: Tue, 30 Sep 2008 10:38:33 +0300
Subject: [PATCH] - first version of support for external configuration file
   (doesn't do any useful yet)

---
 src/Makefile.am                 |    1 +
 src/modules/maemo/config-file.c |  354 +++++++++++++++++++++++++++++++++++++++
 src/modules/maemo/config-file.h |   16 ++
 3 files changed, 371 insertions(+), 0 deletions(-)
 create mode 100644 src/modules/maemo/config-file.c
 create mode 100644 src/modules/maemo/config-file.h

diff --git a/src/Makefile.am b/src/Makefile.am
index 813494c..f893142 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1621,6 +1621,7 @@ module_bluetooth_device_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS)
 # Policy Enforcement
 module_policy_enforcement_la_SOURCES = \
 			modules/maemo/module-policy-enforcement.c \
+			modules/maemo/config-file.c \
 			modules/maemo/client-ext.c \
 			modules/maemo/sink-ext.c \
 			modules/maemo/sink-input-ext.c \
diff --git a/src/modules/maemo/config-file.c b/src/modules/maemo/config-file.c
new file mode 100644
index 0000000..8b522f8
--- /dev/null
+++ b/src/modules/maemo/config-file.c
@@ -0,0 +1,354 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+#ifndef __USE_ISOC99
+#define __USE_ISOC99
+#include <ctype.h>
+#undef __USE_ISOC99
+#else
+#include <ctype.h>
+#endif
+
+#include <config.h>
+
+#include <pulsecore/log.h>
+
+#include "config-file.h"
+#include "policy-group.h"
+#include "classify.h"
+
+#define DEFAULT_CONFIG_FILE "policy.conf"
+
+enum section_type {
+    section_unknown = 0,
+    section_groups,
+    section_device,
+    section_max
+};
+
+struct groupdef {
+    char          *name;
+};
+
+struct devicedef {
+    char          *type;
+    char          *sink;
+    unsigned long  flags;
+};
+
+struct section {
+    enum section_type     type;
+    union {
+        void             *any;
+        struct groupdef  *group;
+        struct devicedef *device;
+    }                     def;
+};
+
+
+static int preprocess_buffer(int, char *, char *);
+
+static int section_header(int, char *, enum section_type *);
+static int section_open(struct userdata *, enum section_type,struct section *);
+static int section_close(struct userdata *, struct section *);
+
+static int groupdef_parse(int, char *, struct groupdef *);
+static int devicedef_parse(int, char *, struct devicedef *);
+
+static int valid_label(char *);
+
+
+int pa_policy_parse_config_file(struct userdata *u, const char *cfgfile)
+{
+#define BUFSIZE 512
+
+    FILE              *f;
+    char               cfgpath[PATH_MAX];
+    char               buf[BUFSIZE];
+    char               line[BUFSIZE];
+    int                lineno;
+    enum section_type  newsect;
+    struct section     section;
+    struct groupdef   *grdef;
+    struct devicedef  *devdef;
+    int                sts;
+
+    pa_assert(u);
+
+    if (!cfgfile)
+        cfgfile = DEFAULT_CONFIG_FILE;
+
+    pa_policy_file_path(cfgfile, cfgpath, PATH_MAX);
+    pa_log_info("%s: policy config file is '%s'", __FILE__, cfgpath);
+
+    if ((f = fopen(cfgpath, "r")) == NULL) {
+        pa_log("%s: Can't open config file '%s': %s",
+               __FILE__, cfgpath, strerror(errno));
+        return 0;
+    }
+
+    sts = 1;
+
+    memset(&section, 0, sizeof(section));
+
+    for (errno = 0, lineno = 1;  fgets(buf, BUFSIZE, f) != NULL;  lineno++) {
+        if (preprocess_buffer(lineno, buf, line) < 0)
+            break;
+
+        if (*line == '\0')
+            continue;
+
+        if (section_header(lineno, line, &newsect)) {
+            if (section_close(u, &section) < 0)
+                sts = 0;
+
+            section.type = newsect;
+
+            if (section_open(u, newsect, &section) < 0)
+                sts = 0;
+        }
+        else {
+            switch (section.type) {
+
+            case section_groups:
+                grdef = section.def.group;
+
+                if (groupdef_parse(lineno, line, grdef) < 0)
+                    sts = 0;
+                else
+                    pa_policy_group_new(u, grdef->name);
+
+                break;
+
+            case section_device:
+                devdef = section.def.device;
+
+                if (devicedef_parse(lineno, line, devdef) < 0)
+                    sts = 0;
+
+                break;
+
+            default:
+                break;
+
+            }
+        }
+    }
+
+    section_close(u, &section);
+
+
+    return sts;
+}
+
+static int preprocess_buffer(int lineno, char *inbuf, char *outbuf)
+{
+    char           c, *p, *q;
+    int             quote;
+    int             sts = 0;
+
+    for (quote = 0, p = inbuf, q = outbuf;   (c = *p) != '\0';   p++) {
+        if (!quote && isblank(c))
+            continue;
+        
+        if (c == '\n' || c == '#')
+            break;
+        
+        if (c == '"') {
+            quote ^= 1;
+            continue;
+        }
+        
+        if (c < 0x20) {
+            pa_log("%s: Illegal character 0x%02x in line %d",
+                   __FILE__, c, lineno);
+            sts = -1;
+            errno = EILSEQ;
+            break;
+        }
+        
+        *q++ = c;
+    }
+    *q = '\0';
+
+    return sts;
+}
+
+
+static int section_header(int lineno, char *line, enum section_type *type)
+{
+    int is_section;
+
+    if (line[0] != '[')
+        is_section = 0;
+    else {
+        is_section = 1;
+
+        if (!strcmp(line, "[groups]"))
+            *type = section_groups;
+        else if (!strcmp(line,"[device]"))
+            *type = section_device;
+        else {
+            *type = section_unknown;
+            pa_log("%s: Invalid section type '%s' in line %d",
+                   __FILE__, line, lineno);
+        }
+    }
+
+    return is_section;
+}
+
+static int section_open(struct userdata *u, enum section_type type,
+                        struct section *sec)
+{
+    int status;
+
+    if (sec == NULL)
+        status = -1;
+    else {
+        switch (type) {
+            
+        case section_groups:
+            sec->def.group = pa_xnew0(struct groupdef, 1);
+            status = 0;
+            break;
+            
+        case section_device:
+            sec->def.device = pa_xnew0(struct devicedef, 1);
+            status = 0;
+            break;
+            
+        default:
+            type = section_unknown;
+            sec->def.any = NULL;
+            status = -1;
+            break;
+        }
+
+        sec->type = type;
+    }
+
+    return status;
+}
+
+static int section_close(struct userdata *u, struct section *sec)
+{
+    struct groupdef  *grdef;
+    struct devicedef *devdef;
+    int               status;
+
+    if (sec == NULL)
+        status = -1;
+    else {
+        switch (sec->type) {
+            
+        case section_groups:
+            status = 0;
+            grdef  = sec->def.group;
+            pa_xfree(grdef);
+            break;
+            
+        case section_device:
+            status = 0;
+            devdef = sec->def.device;
+            
+            pa_classify_add_device(u, devdef->type, devdef->sink,
+                                   devdef->flags); 
+            
+            pa_xfree(devdef->type);
+            pa_xfree(devdef->sink);
+            pa_xfree(devdef);
+
+            break;
+            
+        default:
+            status = 0;
+            break;
+        }
+        
+        sec->type = section_unknown;
+        sec->def.any = NULL;
+    }
+
+    return status;
+}
+
+
+static int groupdef_parse(int lineno, char *line, struct groupdef *grdef)
+{
+    int   sts;
+
+    if (grdef == NULL)
+        sts = -1;
+    else {
+        grdef->name = line;
+        sts = valid_label(grdef->name) ? 0 : -1;
+    }
+
+    return sts;
+}
+
+static int devicedef_parse(int lineno, char *line, struct devicedef *devdef)
+{
+    int   sts;
+    char *end;
+
+    if (devdef == NULL)
+        sts = -1;
+    else {
+        sts = 0;
+
+        if (!strncmp(line, "type=", 5)) {
+            if ((devdef->type = pa_xstrdup(line+5)) == NULL)
+                sts = -1;
+        }
+        else if (!strncmp(line, "sink=", 5)) {
+            if ((devdef->sink = pa_xstrdup(line+5)) == NULL)
+                sts = -1;
+        }
+        else {
+            if ((end = strchr(line, '=')) == NULL) {
+                pa_log("%s: invalid definition '%s' in line %d",
+                       __FILE__, line, lineno);
+            }
+            else {
+                *end = '\0';
+                pa_log("%s: invalid key value '%s' in line %d",
+                       __FILE__, line, lineno);
+            }
+            sts = -1;
+        }
+    }
+
+    return sts;
+}
+
+static int valid_label(char *label)
+{
+    int c;
+
+    if (!isalpha(*label))
+        return 0;
+
+    while((c = *label++) != '\0') {
+        if (!isalpha(c) && isdigit(c) && c != '-' && c != '_')
+            return 0;
+    }
+
+    return 1;
+}
+
+
+
+/*
+ * Local Variables:
+ * c-basic-offset: 4
+ * indent-tabs-mode: nil
+ * End:
+ *
+ */
diff --git a/src/modules/maemo/config-file.h b/src/modules/maemo/config-file.h
new file mode 100644
index 0000000..c910e99
--- /dev/null
+++ b/src/modules/maemo/config-file.h
@@ -0,0 +1,16 @@
+#ifndef fooconfigfilefoo
+#define fooconfigfilefoo
+
+#include "userdata.h"
+
+int pa_policy_parse_config_file(struct userdata *, const char *);
+
+#endif
+
+/*
+ * Local Variables:
+ * c-basic-offset: 4
+ * indent-tabs-mode: nil
+ * End:
+ *
+ */
