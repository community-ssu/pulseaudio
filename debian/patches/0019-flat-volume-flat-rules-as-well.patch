From 1c8606f96ffff574c9a96254f52f1cc155e05e46 Mon Sep 17 00:00:00 2001
From: =?utf-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@gmail.com>
Date: Sun, 23 Nov 2008 16:55:53 +0200
Subject: [PATCH] flat-volume: flat rules as well

---
 src/modules/module-flat-volume.c |  424 +++++++++++++++++++++++++++++++-------
 1 files changed, 348 insertions(+), 76 deletions(-)

diff --git a/src/modules/module-flat-volume.c b/src/modules/module-flat-volume.c
index 122f569..f561883 100644
--- a/src/modules/module-flat-volume.c
+++ b/src/modules/module-flat-volume.c
@@ -38,6 +38,7 @@
 
 #include <pulsecore/core-error.h>
 #include <pulsecore/module.h>
+#include <pulsecore/modargs.h>
 #include <pulsecore/core-util.h>
 #include <pulsecore/log.h>
 #include <pulsecore/sink-input.h>
@@ -51,82 +52,247 @@ PA_MODULE_AUTHOR("Marc-Andre Lureau");
 PA_MODULE_DESCRIPTION("Flat volume");
 PA_MODULE_VERSION(PACKAGE_VERSION);
 PA_MODULE_LOAD_ONCE(TRUE);
-PA_MODULE_USAGE("");
+PA_MODULE_USAGE("with_virtual=<boolean>");
+
+static const char* const valid_modargs[] = {
+    "with_virtual"
+};
 
 struct userdata {
+    pa_module *m;
     pa_subscription *subscription;
     pa_hook_slot *sink_input_set_volume_hook_slot;
     pa_hook_slot *sink_input_fixate_hook_slot;
+    pa_hook_slot *sink_set_volume_hook_slot;
 
     pa_module *module_stream_restore;
+    const char *with_rule; /* ex: sink-input-.*, or NULL to disable */
+    pa_hashmap *rules;
+
+    pa_bool_t with_virtual:1;
 };
 
-static void process_input_volume_change(
-        pa_cvolume *dest_volume,
-        const pa_cvolume *dest_virtual_volume,
-        pa_channel_map *dest_channel_map,
-        pa_sink_input *this,
-        pa_sink *sink) {
+struct rule {
+    char *key; /* ex: sink-input-by-role:event */
+    pa_cvolume volume; /* real volume, virtual volume is in stream-restore entry */
+    /* NOTE: we could keep copy the entry to avoid lookups */
+};
+
+static void rule_free(struct rule *r) {
+    pa_assert(r);
+
+    pa_xfree(r->key);
+    pa_xfree(r);
+}
+
+static void rules_free_cb(void *d, void *data) {
+    rule_free(d);
+}
+
+#define ENTRY_DEVICE_OR_DEFAULT(core, e) ((e)->device && *(e)->device ? (e)->device : pa_namereg_get_default_sink_name (core))
+
+static struct rule *rules_lookup(struct userdata *u, const char *key, const struct module_stream_restore_entry *entry) {
+    struct rule *r;
+    pa_sink *sink;
+
+    pa_assert(u);
+    pa_assert(key);
+    pa_assert(entry);
+
+    r = pa_hashmap_get(u->rules, key);
+    if (r == NULL) {
+        r = pa_xnew(struct rule, 1);
+        r->key = pa_xstrdup(key);
+
+        if (!(sink = pa_namereg_get(u->m->core, ENTRY_DEVICE_OR_DEFAULT(u->m->core, entry), PA_NAMEREG_SINK, 1))) {
+            r->volume = entry->volume;
+        } else {
+            pa_sw_cvolume_divide(&r->volume, &entry->volume, pa_sink_get_volume(sink, FALSE));
+        }
+
+        pa_hashmap_put(u->rules, key, r);
+    }
 
+    return r;
+}
+
+static pa_cvolume sink_get_max_volume(struct userdata *u, pa_sink *sink, pa_sink_input *skip) {
     pa_sink_input *i;
     uint32_t idx;
-    pa_cvolume max_volume, sink_volume;
+    pa_cvolume max_volume;
+    pa_strlist *l;
+    char *name;
+    pa_bool_t set = FALSE; /* true if max_volume is at least set by 1 sink-input or 1 rule */
 
-    pa_assert(dest_volume);
-    pa_assert(dest_virtual_volume);
-    pa_assert(dest_channel_map);
+    pa_assert(u);
     pa_assert(sink);
 
-    if (!(sink->flags & PA_SINK_DECIBEL_VOLUME))
-        return;
-
-    pa_log_debug("Sink input volume changed");
-
-    max_volume = *dest_virtual_volume;
-    pa_cvolume_remap(&max_volume, dest_channel_map, &sink->channel_map);
+    pa_cvolume_mute(&max_volume, sink->sample_spec.channels);
 
     for (i = PA_SINK_INPUT(pa_idxset_first(sink->inputs, &idx)); i; i = PA_SINK_INPUT(pa_idxset_next(sink->inputs, &idx))) {
         /* skip this sink-input if we are processing a volume change request */
-        if (this && this == i)
+        if (skip && skip == i)
             continue;
 
+        if (!u->with_virtual && !i->client)
+            continue;
+
+        set = TRUE;
+
         if (pa_cvolume_max(&i->virtual_volume) > pa_cvolume_max(&max_volume)) {
             max_volume = i->virtual_volume;
             pa_cvolume_remap(&max_volume, &i->channel_map, &sink->channel_map);
         }
     }
 
-    /* Set the master volume, and normalize inputs */
-    if (!pa_cvolume_equal(&max_volume, pa_sink_get_volume(sink, TRUE))) {
+    if (!u->module_stream_restore || !u->with_rule)
+        goto end;
+
+    l = module_stream_restore_list_entries(u->module_stream_restore, u->with_rule);
+    for (;;) {
+        struct module_stream_restore_entry *entry;
+
+        l = pa_strlist_pop(l, &name);
+        if (!name)
+            break;
+
+        entry = module_stream_restore_read_entry(u->module_stream_restore, name);
+        if (!entry || !pa_streq(ENTRY_DEVICE_OR_DEFAULT(sink->core, entry), sink->name)) {
+            pa_xfree(entry);
+            pa_xfree(name);
+            continue;
+        }
+
+        set = TRUE;
+
+        if (pa_cvolume_max(&entry->volume) > pa_cvolume_max(&max_volume)) {
+            max_volume = entry->volume;
+            pa_cvolume_remap(&max_volume, &entry->channel_map, &sink->channel_map);
+        }
+
+        pa_xfree(entry);
+        pa_xfree(name);
+    }
+
+ end:
+    if (!set)
+        max_volume = *pa_sink_get_volume(sink, TRUE);
+
+    return max_volume;
+}
+
+static void sink_normalize(struct userdata *u, pa_sink *sink, const pa_cvolume *max_volume, pa_sink_input *skip) {
+    pa_cvolume sink_volume;
+    pa_sink_input *i;
+    uint32_t idx;
+
+    pa_assert(u);
+    pa_assert(sink);
+    pa_assert(max_volume);
+
+    sink_volume = *pa_sink_get_volume(sink, TRUE);
+    if (!pa_cvolume_equal(&sink_volume, max_volume)) {
+        pa_sink_set_volume(sink, max_volume);
+        max_volume = pa_sink_get_volume(sink, TRUE);
+    }
+
+    pa_log_debug("Normalize sink %s = %.2f", sink->name, (double)pa_cvolume_avg(max_volume)/PA_VOLUME_NORM);
 
-        pa_sink_set_volume(sink, &max_volume);
+    if (u->module_stream_restore && u->with_rule) {
+        pa_strlist *l;
+        char *name;
 
-        pa_log_debug("sink = %.2f (changed)", (double)pa_cvolume_avg(pa_sink_get_volume(sink, TRUE))/PA_VOLUME_NORM);
+        l = module_stream_restore_list_entries(u->module_stream_restore, u->with_rule);
+        for (;;) {
+            struct module_stream_restore_entry *entry;
+            struct rule *r;
 
-        /* Now, normalize each of the internal volume (client sink-input volume / sink master volume) */
-        for (i = PA_SINK_INPUT(pa_idxset_first(sink->inputs, &idx)); i; i = PA_SINK_INPUT(pa_idxset_next(sink->inputs, &idx))) {
-            /* skip this sink-input if we are processing a volume change request */
-            if (this && this == i)
+            l = pa_strlist_pop(l, &name);
+            if (!name)
+                break;
+
+            entry = module_stream_restore_read_entry(u->module_stream_restore, name);
+            if (!entry || !pa_streq(ENTRY_DEVICE_OR_DEFAULT(sink->core, entry), sink->name)) {
+                pa_xfree(entry);
+                pa_xfree(name);
                 continue;
+            }
 
-            sink_volume = max_volume;
-            pa_cvolume_remap(&sink_volume, &sink->channel_map, &i->channel_map);
-            pa_sw_cvolume_divide(&i->volume, &i->virtual_volume, &sink_volume);
-            pa_log_debug("sink input { id = %d, flat = %.2f, true = %.2f }",
-                         i->index,
-                         (double)pa_cvolume_avg(&i->virtual_volume)/PA_VOLUME_NORM,
-                         (double)pa_cvolume_avg(&i->volume)/PA_VOLUME_NORM);
-            pa_asyncmsgq_post(i->sink->asyncmsgq, PA_MSGOBJECT(i), PA_SINK_INPUT_MESSAGE_SET_VOLUME, pa_xnewdup(struct pa_cvolume, &i->volume, 1), 0, NULL, pa_xfree);
+            r = rules_lookup(u, name, entry);
+
+            sink_volume = *max_volume;
+            pa_cvolume_remap(&sink_volume, &sink->channel_map, &entry->channel_map);
+
+            if (pa_cvolume_max(&entry->volume) > 0) /* hack, only change true volume if flat is not 0 */
+                pa_sw_cvolume_divide(&r->volume, &entry->volume, &sink_volume);
+
+            pa_log_debug("  rule { name = %s, flat = %.2f, true = %.2f } (not applied)",
+                         name,
+                         (double)pa_cvolume_avg(&entry->volume)/PA_VOLUME_NORM,
+                         (double)pa_cvolume_avg(&r->volume)/PA_VOLUME_NORM);
+
+            pa_xfree(entry);
+            pa_xfree(name);
         }
-    } else
-        pa_log_debug("sink = %.2f", (double)pa_cvolume_avg(pa_sink_get_volume(sink, TRUE))/PA_VOLUME_NORM);
+    }
+
+    /* Now, normalize each of the internal volume (client sink-input volume / sink master volume) */
+    for (i = PA_SINK_INPUT(pa_idxset_first(sink->inputs, &idx)); i; i = PA_SINK_INPUT(pa_idxset_next(sink->inputs, &idx))) {
+        /* skip this sink-input if we are processing a volume change request */
+        if (skip && skip == i)
+            continue;
+
+        if (!u->with_virtual && !i->client)
+            continue;
+
+        sink_volume = *max_volume;
+        pa_cvolume_remap(&sink_volume, &sink->channel_map, &i->channel_map);
+        pa_sw_cvolume_divide(&i->volume, &i->virtual_volume, &sink_volume);
+        pa_log_debug("  sink input { id = %d, flat = %.2f, true = %.2f }",
+                     i->index,
+                     (double)pa_cvolume_avg(&i->virtual_volume)/PA_VOLUME_NORM,
+                     (double)pa_cvolume_avg(&i->volume)/PA_VOLUME_NORM);
+        pa_asyncmsgq_post(i->sink->asyncmsgq, PA_MSGOBJECT(i), PA_SINK_INPUT_MESSAGE_SET_VOLUME, pa_xnewdup(struct pa_cvolume, &i->volume, 1), 0, NULL, pa_xfree);
+    }
+
+}
+
+static void process_input_volume_change(
+        struct userdata *u,
+        pa_cvolume *dest_volume,
+        const pa_cvolume *dest_virtual_volume,
+        pa_channel_map *dest_channel_map,
+        pa_sink_input *this, /* NULL in case of fixate, otherwise it's a volume change */
+        pa_sink *sink) {
+
+    pa_cvolume max_volume, sink_volume;
+
+    pa_assert(dest_volume);
+    pa_assert(dest_virtual_volume);
+    pa_assert(dest_channel_map);
+    pa_assert(sink);
+
+    if (!u->with_virtual && this && !this->client)
+        return;
 
-    /* and this one */
+    pa_log_debug("sink-input hook call: { id = %d, flat = %.2f, true = %.2f }",
+                 this ? (int)this->index : -1,
+                 (double)pa_cvolume_avg(dest_virtual_volume)/PA_VOLUME_NORM,
+                 (double)pa_cvolume_avg(dest_volume)/PA_VOLUME_NORM);
+
+    max_volume = sink_get_max_volume(u, sink, this);
+    if (pa_cvolume_max(dest_virtual_volume) > pa_cvolume_max(&max_volume)) {
+        max_volume = *dest_virtual_volume;
+        pa_cvolume_remap(&max_volume, dest_channel_map, &sink->channel_map);
+    }
+
+    sink_normalize(u, sink, &max_volume, this);
 
+    /* and this request */
     sink_volume = max_volume;
     pa_cvolume_remap(&sink_volume, &sink->channel_map, dest_channel_map);
     pa_sw_cvolume_divide(dest_volume, dest_virtual_volume, &sink_volume);
-    pa_log_debug("caller sink input: { id = %d, flat = %.2f, true = %.2f }",
+    pa_log_debug("sink-input hook result: { id = %d, flat = %.2f, true = %.2f }",
                  this ? (int)this->index : -1,
                  (double)pa_cvolume_avg(dest_virtual_volume)/PA_VOLUME_NORM,
                  (double)pa_cvolume_avg(dest_volume)/PA_VOLUME_NORM);
@@ -136,7 +302,7 @@ static pa_hook_result_t sink_input_set_volume_hook_callback(pa_core *c, pa_sink_
     pa_assert(this);
     pa_assert(this->sink_input);
 
-    process_input_volume_change(&this->volume, &this->virtual_volume, &this->sink_input->channel_map,
+    process_input_volume_change(u, &this->volume, &this->virtual_volume, &this->sink_input->channel_map,
                                 this->sink_input, this->sink_input->sink);
 
     return PA_HOOK_OK;
@@ -146,83 +312,184 @@ static pa_hook_result_t sink_input_fixate_hook_callback(pa_core *core, pa_sink_i
     pa_assert(this);
     pa_assert(this->sink);
 
-    process_input_volume_change(&this->volume, &this->virtual_volume, &this->channel_map,
+    process_input_volume_change(u, &this->volume, &this->virtual_volume, &this->channel_map,
                                 NULL, this->sink);
 
     return PA_HOOK_OK;
 }
 
-static void subscribe_callback(pa_core *core, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
-    struct userdata *u = userdata;
+static pa_hook_result_t sink_set_volume_hook_callback(pa_core *c, pa_sink_set_volume_data *this, struct userdata *u) {
+    pa_cvolume sink_volume;
+    pa_cvolume si_volume;
     pa_sink *sink;
     pa_sink_input *i;
     uint32_t iidx;
-    pa_cvolume sink_volume;
+
+    pa_assert(this);
+    pa_assert(this->sink);
+
+    sink = this->sink;
+
+    sink_volume = this->virtual_volume;
+    pa_log_debug("Hook sink %s volume to %.2f/%.2f", sink->name, (double)pa_cvolume_avg(&sink_volume) / PA_VOLUME_NORM, (double)pa_cvolume_avg(&this->volume) / PA_VOLUME_NORM);
+
+    if (u->module_stream_restore && u->with_rule) {
+        pa_strlist *l;
+        char *name;
+
+        l = module_stream_restore_list_entries(u->module_stream_restore, u->with_rule);
+        for (;;) {
+            struct module_stream_restore_entry *entry;
+            struct rule *r;
+
+            l = pa_strlist_pop(l, &name);
+            if (!name)
+                break;
+
+            entry = module_stream_restore_read_entry(u->module_stream_restore, name);
+            if (!entry || !pa_streq(ENTRY_DEVICE_OR_DEFAULT(c, entry), sink->name)) {
+                pa_xfree(entry);
+                pa_xfree(name);
+                continue;
+            }
+
+            r = rules_lookup(u, name, entry);
+
+            si_volume = sink_volume;
+            pa_cvolume_remap(&si_volume, &sink->channel_map, &entry->channel_map);
+            pa_log_debug("rule { name = %s, flat = %.2f, true = %.2f } (before)",
+                         name,
+                         (double)pa_cvolume_avg(&entry->volume)/PA_VOLUME_NORM,
+                         (double)pa_cvolume_avg(&r->volume)/PA_VOLUME_NORM);
+            pa_sw_cvolume_multiply(&si_volume, &r->volume, &si_volume);
+            if (!pa_cvolume_equal(&si_volume, &entry->volume)) {
+                entry->volume = si_volume;
+                module_stream_restore_update_entry(u->module_stream_restore, PA_UPDATE_REPLACE, name, entry, TRUE);
+                pa_log_debug("rule = { name = %s, flat = %.2f, true = %.2f } (updated)",
+                             name,
+                             (double)pa_cvolume_avg(&entry->volume)/PA_VOLUME_NORM,
+                             (double)pa_cvolume_avg(&r->volume)/PA_VOLUME_NORM);
+            }
+
+            pa_xfree(entry);
+            pa_xfree(name);
+        }
+    }
+
+    for (i = PA_SINK_INPUT(pa_idxset_first(sink->inputs, &iidx)); i; i = PA_SINK_INPUT(pa_idxset_next(sink->inputs, &iidx))) {
+        si_volume = sink_volume;
+        pa_cvolume_remap(&si_volume, &sink->channel_map, &i->channel_map);
+        pa_sw_cvolume_multiply(&si_volume, &i->volume, &si_volume);
+
+        if (!u->with_virtual && !i->client)
+            continue;
+
+        if (!pa_cvolume_equal(&si_volume, &i->virtual_volume)) {
+            i->virtual_volume = si_volume;
+            pa_subscription_post(i->sink->core, PA_SUBSCRIPTION_EVENT_SINK_INPUT|PA_SUBSCRIPTION_EVENT_CHANGE, i->index);
+            pa_log_debug("sink input = { id = %d, flat = %.2f, true = %.2f } (updated)",
+                         i->index,
+                         (double)pa_cvolume_avg(&i->virtual_volume)/PA_VOLUME_NORM,
+                         (double)pa_cvolume_avg(&i->volume)/PA_VOLUME_NORM);
+        }
+    }
+
+    return PA_HOOK_OK;
+}
+
+static void subscribe_callback(pa_core *core, pa_subscription_event_type_t t, uint32_t idx, void *userdata) {
+    pa_sink *sink;
+    struct userdata *u = userdata;
+    pa_sink_set_volume_data data;
 
     pa_assert(core);
     pa_assert(u);
 
+    if (t != (PA_SUBSCRIPTION_EVENT_SINK|PA_SUBSCRIPTION_EVENT_NEW) &&
+        t != (PA_SUBSCRIPTION_EVENT_SINK|PA_SUBSCRIPTION_EVENT_CHANGE) &&
+        t != (PA_SUBSCRIPTION_EVENT_MODULE|PA_SUBSCRIPTION_EVENT_CHANGE))
+        return;
+
     if (u->module_stream_restore &&
         t == (PA_SUBSCRIPTION_EVENT_MODULE|PA_SUBSCRIPTION_EVENT_CHANGE) &&
         idx == u->module_stream_restore->index) {
-        pa_log_debug("Stream-restore changed");
-        return;
-    }
+        pa_cvolume max_volume;
+        uint32_t iidx;
 
-    if (t != (PA_SUBSCRIPTION_EVENT_SINK|PA_SUBSCRIPTION_EVENT_NEW) &&
-        t != (PA_SUBSCRIPTION_EVENT_SINK|PA_SUBSCRIPTION_EVENT_CHANGE))
-        return;
+        pa_log_debug("Some rule changed (normalizing all sinks):");
 
-    if (!(sink = pa_idxset_get_by_index(core->sinks, idx)))
-        return;
+        for (sink = PA_SINK(pa_idxset_first(core->sinks, &iidx)); sink; sink = PA_SINK(pa_idxset_next(core->sinks, &iidx))) {
+            max_volume = sink_get_max_volume(u, sink, NULL);
+            sink_normalize(u, sink, &max_volume, NULL);
+        }
 
-    if (!(sink->flags & PA_SINK_DECIBEL_VOLUME))
         return;
+    }
 
-    pa_log_debug("Sink volume changed");
-    pa_log_debug("sink = %.2f", (double)pa_cvolume_avg(pa_sink_get_volume(sink, TRUE)) / PA_VOLUME_NORM);
-
-    sink_volume = *pa_sink_get_volume(sink, TRUE);
-
-    for (i = PA_SINK_INPUT(pa_idxset_first(sink->inputs, &iidx)); i; i = PA_SINK_INPUT(pa_idxset_next(sink->inputs, &iidx))) {
-        pa_cvolume si_volume;
+    if (!(sink = pa_idxset_get_by_index(core->sinks, idx)))
+        return;
 
-        si_volume = sink_volume;
-        pa_cvolume_remap(&si_volume, &sink->channel_map, &i->channel_map);
-        pa_sw_cvolume_multiply(&i->virtual_volume, &i->volume, &si_volume);
-        pa_log_debug("sink input = { id = %d, flat = %.2f, true = %.2f }",
-                     i->index,
-                     (double)pa_cvolume_avg(&i->virtual_volume)/PA_VOLUME_NORM,
-                     (double)pa_cvolume_avg(&i->volume)/PA_VOLUME_NORM);
-        pa_subscription_post(i->sink->core, PA_SUBSCRIPTION_EVENT_SINK_INPUT|PA_SUBSCRIPTION_EVENT_CHANGE, i->index);
-    }
+    data.sink = sink;
+    data.virtual_volume = sink->virtual_volume;
+    data.volume = sink->volume;
+    sink_set_volume_hook_callback(core, &data, u);
 }
 
 int pa__init(pa_module*m) {
+    pa_modargs *ma = NULL;
     struct userdata *u;
     pa_module *i;
     uint32_t idx;
+    pa_bool_t with_virtual = FALSE;
 
     pa_assert(m);
 
-    u = pa_xnew(struct userdata, 1);
+    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+        pa_log("Failed to parse module arguments");
+        goto fail;
+    }
+
+    if (pa_modargs_get_value_boolean(ma, "with_virtual", &with_virtual) < 0) {
+        pa_log("with_virtual= expect boolean arguments");
+        goto fail;
+    }
+
+    u = pa_xnew0(struct userdata, 1);
     m->userdata = u;
+    u->m = m;
 
+    u->with_virtual = with_virtual;
     u->sink_input_fixate_hook_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_INPUT_FIXATE], PA_HOOK_LATE, (pa_hook_cb_t) sink_input_fixate_hook_callback, u);
     u->sink_input_set_volume_hook_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_INPUT_SET_VOLUME], PA_HOOK_LATE, (pa_hook_cb_t) sink_input_set_volume_hook_callback, u);
 
+#if 0
+    u->sink_set_volume_hook_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_SET_VOLUME], PA_HOOK_LATE, (pa_hook_cb_t) sink_set_volume_hook_callback, u);
+#endif
     u->subscription = pa_subscription_new(m->core, PA_SUBSCRIPTION_MASK_SINK | PA_SUBSCRIPTION_MASK_MODULE, subscribe_callback, u);
 
     u->module_stream_restore = NULL;
-    for (i = pa_idxset_first(m->core->modules, &idx); i; i = pa_idxset_next(m->core->modules, &idx)) {
-        if (pa_streq(i->name, "module-stream-restore")) {
-            pa_log_debug("flat-volume will update stream-restore rules");
-            u->module_stream_restore = i;
-            break;
+    if (m->core->modules) {
+        for (i = pa_idxset_first(m->core->modules, &idx); i; i = pa_idxset_next(m->core->modules, &idx)) {
+            if (pa_streq(i->name, "module-stream-restore")) {
+                pa_log_debug("flat-volume will update stream-restore rules");
+                u->module_stream_restore = i;
+                break;
+            }
         }
     }
 
+    u->with_rule = "sink-input-by-media-role.*"; /* we might want to disable it, at least for testing */
+    u->rules = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
+
     return 0;
+
+ fail:
+    pa__done(m);
+
+    if (ma)
+        pa_modargs_free(ma);
+
+    return  -1;
 }
 
 void pa__done(pa_module*m) {
@@ -234,12 +501,17 @@ void pa__done(pa_module*m) {
         return;
 
     if (u->subscription)
-      pa_subscription_free(u->subscription);
+        pa_subscription_free(u->subscription);
 
     if (u->sink_input_set_volume_hook_slot)
         pa_hook_slot_free(u->sink_input_set_volume_hook_slot);
     if (u->sink_input_fixate_hook_slot)
         pa_hook_slot_free(u->sink_input_fixate_hook_slot);
+    if (u->sink_set_volume_hook_slot)
+        pa_hook_slot_free(u->sink_set_volume_hook_slot);
+
+    if (u->rules)
+        pa_hashmap_free(u->rules, rules_free_cb, NULL);
 
     pa_xfree(u);
 }
-- 
1.6.0.2.514.g23abd3

