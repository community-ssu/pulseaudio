From b5f2b32d7a09e6c412f163c8bfc7c1a10a23da28 Mon Sep 17 00:00:00 2001
From: Pekka Ervasti <peervast@gmail.com>
Date: Wed, 6 May 2009 18:02:40 +0300
Subject: [PATCH 43/43] alsa-*-old: delay by timestamps

---
 src/modules/alsa/module-alsa-sink-old.c   |   64 ++++++++++++++++++++++++++---
 src/modules/alsa/module-alsa-source-old.c |   62 +++++++++++++++++++++++++---
 2 files changed, 114 insertions(+), 12 deletions(-)

diff --git a/src/modules/alsa/module-alsa-sink-old.c b/src/modules/alsa/module-alsa-sink-old.c
index 90a1eb6..8842778 100644
--- a/src/modules/alsa/module-alsa-sink-old.c
+++ b/src/modules/alsa/module-alsa-sink-old.c
@@ -31,6 +31,7 @@
 
 #include <pulse/xmalloc.h>
 #include <pulse/util.h>
+#include <pulse/timeval.h>
 
 #ifdef HAVE_VALGRIND_MEMCHECK_H
 #include <valgrind/memcheck.h>
@@ -50,6 +51,7 @@
 #include <pulsecore/thread-mq.h>
 #include <pulsecore/rtpoll.h>
 #include <pulsecore/atomic.h>
+#include <pulsecore/rtclock.h>
 
 #include "alsa-util.h"
 #include "module-alsa-sink-old-symdef.h"
@@ -80,6 +82,8 @@ PA_MODULE_USAGE(
 #define PROP_BUFFERS_PRIMARY "primary"
 #define PROP_BUFFERS_ALTERNATIVE "alternative"
 
+#define SYSFS_TS_PLAYBACK "/sys/devices/platform/omap-mcbsp.2/ts_playback"
+
 struct userdata {
     pa_core *core;
     pa_module *module;
@@ -118,6 +122,8 @@ struct userdata {
     pa_bool_t first;
 
     pa_rtpoll_item *alsa_rtpoll_item;
+
+    int sysfs_ts_fd;
 };
 
 static const char* const valid_modargs[] = {
@@ -362,6 +368,42 @@ static int unix_write(struct userdata *u) {
     }
 }
 
+static int sink_get_latency_by_timestamps(struct userdata *u, pa_usec_t *d) {
+    struct timespec ts_dma;
+    struct timeval tv_now;
+    pa_usec_t fragment_usec;
+    char buf[80];
+    ssize_t c;
+    uint32_t val;
+
+    pa_assert(u);
+    pa_assert(d);
+
+    if (u->sysfs_ts_fd == -1)
+        return -1;
+
+    if (lseek(u->sysfs_ts_fd, 0, SEEK_SET))
+        return -1;
+    if ((c = read(u->sysfs_ts_fd, buf, sizeof(buf))) == -1)
+        return -1;
+    buf[c-1] = '\0';
+
+    c = strcspn(buf, ",");
+    buf[c] = '\0';
+
+    pa_atou(buf, &val);
+    ts_dma.tv_sec = val;
+    pa_atou(&buf[c+2], &val);
+    ts_dma.tv_nsec = val;
+
+    pa_rtclock_get(&tv_now);
+
+    fragment_usec = pa_bytes_to_usec(u->fragment_size, &u->sink->sample_spec);
+    *d = pa_timespec_load(&ts_dma) + fragment_usec - pa_timeval_load(&tv_now);
+
+    return 0;
+}
+
 static pa_usec_t sink_get_latency(struct userdata *u) {
     pa_usec_t r = 0;
     snd_pcm_status_t *status;
@@ -373,13 +415,15 @@ static pa_usec_t sink_get_latency(struct userdata *u) {
     pa_assert(u);
     pa_assert(u->pcm_handle);
 
-    if ((err = snd_pcm_status(u->pcm_handle, status)) < 0)
-        pa_log("Failed to get delay: %s", snd_strerror(err));
-    else
-        frames = snd_pcm_status_get_delay(status);
+    if (sink_get_latency_by_timestamps(u, &r) < 0) {
+        if ((err = snd_pcm_status(u->pcm_handle, status)) < 0)
+            pa_log("Failed to get delay: %s", snd_strerror(err));
+        else
+            frames = snd_pcm_status_get_delay(status);
 
-    if (frames > 0)
-        r = pa_bytes_to_usec(frames * u->frame_size, &u->sink->sample_spec);
+        if (frames > 0)
+            r = pa_bytes_to_usec(frames * u->frame_size, &u->sink->sample_spec);
+    }
 
     if (u->memchunk.memblock)
         r += pa_bytes_to_usec(u->memchunk.length, &u->sink->sample_spec);
@@ -927,6 +971,11 @@ int pa__init(pa_module*m) {
                                                         PA_HOOK_LATE,
                                                         (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
 
+    u->sysfs_ts_fd = open(SYSFS_TS_PLAYBACK, O_RDONLY);
+
+    if (u->sysfs_ts_fd == -1)
+        pa_log_info("playback sysfs ts file open failed");
+
     pa_sink_put(u->sink);
 
     pa_modargs_free(ma);
@@ -985,4 +1034,7 @@ void pa__done(pa_module*m) {
     pa_xfree(u);
 
     snd_config_update_free_global();
+
+    if (u->sysfs_ts_fd != -1)
+        close(u->sysfs_ts_fd);
 }
diff --git a/src/modules/alsa/module-alsa-source-old.c b/src/modules/alsa/module-alsa-source-old.c
index 9c24664..c9adc52 100644
--- a/src/modules/alsa/module-alsa-source-old.c
+++ b/src/modules/alsa/module-alsa-source-old.c
@@ -35,6 +35,7 @@
 
 #include <pulse/xmalloc.h>
 #include <pulse/util.h>
+#include <pulse/timeval.h>
 
 #include <pulsecore/core-error.h>
 #include <pulsecore/core.h>
@@ -50,6 +51,7 @@
 #include <pulsecore/core-error.h>
 #include <pulsecore/thread-mq.h>
 #include <pulsecore/rtpoll.h>
+#include <pulsecore/rtclock.h>
 
 #include "alsa-util.h"
 #include "module-alsa-source-old-symdef.h"
@@ -81,6 +83,8 @@ PA_MODULE_USAGE(
 #define PROP_BUFFERS_PRIMARY "primary"
 #define PROP_BUFFERS_ALTERNATIVE "alternative"
 
+#define SYSFS_TS_CAPTURE "/sys/devices/platform/omap-mcbsp.2/ts_capture"
+
 struct userdata {
     pa_core *core;
     pa_module *module;
@@ -126,6 +130,8 @@ struct userdata {
     pa_rtpoll_item *alsa_rtpoll_item;
 
     snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
+
+    int sysfs_ts_fd;
 };
 
 static const char* const valid_modargs[] = {
@@ -364,6 +370,40 @@ static int unix_read(struct userdata *u) {
     }
 }
 
+static int source_get_latency_by_timestamps(struct userdata *u, pa_usec_t *d) {
+    struct timespec ts_dma;
+    struct timeval tv_now;
+    char buf[80];
+    ssize_t c;
+    uint32_t val;
+
+    pa_assert(u);
+    pa_assert(d);
+
+    if (u->sysfs_ts_fd == -1)
+        return -1;
+
+    if (lseek(u->sysfs_ts_fd, 0, SEEK_SET))
+        return -1;
+    if ((c = read(u->sysfs_ts_fd, buf, sizeof(buf))) == -1)
+        return -1;
+    buf[c-1] = '\0';
+
+    c = strcspn(buf, ",");
+    buf[c] = '\0';
+
+    pa_atou(buf, &val);
+    ts_dma.tv_sec = val;
+    pa_atou(&buf[c+2], &val);
+    ts_dma.tv_nsec = val;
+
+    pa_rtclock_get(&tv_now);
+
+    *d = pa_timeval_load(&tv_now) - pa_timespec_load(&ts_dma);
+
+    return 0;
+}
+
 static pa_usec_t source_get_latency(struct userdata *u) {
     pa_usec_t r = 0;
     snd_pcm_status_t *status;
@@ -375,13 +415,15 @@ static pa_usec_t source_get_latency(struct userdata *u) {
     pa_assert(u);
     pa_assert(u->pcm_handle);
 
-    if ((err = snd_pcm_status(u->pcm_handle, status)) < 0)
-        pa_log("Failed to get delay: %s", snd_strerror(err));
-    else
-        frames = snd_pcm_status_get_delay(status);
+    if (source_get_latency_by_timestamps(u, &r) < 0) {
+        if ((err = snd_pcm_status(u->pcm_handle, status)) < 0)
+            pa_log("Failed to get delay: %s", snd_strerror(err));
+        else
+            frames = snd_pcm_status_get_delay(status);
 
-    if (frames > 0)
-        r = pa_bytes_to_usec(frames * u->frame_size, &u->source->sample_spec);
+        if (frames > 0)
+            r = pa_bytes_to_usec(frames * u->frame_size, &u->source->sample_spec);
+    }
 
     return r;
 }
@@ -1293,6 +1335,11 @@ int pa__init(pa_module*m) {
                                                           PA_HOOK_LATE,
                                                           (pa_hook_cb_t)source_proplist_changed_hook_callback, u);
 
+    u->sysfs_ts_fd = open(SYSFS_TS_CAPTURE, O_RDONLY);
+
+    if (u->sysfs_ts_fd == -1)
+        pa_log_info("capture sysfs ts file open failed");
+
     pa_source_put(u->source);
 
     if (alsa_mixer)
@@ -1357,4 +1404,7 @@ void pa__done(pa_module*m) {
     pa_xfree(u);
 
     snd_config_update_free_global();
+
+    if (u->sysfs_ts_fd != -1)
+        close(u->sysfs_ts_fd);
 }
-- 
1.6.2.4

