From 8dbebb0ce799e5a83bf2840187b4b439b8141875 Mon Sep 17 00:00:00 2001
From: Juho Hamalainen <ext-juho.hamalainen@nokia.com>
Date: Thu, 5 Mar 2009 13:42:53 +0200
Subject: [PATCH 10/49] alsa-sink-volume: copy from alsa-sink-old

---
 src/Makefile.am                            |   12 +-
 src/modules/alsa/module-alsa-sink-volume.c | 2244 ++++++++++++++++++++++++++++
 2 files changed, 2252 insertions(+), 4 deletions(-)
 create mode 100644 src/modules/alsa/module-alsa-sink-volume.c

diff --git a/src/Makefile.am b/src/Makefile.am
index 070eedd..9e8ed8c 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -965,13 +965,11 @@ modlibexec_LTLIBRARIES += \
 		libalsa-util.la \
 		module-alsa-sink.la \
 		module-alsa-source.la \
-		module-alsa-card.la
-if HAVE_DBUS
-modlibexec_LTLIBRARIES += \
+		module-alsa-card.la \
 		module-alsa-sink-old.la \
+		module-alsa-sink-volume.la \
 		module-alsa-source-old.la
 endif
-endif
 
 if HAVE_SOLARIS
 modlibexec_LTLIBRARIES += \
@@ -1084,6 +1082,7 @@ SYMDEF_FILES = \
 		modules/alsa/module-alsa-source-symdef.h \
 		modules/alsa/module-alsa-card-symdef.h \
 		modules/alsa/module-alsa-sink-old-symdef.h \
+		modules/alsa/module-alsa-sink-volume-symdef.h \
 		modules/alsa/module-alsa-source-old-symdef.h \
 		modules/module-solaris-symdef.h \
 		modules/module-waveout-symdef.h \
@@ -1317,6 +1316,11 @@ module_alsa_sink_old_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_alsa_sink_old_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
 module_alsa_sink_old_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
 
+module_alsa_sink_volume_la_SOURCES = modules/alsa/module-alsa-sink-volume.c
+module_alsa_sink_volume_la_LDFLAGS = $(MODULE_LDFLAGS)
+module_alsa_sink_volume_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
+module_alsa_sink_volume_la_CFLAGS = $(AM_CFLAGS) $(ASOUNDLIB_CFLAGS)
+
 module_alsa_source_old_la_SOURCES = modules/alsa/module-alsa-source-old.c
 module_alsa_source_old_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_alsa_source_old_la_LIBADD = $(AM_LIBADD) $(ASOUNDLIB_LIBS) libalsa-util.la libpulsecore-@PA_MAJORMINORMICRO@.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
diff --git a/src/modules/alsa/module-alsa-sink-volume.c b/src/modules/alsa/module-alsa-sink-volume.c
new file mode 100644
index 0000000..b909274
--- /dev/null
+++ b/src/modules/alsa/module-alsa-sink-volume.c
@@ -0,0 +1,2244 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright (C) 2008-2009 Nokia Corporation and/or its subsidiary(-ies).
+  Copyright 2004-2006 Lennart Poettering
+  Copyright 2006 Pierre Ossman <ossman@cendio.se> for Cendio AB
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published
+  by the Free Software Foundation; either version 2 of the License,
+  or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with PulseAudio; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <gdbm.h>
+
+#include <asoundlib.h>
+
+#include <pulse/xmalloc.h>
+#include <pulse/util.h>
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+#include <valgrind/memcheck.h>
+#endif
+
+#include <pulsecore/core.h>
+#include <pulsecore/module.h>
+#include <pulsecore/memchunk.h>
+#include <pulsecore/sink.h>
+#include <pulsecore/modargs.h>
+#include <pulsecore/core-util.h>
+#include <pulsecore/sample-util.h>
+#include <pulsecore/log.h>
+#include <pulsecore/macro.h>
+#include <pulsecore/thread.h>
+#include <pulsecore/core-error.h>
+#include <pulsecore/thread-mq.h>
+#include <pulsecore/rtpoll.h>
+#include <pulsecore/atomic.h>
+
+#include "alsa-util.h"
+#include "module-alsa-sink-volume-symdef.h"
+#include "module-alsa-sink-old.h"
+
+PA_MODULE_AUTHOR("Lennart Poettering");
+PA_MODULE_DESCRIPTION("ALSA Sink");
+PA_MODULE_VERSION(PACKAGE_VERSION);
+PA_MODULE_LOAD_ONCE(FALSE);
+PA_MODULE_USAGE(
+        "sink_name=<name for the sink> "
+        "device=<ALSA device> "
+        "device_id=<ALSA device id> "
+        "format=<sample format> "
+        "channels=<number of channels> "
+        "rate=<sample rate> "
+        "mixer=<initial ALSA mixer> "
+        "mixer_load=<load mixer controls in startup> "
+        "fragments=<number of fragments> "
+        "fragment_size=<fragment size> "
+        "alt_fragments=<number of fragments> "
+        "alt_fragment_size=<fragment size> "
+        "channel_map=<channel map> "
+        "mmap=<enable memory mapping?>");
+
+#define DEFAULT_DEVICE "default"
+
+#define SINK_SWITCH_PRIMARY (0)
+#define SINK_SWITCH_ALTERNATIVE (1)
+
+struct gain_step_t {
+    int step;
+    pa_bool_t enabled;
+    pa_volume_t volume;
+    PA_LLIST_FIELDS(struct gain_step_t);
+};
+
+struct mixer_control_t {
+    char *name;
+    pa_alsa_fdlist *mixer_fdl;
+    snd_mixer_elem_t *mixer_elem;
+    snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
+    unsigned channels;
+
+    pa_bool_t hw_volume_control;
+
+    long hw_volume_max, hw_volume_min;
+    long hw_dB_max, hw_dB_min;
+    pa_bool_t hw_dB_supported;
+    pa_bool_t mixer_separate_channels;
+    pa_cvolume hardware_volume;
+
+    PA_LLIST_HEAD(struct gain_step_t, gain_step);
+    struct mixer_control_t **slaves;
+    pa_bool_t slave;
+
+    /* store mixer volumes when mixer not in use */
+    pa_cvolume cache_volume;
+    pa_bool_t cache_muted;
+
+    PA_LLIST_FIELDS(struct mixer_control_t);
+};
+
+struct userdata {
+    pa_core *core;
+    pa_module *module;
+    pa_sink *sink;
+    pa_sink_flags_t default_flags;
+
+    pa_thread *thread;
+    pa_thread_mq thread_mq;
+    pa_rtpoll *rtpoll;
+
+    snd_pcm_t *pcm_handle;
+    snd_mixer_t *mixer_handle;
+
+    size_t frame_size, fragment_size, hwbuf_size;
+    snd_pcm_uframes_t period_size;
+    unsigned nfragments;
+    pa_memchunk memchunk;
+
+    size_t pri_frame_size, pri_fragment_size, pri_hwbuf_size;
+    snd_pcm_uframes_t pri_period_size;
+    unsigned pri_nfragments;
+
+    size_t alt_frame_size, alt_fragment_size, alt_hwbuf_size;
+    snd_pcm_uframes_t alt_period_size;
+    unsigned alt_nfragments;
+
+    pa_bool_t switching_enabled;
+    int switch_mode;
+
+    /* store for all loaded mixers */
+    PA_LLIST_HEAD(struct mixer_control_t, mixer_list);
+    struct mixer_control_t *active_mixer;
+    pa_channel_map channel_map;
+
+    pa_hook_slot *sink_proplist_changed_slot;
+
+    char *device_name;
+
+    pa_bool_t use_mmap;
+
+    pa_bool_t first;
+    pa_bool_t ignore_dB;
+
+    pa_rtpoll_item *alsa_rtpoll_item;
+
+    /* store mixer volumes */
+    GDBM_FILE gdbm_file;
+    pa_bool_t cache_volumes;
+};
+
+#define ENTRY_VERSION 1
+
+struct entry {
+    uint8_t version;
+    pa_bool_t muted:1;
+    pa_cvolume volume;
+} PA_GCC_PACKED;
+
+static const char* const valid_modargs[] = {
+    "device",
+    "device_id",
+    "sink_name",
+    "format",
+    "channels",
+    "rate",
+    "mixer",
+    "mixer_load",
+    "fragments",
+    "fragment_size",
+    "alt_fragments",
+    "alt_fragment_size",
+    "channel_map",
+    "mmap",
+    NULL
+};
+
+static void replace_chars(char *str, const char c, const char new_c) {
+    unsigned ii = 0;
+    pa_assert(str);
+    while(str[ii++] != '\0') { // is there a pa function for this?
+        if (str[ii] == c)
+            str[ii] = new_c;
+    }
+}
+
+static void switch_buffers(struct userdata *u, int switch_mode) {
+    unsigned num_inputs = 0;
+
+    pa_assert(u->sink);
+
+    if (!u->switching_enabled) {
+        pa_log_info("switch_buffers() switching disabled by config (no alt_ parameters)");
+        return;
+    }
+    if (switch_mode == u->switch_mode) {
+        pa_log_debug("switch_buffers() same mode as previously");
+        return;
+    }
+    u->switch_mode = switch_mode;
+    num_inputs = pa_idxset_size(u->sink->inputs);
+
+    pa_log_debug("switch_buffers() got %d inputs", num_inputs);
+
+    /* Suspend is dependent on the context where switch_buffers is run.
+     * If using from thread_func, internal suspend() should be used. */
+    pa_sink_suspend(u->sink, TRUE);
+
+    if (u->switch_mode == SINK_SWITCH_PRIMARY) {
+        pa_log_info("switch to primary buffer");
+        u->frame_size = u->pri_frame_size;
+        u->fragment_size = u->pri_fragment_size;
+        u->hwbuf_size = u->pri_hwbuf_size;
+        u->nfragments = u->pri_nfragments;
+        u->period_size = u->pri_period_size;
+    } else {
+        pa_log_info("switch to alternate buffer");
+        u->frame_size = u->alt_frame_size;
+        u->fragment_size = u->alt_fragment_size;
+        u->hwbuf_size = u->alt_hwbuf_size;
+        u->nfragments = u->alt_nfragments;
+        u->period_size = u->alt_period_size;
+    }
+
+    /* update buffer metrics */
+    pa_proplist_setf(u->sink->proplist,
+                     PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE,
+                     "%lu", (unsigned long) (u->period_size * u->frame_size * u->nfragments));
+    pa_proplist_setf(u->sink->proplist,
+                     PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE,
+                     "%lu", (unsigned long) (u->period_size * u->frame_size));
+
+    if (num_inputs > 0)
+        pa_sink_suspend(u->sink, FALSE);
+}
+
+static int mmap_write(struct userdata *u) {
+    int work_done = 0;
+
+    pa_assert(u);
+    pa_sink_assert_ref(u->sink);
+
+    for (;;) {
+        pa_memchunk chunk;
+        void *p;
+        snd_pcm_sframes_t n;
+        int err;
+        const snd_pcm_channel_area_t *areas;
+        snd_pcm_uframes_t offset, frames;
+
+        if ((n = snd_pcm_avail_update(u->pcm_handle)) < 0) {
+
+            if (n == -EPIPE) {
+                pa_log_debug("snd_pcm_avail_update: Buffer underrun!");
+                u->first = TRUE;
+            }
+
+            if ((err = snd_pcm_recover(u->pcm_handle, n, 1)) == 0)
+                continue;
+
+            if (err == -EAGAIN)
+                return work_done;
+
+            pa_log("snd_pcm_avail_update: %s", snd_strerror(err));
+            return -1;
+        }
+
+        /*         pa_log("Got request for %i samples", (int) n); */
+
+        frames = n - (n % u->period_size);
+
+        if (frames <= 0)
+            return work_done;
+
+        if ((err = snd_pcm_mmap_begin(u->pcm_handle, &areas, &offset, &frames)) < 0) {
+
+            if (err == -EPIPE) {
+                pa_log_debug("snd_pcm_mmap_begin: Buffer underrun!");
+                u->first = TRUE;
+            }
+
+            if ((err = snd_pcm_recover(u->pcm_handle, err, 1)) == 0)
+                continue;
+
+            if (err == -EAGAIN)
+                return work_done;
+
+            pa_log("Failed to write data to DSP: %s", snd_strerror(err));
+            return -1;
+        }
+
+        /* Check these are multiples of 8 bit */
+        pa_assert((areas[0].first & 7) == 0);
+        pa_assert((areas[0].step & 7)== 0);
+
+        /* We assume a single interleaved memory buffer */
+        pa_assert((areas[0].first >> 3) == 0);
+        pa_assert((areas[0].step >> 3) == u->frame_size);
+
+        p = (uint8_t*) areas[0].addr + (offset * u->frame_size);
+
+        chunk.memblock = pa_memblock_new_fixed(u->core->mempool, p, frames * u->frame_size, 1);
+        chunk.length = pa_memblock_get_length(chunk.memblock);
+        chunk.index = 0;
+
+        pa_sink_render_into_full(u->sink, &chunk);
+
+        /* FIXME: Maybe we can do something to keep this memory block
+         * a little bit longer around? */
+        pa_memblock_unref_fixed(chunk.memblock);
+
+        if ((err = snd_pcm_mmap_commit(u->pcm_handle, offset, frames)) < 0) {
+
+            if (err == -EPIPE) {
+                pa_log_debug("snd_pcm_mmap_commit: Buffer underrun!");
+                u->first = TRUE;
+            }
+
+            if ((err = snd_pcm_recover(u->pcm_handle, err, 1)) == 0)
+                continue;
+
+            if (err == -EAGAIN)
+                return work_done;
+
+            pa_log("Failed to write data to DSP: %s", snd_strerror(err));
+            return -1;
+        }
+
+        work_done = 1;
+
+        if (frames >= (snd_pcm_uframes_t) n)
+            return work_done;
+
+        /*         pa_log("wrote %i samples", (int) frames); */
+    }
+}
+
+static int unix_write(struct userdata *u) {
+    snd_pcm_status_t *status;
+    int work_done = 0;
+
+    snd_pcm_status_alloca(&status);
+
+    pa_assert(u);
+    pa_sink_assert_ref(u->sink);
+
+    for (;;) {
+        void *p;
+        snd_pcm_sframes_t t;
+        ssize_t l;
+        int err;
+
+        if ((err = snd_pcm_status(u->pcm_handle, status)) < 0) {
+            pa_log("Failed to query DSP status data: %s", snd_strerror(err));
+            return -1;
+        }
+
+        if (snd_pcm_status_get_avail_max(status)*u->frame_size >= u->hwbuf_size)
+            pa_log_debug("Buffer underrun!");
+
+        l = snd_pcm_status_get_avail(status) * u->frame_size;
+
+        /*         pa_log("%u bytes to write", l); */
+
+        l = l - (l % u->fragment_size);
+
+        if (l <= 0)
+            return work_done;
+
+        if (u->memchunk.length <= 0)
+            pa_sink_render(u->sink, l, &u->memchunk);
+
+        pa_assert(u->memchunk.length > 0);
+
+        p = pa_memblock_acquire(u->memchunk.memblock);
+        t = snd_pcm_writei(u->pcm_handle, (const uint8_t*) p + u->memchunk.index, u->memchunk.length / u->frame_size);
+        pa_memblock_release(u->memchunk.memblock);
+
+        /*         pa_log("wrote %i bytes of %u (%u)", t*u->frame_size, u->memchunk.length, l); */
+
+        pa_assert(t != 0);
+
+        if (t < 0) {
+
+            if ((t = snd_pcm_recover(u->pcm_handle, t, 1)) == 0)
+                continue;
+
+            if (t == -EAGAIN) {
+                pa_log_debug("EAGAIN");
+                return work_done;
+            } else {
+                pa_log("Failed to write data to DSP: %s", snd_strerror(t));
+                return -1;
+            }
+        }
+
+        u->memchunk.index += t * u->frame_size;
+        u->memchunk.length -= t * u->frame_size;
+
+        if (u->memchunk.length <= 0) {
+            pa_memblock_unref(u->memchunk.memblock);
+            pa_memchunk_reset(&u->memchunk);
+        }
+
+        work_done = 1;
+
+        if (t * u->frame_size >= (unsigned) l)
+            return work_done;
+    }
+}
+
+static pa_usec_t sink_get_latency(struct userdata *u) {
+    pa_usec_t r = 0;
+    snd_pcm_status_t *status;
+    snd_pcm_sframes_t frames = 0;
+    int err;
+
+    snd_pcm_status_alloca(&status);
+
+    pa_assert(u);
+    pa_assert(u->pcm_handle);
+
+    if ((err = snd_pcm_status(u->pcm_handle, status)) < 0)
+        pa_log("Failed to get delay: %s", snd_strerror(err));
+    else
+        frames = snd_pcm_status_get_delay(status);
+
+    if (frames > 0)
+        r = pa_bytes_to_usec(frames * u->frame_size, &u->sink->sample_spec);
+
+    if (u->memchunk.memblock)
+        r += pa_bytes_to_usec(u->memchunk.length, &u->sink->sample_spec);
+
+    return r;
+}
+
+static int build_pollfd(struct userdata *u) {
+    int err;
+    struct pollfd *pollfd;
+    int n;
+
+    pa_assert(u);
+    pa_assert(u->pcm_handle);
+
+    if ((n = snd_pcm_poll_descriptors_count(u->pcm_handle)) < 0) {
+        pa_log("snd_pcm_poll_descriptors_count() failed: %s", snd_strerror(n));
+        return -1;
+    }
+
+    if (u->alsa_rtpoll_item)
+        pa_rtpoll_item_free(u->alsa_rtpoll_item);
+
+    u->alsa_rtpoll_item = pa_rtpoll_item_new(u->rtpoll, PA_RTPOLL_NEVER, n);
+    pollfd = pa_rtpoll_item_get_pollfd(u->alsa_rtpoll_item, NULL);
+
+    if ((err = snd_pcm_poll_descriptors(u->pcm_handle, pollfd, n)) < 0) {
+        pa_log("snd_pcm_poll_descriptors() failed: %s", snd_strerror(err));
+        return -1;
+    }
+
+    return 0;
+}
+
+static int suspend(struct userdata *u) {
+    pa_assert(u);
+    pa_assert(u->pcm_handle);
+
+    /* Let's suspend */
+    snd_pcm_drain(u->pcm_handle);
+    snd_pcm_close(u->pcm_handle);
+    u->pcm_handle = NULL;
+
+    if (u->alsa_rtpoll_item) {
+        pa_rtpoll_item_free(u->alsa_rtpoll_item);
+        u->alsa_rtpoll_item = NULL;
+    }
+
+    pa_log_info("Device suspended...");
+
+    return 0;
+}
+
+static int unsuspend(struct userdata *u) {
+    pa_sample_spec ss;
+    int err;
+    pa_bool_t b, d;
+    unsigned nfrags;
+
+    pa_assert(u);
+    pa_assert(!u->pcm_handle);
+
+    pa_log_info("Trying resume...");
+
+    snd_config_update_free_global();
+    if ((err = snd_pcm_open(&u->pcm_handle, u->device_name, SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK)) < 0) {
+        pa_log("Error opening PCM device %s: %s", u->device_name, snd_strerror(err));
+        goto fail;
+    }
+
+    ss = u->sink->sample_spec;
+    nfrags = u->nfragments;
+    b = u->use_mmap;
+    d = FALSE;
+
+    if ((err = pa_alsa_set_hw_params(u->pcm_handle, &ss, &nfrags, &u->period_size, u->hwbuf_size / u->frame_size, &b, &d, TRUE)) < 0) {
+        pa_log("Failed to set hardware parameters: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if (b != u->use_mmap) {
+        pa_log_warn("Resume failed, couldn't get original access mode.");
+        goto fail;
+    }
+
+    if (!pa_sample_spec_equal(&ss, &u->sink->sample_spec)) {
+        pa_log_warn("Resume failed, couldn't restore original sample settings.");
+        goto fail;
+    }
+
+    if (nfrags != u->nfragments || u->period_size*u->frame_size != u->fragment_size) {
+        pa_log_warn("Resume failed, couldn't restore original fragment settings.");
+        goto fail;
+    }
+
+    if ((err = pa_alsa_set_sw_params(u->pcm_handle, u->period_size)) < 0) {
+        pa_log("Failed to set software parameters: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if (build_pollfd(u) < 0)
+        goto fail;
+
+    /* FIXME: We need to reload the volume somehow */
+
+    u->first = TRUE;
+
+    pa_log_info("Resumed successfully...");
+
+    return 0;
+
+ fail:
+    if (u->pcm_handle) {
+        snd_pcm_close(u->pcm_handle);
+        u->pcm_handle = NULL;
+    }
+
+    return -1;
+}
+
+static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offset, pa_memchunk *chunk) {
+    struct userdata *u = PA_SINK(o)->userdata;
+
+    switch (code) {
+
+        case PA_SINK_MESSAGE_GET_LATENCY: {
+            pa_usec_t r = 0;
+
+            if (u->pcm_handle)
+                r = sink_get_latency(u);
+
+            *((pa_usec_t*) data) = r;
+
+            return 0;
+        }
+
+        case PA_SINK_MESSAGE_SET_STATE:
+
+            switch ((pa_sink_state_t) PA_PTR_TO_UINT(data)) {
+
+                case PA_SINK_SUSPENDED:
+                    pa_assert(PA_SINK_IS_OPENED(u->sink->thread_info.state));
+
+                    if (suspend(u) < 0)
+                        return -1;
+
+                    break;
+
+                case PA_SINK_IDLE:
+                case PA_SINK_RUNNING:
+
+                    if (u->sink->thread_info.state == PA_SINK_INIT) {
+                        if (build_pollfd(u) < 0)
+                            return -1;
+                    }
+
+                    if (u->sink->thread_info.state == PA_SINK_SUSPENDED) {
+                        if (unsuspend(u) < 0)
+                            return -1;
+                    }
+
+                    break;
+
+                case PA_SINK_UNLINKED:
+                case PA_SINK_INIT:
+                    break;
+                case PA_SINK_INVALID_STATE:
+                    pa_log_error("invalid state");
+                    break;
+            }
+
+            break;
+
+        case PA_SINK_MESSAGE_ADD_INPUT:
+            break;
+        case PA_SINK_MESSAGE_REMOVE_INPUT:
+            break;
+
+        default:
+            break;
+    }
+
+    return pa_sink_process_msg(o, code, data, offset, chunk);
+}
+
+static int mixer_callback(snd_mixer_elem_t *elem, unsigned int mask) {
+    struct userdata *u = snd_mixer_elem_get_callback_private(elem);
+
+    pa_assert(u);
+    pa_assert(u->mixer_handle);
+
+    if (mask == SND_CTL_EVENT_MASK_REMOVE)
+        return 0;
+
+    if (mask & SND_CTL_EVENT_MASK_VALUE) {
+        pa_sink_get_volume(u->sink, TRUE);
+        pa_sink_get_mute(u->sink, TRUE);
+    }
+
+    return 0;
+}
+
+static pa_volume_t from_alsa_volume(struct userdata *u, long alsa_vol) {
+
+    return (pa_volume_t) round(((double) (alsa_vol - u->active_mixer->hw_volume_min) * PA_VOLUME_NORM) /
+                               (double) (u->active_mixer->hw_volume_max - u->active_mixer->hw_volume_min));
+}
+
+static long to_alsa_volume(struct userdata *u, pa_volume_t vol) {
+    long alsa_vol;
+
+    alsa_vol = (long) round(((double) vol * (double) (u->active_mixer->hw_volume_max - u->active_mixer->hw_volume_min))
+                            / PA_VOLUME_NORM) + u->active_mixer->hw_volume_min;
+
+    return PA_CLAMP_UNLIKELY(alsa_vol, u->active_mixer->hw_volume_min, u->active_mixer->hw_volume_max);
+}
+
+static void sink_get_volume_cb(pa_sink *s) {
+    struct userdata *u = s->userdata;
+    int err;
+    unsigned i;
+    pa_cvolume r;
+    char t[PA_CVOLUME_SNPRINT_MAX];
+
+    pa_assert(u);
+    pa_assert(u->active_mixer->mixer_elem);
+
+    if (u->active_mixer->mixer_separate_channels) {
+
+        r.channels = u->sink->sample_spec.channels;
+
+        for (i = 0; i < u->sink->sample_spec.channels; i++) {
+            long alsa_vol;
+
+            if (u->active_mixer->hw_dB_supported) {
+
+                if ((err = snd_mixer_selem_get_playback_dB(u->active_mixer->mixer_elem, u->active_mixer->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+                r.values[i] = pa_sw_volume_from_dB((double) (alsa_vol - u->active_mixer->hw_dB_max) / 100.0);
+            } else {
+
+                if ((err = snd_mixer_selem_get_playback_volume(u->active_mixer->mixer_elem, u->active_mixer->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+                r.values[i] = from_alsa_volume(u, alsa_vol);
+            }
+        }
+
+    } else {
+        long alsa_vol;
+
+        if (u->active_mixer->hw_dB_supported) {
+
+            if ((err = snd_mixer_selem_get_playback_dB(u->active_mixer->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+            pa_cvolume_set(&r, u->sink->sample_spec.channels, pa_sw_volume_from_dB((double) (alsa_vol - u->active_mixer->hw_dB_max) / 100.0));
+
+        } else {
+
+            if ((err = snd_mixer_selem_get_playback_volume(u->active_mixer->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+            pa_cvolume_set(&r, u->sink->sample_spec.channels, from_alsa_volume(u, alsa_vol));
+        }
+    }
+
+    pa_log_debug("Read hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &r));
+
+    if (!pa_cvolume_equal(&u->active_mixer->hardware_volume, &r)) {
+
+        s->virtual_volume = u->active_mixer->hardware_volume = r;
+
+        if (u->active_mixer->hw_dB_supported) {
+            pa_cvolume reset;
+
+            /* Hmm, so the hardware volume changed, let's reset our software volume */
+            pa_cvolume_reset(&reset, u->sink->sample_spec.channels);
+            pa_sink_set_soft_volume(s, &reset);
+        }
+    }
+
+    return;
+
+ fail:
+    pa_log_error("Unable to read volume: %s", snd_strerror(err));
+}
+
+
+static long update_alsa_volume(struct mixer_control_t *m, long alsa_vol) {
+
+    struct gain_step_t *g;
+    long vol = alsa_vol;
+    int step = 0;
+    int i;
+    int step_count = 0;
+
+    for (g = m->gain_step; g; g = g->next)
+        step_count++;
+
+    pa_log("update alsa volume for mixer %s, step count %d", m->name, step_count);
+
+    if (m->hw_dB_supported) {
+    pa_log("min %d max %d alsa_vol %ld", m->hw_dB_min, m->hw_dB_max, alsa_vol);
+        step = ((-m->hw_dB_max) + (-m->hw_dB_min)) / step_count;
+        step = (-alsa_vol)/step;
+        if (step < 0)
+            step = -step;
+
+    } else {
+        step = (m->hw_volume_max - m->hw_volume_min) / step_count;
+        step = alsa_vol/step;
+    }
+
+    pa_log("got step %d", step);
+
+    if (step < 0)
+        step = 0;
+    if (step >= step_count)
+        step = step_count-1;
+
+    if (step == 0)
+        vol = m->gain_step->volume;
+    else {
+        i = 1;
+        for (g = m->gain_step->next; g; g = g->next) {
+            if (step == i) {
+                vol = g->volume;
+                break;
+            }
+            i++;
+        }
+    }
+
+    pa_log("update alsa vol from %ld to %ld", alsa_vol, vol);
+
+    return vol;
+
+    
+#if 0
+    long vol;
+    int step = 0;
+    pa_assert(m);
+    pa_assert(m->gain_step);
+
+    step = (m->hw_volume_max - m->hw_volume_min)/m->gain_step_count;
+    step = alsa_vol/step;
+    if (step < 0)
+        vol = m->gain_step[0];
+    else if (step >= m->gain_step_count)
+        vol = m->gain_step[m->gain_step_count-1];
+    else
+        vol = m->gain_step[step];
+
+    pa_log_debug("update alsa volume from %ld to %ld", alsa_vol, vol);
+    return vol;
+#endif
+    return 0;
+}
+
+static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m, pa_cvolume *vv) {
+    int err;
+    unsigned i;
+    pa_cvolume r;
+
+    pa_assert(u);
+    pa_assert(m->mixer_elem);
+
+    if (m->mixer_separate_channels) {
+
+        r.channels = u->sink->sample_spec.channels;
+
+        for (i = 0; i < u->sink->sample_spec.channels; i++) {
+            long alsa_vol;
+            pa_volume_t vol;
+
+            vol = vv->values[i];
+
+            if (m->hw_dB_supported) {
+
+                alsa_vol = (long) (pa_sw_volume_to_dB(vol) * 100);
+                alsa_vol += m->hw_dB_max;
+                alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, m->hw_dB_min, m->hw_dB_max);
+
+                if (m->gain_step)
+                    alsa_vol = update_alsa_volume(m, alsa_vol);
+
+                if ((err = snd_mixer_selem_set_playback_dB(m->mixer_elem, m->mixer_map[i], alsa_vol, 1)) < 0)
+                    goto fail;
+
+                if ((err = snd_mixer_selem_get_playback_dB(m->mixer_elem, m->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+                r.values[i] = pa_sw_volume_from_dB((double) (alsa_vol - m->hw_dB_max) / 100.0);
+
+            } else {
+                alsa_vol = to_alsa_volume(u, vol);
+
+                if (m->gain_step)
+                    alsa_vol = update_alsa_volume(m, alsa_vol);
+
+                if ((err = snd_mixer_selem_set_playback_volume(m->mixer_elem, m->mixer_map[i], alsa_vol)) < 0)
+                    goto fail;
+
+                if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, m->mixer_map[i], &alsa_vol)) < 0)
+                    goto fail;
+
+                r.values[i] = from_alsa_volume(u, alsa_vol);
+            }
+        }
+
+    } else {
+        pa_volume_t vol;
+        long alsa_vol;
+
+        vol = pa_cvolume_max(vv);
+
+        if (m->hw_dB_supported) {
+            alsa_vol = (long) (pa_sw_volume_to_dB(vol) * 100);
+            alsa_vol += m->hw_dB_max;
+            alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, m->hw_dB_min, m->hw_dB_max);
+
+            if (m->gain_step)
+                alsa_vol = update_alsa_volume(m, alsa_vol);
+
+            if ((err = snd_mixer_selem_set_playback_dB_all(m->mixer_elem, alsa_vol, 1)) < 0)
+                goto fail;
+
+            if ((err = snd_mixer_selem_get_playback_dB(m->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+            VALGRIND_MAKE_MEM_DEFINED(&alsa_vol, sizeof(alsa_vol));
+#endif
+
+            pa_cvolume_set(&r, u->sink->sample_spec.channels, pa_sw_volume_from_dB((double) (alsa_vol - m->hw_dB_max) / 100.0));
+
+        } else {
+            alsa_vol = to_alsa_volume(u, vol);
+
+            if (m->gain_step)
+                alsa_vol = update_alsa_volume(m, alsa_vol);
+
+            if ((err = snd_mixer_selem_set_playback_volume_all(m->mixer_elem, alsa_vol)) < 0)
+                goto fail;
+
+            if ((err = snd_mixer_selem_get_playback_volume(m->mixer_elem, SND_MIXER_SCHN_MONO, &alsa_vol)) < 0)
+                goto fail;
+
+            pa_cvolume_set(&r, u->sink->sample_spec.channels, from_alsa_volume(u, alsa_vol));
+        }
+    }
+
+    m->hardware_volume = r;
+
+    if (m->hw_dB_supported) {
+        char t[PA_CVOLUME_SNPRINT_MAX];
+
+        /* Match exactly what the user requested by software */
+        pa_sw_cvolume_divide(&u->sink->soft_volume, vv, &m->hardware_volume);
+
+        pa_log_debug("Requested volume: %s", pa_cvolume_snprint(t, sizeof(t), vv));
+        pa_log_debug("Got hardware volume: %s", pa_cvolume_snprint(t, sizeof(t), &m->hardware_volume));
+        pa_log_debug("Calculated software volume: %s", pa_cvolume_snprint(t, sizeof(t), &u->sink->soft_volume));
+
+    } else
+
+        /* We can't match exactly what the user requested, hence let's
+         * at least tell the user about it */
+
+        *vv = r;
+
+    return 0;
+
+ fail:
+    pa_log_error("Unable to set volume: %s", snd_strerror(err));
+
+    return 1;
+}
+
+static void sink_set_volume_cb(pa_sink *s) {
+    struct userdata *u = s->userdata;
+
+    if (!u->active_mixer) {
+        pa_log_warn("%s: no active mixer (sink_set_volume_cb)", u->device_name);
+        return;
+    }
+
+    if (u->active_mixer->slaves) {
+        int i;
+        pa_log("SET SLAVE VOLUMES");
+        for (i = 0; u->active_mixer->slaves[i]; i++) {
+            pa_log("slave %s", u->active_mixer->slaves[i]->name);
+            set_alsa_mixer_volumes(u, u->active_mixer->slaves[i], &s->virtual_volume);
+        }
+    }
+
+    pa_log("control volumes %s", u->active_mixer->name);
+    if (set_alsa_mixer_volumes(u, u->active_mixer, &s->virtual_volume)) {
+        s->get_volume = NULL;
+        s->set_volume = NULL;
+    }
+}
+
+static void sink_get_mute_cb(pa_sink *s) {
+    struct userdata *u = s->userdata;
+    int err, sw;
+
+    pa_assert(u);
+    pa_assert(u->active_mixer->mixer_elem);
+
+    if ((err = snd_mixer_selem_get_playback_switch(u->active_mixer->mixer_elem, 0, &sw)) < 0) {
+        pa_log_error("Unable to get switch: %s", snd_strerror(err));
+        return;
+    }
+
+    s->muted = !sw;
+}
+
+static void sink_set_mute_cb(pa_sink *s) {
+    struct userdata *u = s->userdata;
+    int err;
+
+    pa_assert(u);
+    pa_assert(u->active_mixer->mixer_elem);
+
+    if ((err = snd_mixer_selem_set_playback_switch_all(u->active_mixer->mixer_elem, !s->muted)) < 0) {
+        pa_log_error("Unable to set switch: %s", snd_strerror(err));
+        return;
+    }
+}
+
+static void thread_func(void *userdata) {
+    struct userdata *u = userdata;
+
+    pa_assert(u);
+
+    pa_log_debug("Thread starting up");
+
+    if (u->core->realtime_scheduling)
+        pa_make_realtime(u->core->realtime_priority);
+
+    pa_thread_mq_install(&u->thread_mq);
+    pa_rtpoll_install(u->rtpoll);
+
+    for (;;) {
+        int ret;
+
+        /* Render some data and write it to the dsp */
+        if (PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
+            int work_done = 0;
+
+            if (u->sink->thread_info.rewind_requested)
+                pa_sink_process_rewind(u->sink, 0);
+
+            if (u->use_mmap) {
+                if ((work_done = mmap_write(u)) < 0)
+                    goto fail;
+            } else {
+                if ((work_done = unix_write(u)) < 0)
+                    goto fail;
+            }
+
+            if (work_done && u->first) {
+                pa_log_info("Starting playback.");
+                snd_pcm_start(u->pcm_handle);
+                u->first = FALSE;
+                continue;
+            }
+        }
+
+        /* Hmm, nothing to do. Let's sleep */
+        if ((ret = pa_rtpoll_run(u->rtpoll, 1)) < 0)
+            goto fail;
+
+        if (ret == 0)
+            goto finish;
+
+        /* Tell ALSA about this and process its response */
+        if (PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
+            struct pollfd *pollfd;
+            unsigned short revents = 0;
+            int err;
+            unsigned n;
+
+            pollfd = pa_rtpoll_item_get_pollfd(u->alsa_rtpoll_item, &n);
+
+            if ((err = snd_pcm_poll_descriptors_revents(u->pcm_handle, pollfd, n, &revents)) < 0) {
+                pa_log("snd_pcm_poll_descriptors_revents() failed: %s", snd_strerror(err));
+                goto fail;
+            }
+
+            if (revents & (POLLERR|POLLNVAL|POLLHUP)) {
+
+                if (revents & POLLERR)
+                    pa_log_warn("Got POLLERR from ALSA");
+                if (revents & POLLNVAL)
+                    pa_log_warn("Got POLLNVAL from ALSA");
+                if (revents & POLLHUP)
+                    pa_log_warn("Got POLLHUP from ALSA");
+
+                /* Try to recover from this error */
+
+                switch (snd_pcm_state(u->pcm_handle)) {
+
+                    case SND_PCM_STATE_XRUN:
+                        if ((err = snd_pcm_recover(u->pcm_handle, -EPIPE, 1)) != 0) {
+                            pa_log_warn("Could not recover from POLLERR|POLLNVAL|POLLHUP and XRUN: %s", snd_strerror(err));
+                            goto fail;
+                        }
+                        break;
+
+                    case SND_PCM_STATE_SUSPENDED:
+                        if ((err = snd_pcm_recover(u->pcm_handle, -ESTRPIPE, 1)) != 0) {
+                            pa_log_warn("Could not recover from POLLERR|POLLNVAL|POLLHUP and SUSPENDED: %s", snd_strerror(err));
+                            goto fail;
+                        }
+                        break;
+
+                    default:
+
+                        snd_pcm_drop(u->pcm_handle);
+
+                        if ((err = snd_pcm_prepare(u->pcm_handle)) < 0) {
+                            pa_log_warn("Could not recover from POLLERR|POLLNVAL|POLLHUP with snd_pcm_prepare(): %s", snd_strerror(err));
+                            goto fail;
+                        }
+                        break;
+                }
+            }
+        }
+    }
+
+ fail:
+    /* If this was no regular exit from the loop we have to continue
+     * processing messages until we received PA_MESSAGE_SHUTDOWN */
+    pa_asyncmsgq_post(u->thread_mq.outq, PA_MSGOBJECT(u->core), PA_CORE_MESSAGE_UNLOAD_MODULE, u->module, 0, NULL, NULL);
+    pa_asyncmsgq_wait_for(u->thread_mq.inq, PA_MESSAGE_SHUTDOWN);
+
+ finish:
+    pa_log_debug("Thread shutting down");
+}
+
+static struct mixer_control_t* get_mixer_elem_by_name(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
+
+    for (m = u->mixer_list; m; m = m->next) {
+        if (strcmp(mixer, m->name) == 0)
+            return m;
+    }
+
+    return NULL;
+}
+
+static int set_mixer_elem_by_name(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
+
+    m = get_mixer_elem_by_name(u, mixer);
+
+    if (!m) {
+        pa_log_info("%s: no preloaded mixer %s found", u->device_name, mixer);
+        return 1;
+    }
+
+    if (m == u->active_mixer) {
+        pa_log_debug("%s: requested mixer already active.", u->device_name);
+        return 0;
+    }
+
+    pa_log_info("%s: setting active mixer to %s", u->device_name, m->name);
+
+    u->sink->flags = u->default_flags;
+
+    if (m->hw_volume_control) {
+        if (m->hw_dB_supported) {
+            if (m->hw_dB_max > 0) {
+                u->sink->base_volume = pa_sw_volume_from_dB(- (double) m->hw_dB_max/100.0);
+                pa_log_info("Fixing base volume to %0.2f dB", pa_sw_volume_to_dB(u->sink->base_volume));
+            } else
+                pa_log_info("No particular base volume set, fixing to 0 dB");
+        }
+        u->sink->get_volume = sink_get_volume_cb;
+        u->sink->set_volume = sink_set_volume_cb;
+
+        u->sink->flags |= PA_SINK_HW_VOLUME_CTRL | (m->hw_dB_supported ? PA_SINK_DECIBEL_VOLUME : 0);
+        pa_log_info("Using hardware volume control. Hardware dB scale %s.", m->hw_dB_supported ? "supported" : "not supported");
+
+        if (!m->hw_dB_supported)
+            u->sink->n_volume_steps = m->hw_volume_max - m->hw_volume_min + 1;
+    } else {
+        u->sink->get_volume = NULL;
+        u->sink->set_volume = NULL;
+        pa_log_info("Using software volume control.");
+    }
+
+    if (snd_mixer_selem_has_playback_switch(m->mixer_elem)) {
+        u->sink->get_mute = sink_get_mute_cb;
+        u->sink->set_mute = sink_set_mute_cb;
+        u->sink->flags |= PA_SINK_HW_MUTE_CTRL;
+    } else {
+        u->sink->get_mute = NULL;
+        u->sink->set_mute = NULL;
+        pa_log_info("Using software mute control.");
+    }
+
+    u->active_mixer = m;
+    return 0;
+}
+
+
+
+static struct mixer_control_t* get_mixer_element(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
+    snd_mixer_elem_t *mixer_elem;
+    pa_channel_map map;
+
+    map = u->channel_map;
+
+    if (u->mixer_handle) {
+        /* Try using mixer as both primary and fallback mixer, to ensure mixer selection
+         * even when mixer doesn't have both volume and mute switches */
+        if (!(mixer_elem = pa_alsa_find_elem(u->mixer_handle, mixer, mixer, TRUE))) {
+            pa_log_error("%s: could not select mixer %s at all", u->device_name, mixer);
+            goto fail;
+        }
+    } else {
+        pa_log_error("%s: No mixer handle.", u->device_name);
+        goto fail;
+    }
+
+    if (u->mixer_handle && mixer_elem) {
+
+        m = pa_xnew0(struct mixer_control_t, 1);
+        PA_LLIST_INIT(struct mixer_control_t, m);
+
+        m->name = pa_xstrdup(mixer);
+        m->mixer_elem = mixer_elem;
+
+        if (snd_mixer_selem_has_playback_volume(m->mixer_elem)) {
+            pa_bool_t suitable = FALSE;
+
+            if (snd_mixer_selem_get_playback_volume_range(m->mixer_elem, &m->hw_volume_min, &m->hw_volume_max) < 0)
+                pa_log_info("Failed to get volume range. Falling back to software volume control.");
+            else if (m->hw_volume_min >= m->hw_volume_max)
+                pa_log_warn("Your kernel driver is broken: it reports a volume range from %li to %li which makes no sense.", m->hw_volume_min, m->hw_volume_max);
+            else {
+                pa_log_info("Volume ranges from %li to %li.", m->hw_volume_min, m->hw_volume_max);
+                suitable = TRUE;
+            }
+
+            if (suitable) {
+                if (u->ignore_dB || snd_mixer_selem_get_playback_dB_range(m->mixer_elem, &m->hw_dB_min, &m->hw_dB_max) < 0)
+                    pa_log_info("Mixer doesn't support dB information or data is ignored.");
+                else {
+#ifdef HAVE_VALGRIND_MEMCHECK_H
+                    VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_min, sizeof(m->hw_dB_min));
+                    VALGRIND_MAKE_MEM_DEFINED(&m->hw_dB_max, sizeof(m->hw_dB_max));
+#endif
+
+                    if (m->hw_dB_min >= m->hw_dB_max)
+                        pa_log_warn("Your kernel driver is broken: it reports a volume range from %0.2f dB to %0.2f dB which makes no sense.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
+                    else {
+                        pa_log_info("Volume ranges from %0.2f dB to %0.2f dB.", (double) m->hw_dB_min/100.0, (double) m->hw_dB_max/100.0);
+                        m->hw_dB_supported = TRUE;
+                    }
+                }
+
+                if (!m->hw_dB_supported &&
+                    m->hw_volume_max - m->hw_volume_min < 3) {
+
+                    pa_log_info("Device doesn't do dB volume and has less than 4 volume levels. Falling back to software volume control.");
+                    suitable = FALSE;
+                }
+            }
+
+            m->hw_volume_control = suitable;
+
+            if (suitable) {
+                m->mixer_separate_channels = (pa_alsa_calc_mixer_map(m->mixer_elem, &map, m->mixer_map, TRUE) >= 0);
+            } else
+                pa_log_info("Using software volume control.");
+        }
+
+        m->mixer_fdl = pa_alsa_fdlist_new();
+
+        if (pa_alsa_fdlist_set_mixer(m->mixer_fdl, u->mixer_handle, u->core->mainloop) < 0) {
+            pa_log("Failed to initialize file descriptor monitoring");
+            goto fail;
+        }
+
+        snd_mixer_elem_set_callback(m->mixer_elem, mixer_callback);
+        snd_mixer_elem_set_callback_private(m->mixer_elem, u);
+
+        pa_log_info("%s: new mixer found: %s", u->device_name, m->name);
+    }
+
+    return m;
+ fail:
+    if (m) {
+        if (m->mixer_fdl) {
+            pa_alsa_fdlist_free(m->mixer_fdl);
+            m->mixer_fdl = NULL;
+        }
+
+        pa_xfree(m);
+    }
+
+    return NULL;
+}
+
+/** Load mixers using comma separated string list.
+ *
+ * return number of successfully loaded mixer elements
+ */
+static int get_mixer_elements(struct userdata *u, const char *mixer_list) {
+    const char *state = NULL;
+    struct mixer_control_t *m = NULL;
+    int count = 0;
+    char *mixer;
+    pa_assert(u);
+    pa_assert(mixer_list);
+
+    while ((mixer = pa_split(mixer_list, ",", &state))) {
+        if (mixer) {
+            m = get_mixer_element(u, mixer);
+            if (m) {
+                PA_LLIST_PREPEND(struct mixer_control_t, u->mixer_list, m);
+                count++;
+            }
+            pa_xfree(mixer);
+        }
+    }
+
+    return count;
+}
+
+static void clear_gain_steps(struct mixer_control_t *m) {
+    struct gain_step_t *g;
+    pa_log("clear_gain_steps");
+    while ((g = m->gain_step)) {
+        pa_log("free");
+        PA_LLIST_REMOVE(struct gain_step_t, m->gain_step, g);
+        pa_xfree(g);
+    }
+    pa_log("done");
+}
+
+static void free_mixer_element(struct mixer_control_t *m) {
+    pa_xfree(m->name);
+    pa_alsa_fdlist_free(m->mixer_fdl);
+    m->mixer_elem = NULL;
+
+    clear_gain_steps(m);
+
+    pa_xfree(m);
+}
+
+static void free_mixer_elements(struct userdata *u) {
+    struct mixer_control_t *m;
+    pa_log_debug("free mixer elements");
+
+    u->active_mixer = NULL;
+
+    while ((m = u->mixer_list)) {
+        PA_LLIST_REMOVE(struct mixer_control_t, u->mixer_list, m);
+        free_mixer_element(m);
+    }
+}
+
+static void my_split(const char *src, const char *separator, char **left, char **right) {
+    const char *state = NULL;
+    char *str;
+
+    while ((str = pa_split(src, separator, &state))) {
+        if (str) {
+            if (!*left)
+                *left = str;
+            else if (!*right)
+                *right = str;
+            else
+                pa_xfree(str);
+        }
+    }
+}
+
+#define MAX_MIXER_COUNT (16)
+static int mixers_from_str(struct userdata *u, struct mixer_control_t **mixers, const char *list_str) {
+    struct mixer_control_t *m;
+    const char *state = NULL;
+    int mixer_count = 0;
+    char *str;
+
+    while ((str = pa_split(list_str, ",", &state))) {
+        if (str) {
+            m = get_mixer_elem_by_name(u, str);
+            if (m)
+                mixers[mixer_count++] = m;
+            pa_xfree(str);
+        }
+        if (mixer_count == MAX_MIXER_COUNT)
+            break;
+    }
+    mixers[mixer_count] = NULL;
+
+    return mixer_count;
+}
+
+static int levels(struct userdata *u, struct mixer_control_t **mixers, const char *mixer_values) {
+    struct gain_step_t *g;
+    struct gain_step_t *last = NULL;
+    const char *state = NULL;
+    int ret = 0;
+    char *str;
+    int i;
+    int vol;
+
+    pa_log("LEVELS %s", mixer_values);
+
+    for (i = 0; mixers[i]; i++) {
+        if (!last)
+            last = mixers[i]->gain_step;
+        str = pa_split(mixer_values, ",", &state);
+        pa_log("STR: %s", str);
+        g = pa_xnew0(struct gain_step_t, 1);
+        PA_LLIST_INIT(struct gain_step_t, g);
+        g->enabled = FALSE;
+//        PA_LLIST_INSERT_AFTER(struct gain_step_t, mixers[i]->gain_step, last, g);
+//        last = g;
+        PA_LLIST_PREPEND(struct gain_step_t, mixers[i]->gain_step, g);
+
+        if (str) {
+            if (pa_atoi(str, &vol) == 0) {
+                g->enabled = TRUE;
+                g->volume = (pa_volume_t)vol;
+                pa_log("%s set %d: %ld", mixers[i]->name, i, vol);
+            }
+
+            pa_xfree(str);
+        }
+    }
+
+    return ret;
+}
+
+static int mixer_levels_from_str(struct userdata *u, struct mixer_control_t **mixers, const char *mixer_values) {
+    const char *state = NULL;
+    int ret = 0;
+    char *str;
+    int i;
+
+    pa_log("mixer levels from str %s", mixer_values);
+
+    while ((str = pa_split(mixer_values, "|", &state))) {
+        if (str) {
+            levels(u, mixers, str);
+            pa_xfree(str);
+        }
+    }
+
+    return ret;
+}
+
+static int update_mixer_gain_steps(struct userdata *u, const char *step_list) {
+    struct mixer_control_t **mixers;
+    struct gain_step_t *g;
+    const char *state = NULL;
+    char *str;
+    char *mixer_list = NULL;
+    char *mixer_values = NULL;
+    int mixer_count = 0;
+
+    my_split(step_list, "#", &mixer_list, &mixer_values);
+
+    if (mixer_list && mixer_values) {
+        mixers = pa_xmalloc0(sizeof(struct mixer_control_t*) * (MAX_MIXER_COUNT+1));
+        mixer_count = mixers_from_str(u, mixers, mixer_list);
+
+        if (mixers[0] != NULL) {
+            int i;
+            for (i = 0; mixers[i]; i++) {
+                pa_log("mixer[%d] %s", i, mixers[i]->name);
+
+                clear_gain_steps(mixers[i]);
+            }
+        }
+
+        if (mixer_count > 0) {
+            mixer_levels_from_str(u, mixers, mixer_values);
+        }
+    }
+
+    pa_xfree(mixers);
+
+    return mixer_count;
+}
+
+static void set_vol(pa_cvolume *vol, const int channels, pa_volume_t value) {
+    int ii;
+    vol->channels = channels;
+    for (ii = 0; ii < channels; ii++) {
+        vol->values[ii] = value;
+    }
+}
+
+/** Set mixer state using colon separated MIXER:STATE pair.
+ */
+static int set_mixer_value(struct userdata *u, const char *value_str) {
+    int ret = 0;
+    struct mixer_control_t *m = NULL;
+    const char *state = NULL;
+    char *str;
+    char *mixer = NULL;
+    char *value = NULL;
+    pa_cvolume vol;
+
+    my_split(value_str, ":", &mixer, &value);
+
+    if (mixer && value) {
+
+        if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_OFF) == 0) {
+            m = get_mixer_elem_by_name(u, mixer);
+            if (m) {
+                m->slave = FALSE;
+                pa_log_info("%s: set mixer %s off", u->device_name, mixer);
+                if (m->hw_dB_supported)
+                    set_vol(&vol, u->sink->channel_map.channels, pa_sw_volume_from_dB(m->hw_dB_min));
+                else
+                    set_vol(&vol, u->sink->channel_map.channels, from_alsa_volume(u, m->hw_volume_min));
+                set_alsa_mixer_volumes(u, m, &vol);
+            }
+        } else if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_MAX) == 0) {
+            m = get_mixer_elem_by_name(u, mixer);
+            if (m) {
+                m->slave = FALSE;
+                pa_log_info("%s: set mixer %s max", u->device_name, mixer);
+                if (m->hw_dB_supported)
+                    set_vol(&vol, u->sink->channel_map.channels, pa_sw_volume_from_dB(- m->hw_dB_max/100.0));
+                else
+                    set_vol(&vol, u->sink->channel_map.channels, from_alsa_volume(u, m->hw_volume_max));
+                set_alsa_mixer_volumes(u, m, &vol);
+            }
+        } else if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_CONTROL) == 0) {
+            pa_log_info("%s: set mixer %s active", u->device_name, mixer);
+            if (set_mixer_elem_by_name(u, mixer)) {
+                /* couldn't select mixer, try to load that mixer element */
+                if (get_mixer_elements(u, mixer) > 0) {
+                    /* new mixer element loaded, try selecting again */
+                    if (set_mixer_elem_by_name(u, mixer)) {
+                        pa_log_error("%s: cannot load new mixer control %s", u->device_name, mixer);
+
+                        ret = 1;
+                    }
+                }
+            }
+            if (ret == 0)
+                u->active_mixer->slave = FALSE;
+        } else if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_SLAVE) == 0) {
+            m = get_mixer_elem_by_name(u, mixer);
+            if (m) {
+                pa_log("%s: set mixer %s slave", u->device_name, mixer);
+                m->slave = TRUE;
+            }
+
+        } else {
+            pa_log_error("%s: bad mixer setup pair (%s)", u->device_name, value_str);
+            ret = 1;
+        }
+
+    } else {
+        pa_log_error("%s: bad mixer setup pair (%s)", u->device_name, value_str);
+        ret = 1;
+    }
+
+    if (mixer)
+        pa_xfree(mixer);
+    if (value)
+        pa_xfree(value);
+
+    return ret;
+}
+
+static int update_slave_list(struct userdata *u) {
+    struct mixer_control_t *m;
+    int count = 0;
+
+    if (!u->active_mixer) {
+        /* don't update slave list, since no control mixer */
+        return 0;
+    }
+
+    for (m = u->mixer_list; m; m = m->next) {
+        if (m->slaves) {
+            pa_xfree(m->slaves);
+            m->slaves = NULL;
+        }
+        if (m->slave)
+            count++;
+    }
+
+    if (count > 0) {
+        int i = 0;
+        u->active_mixer->slaves = pa_xmalloc0(sizeof(struct mixer_control_t*) * (count+1));
+
+        for (m = u->mixer_list; m; m = m->next) {
+            if (i == count)
+                break;
+            if (m->slave) {
+                u->active_mixer->slaves[i++] = m;
+                pa_log("add slave %s to slavelist in %s", m->name, u->active_mixer->name);
+            }
+        }
+
+        u->active_mixer->slaves[i] = NULL;
+    }
+
+    return 0;
+}
+
+/** Parse mixer control list.
+ *
+ * Parses comma separated list of MIXER:STATE pairs.
+ */
+static int update_mixer_setup(struct userdata *u, const char *value_list) {
+    int ret = 0;
+    const char *state = NULL;
+    char *value;
+
+    pa_log_info("%s: update mixer setup", u->device_name);
+
+    /* store volumes from currently active mixer */
+    if (u->active_mixer) {
+        u->active_mixer->cache_volume = *pa_sink_get_volume(u->sink, TRUE);
+        u->active_mixer->cache_muted = pa_sink_get_mute(u->sink, TRUE);
+    }
+
+    while ((value = pa_split(value_list, ",", &state))) {
+        if (value) {
+            set_mixer_value(u, value);
+            pa_xfree(value);
+        }
+    }
+
+    update_slave_list(u);
+
+    /* update previously stored volumes to sink */
+    if (u->active_mixer) {
+        pa_log_info("%s: update stored volumes to sink", u->device_name);
+        if (u->active_mixer->cache_volume.channels > 0) {
+            pa_sink_set_volume(u->sink, &u->active_mixer->cache_volume, TRUE, TRUE);
+            pa_sink_set_mute(u->sink, u->active_mixer->cache_muted);
+        } else {
+            /* no previously stored volumes, update volume from hw */
+            pa_sink_get_volume(u->sink, TRUE);
+            pa_sink_get_mute(u->sink, TRUE);
+        }
+    }
+
+    return ret;
+}
+
+static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
+    const char *v = NULL;
+    unsigned count = 0;
+    const char *step_list = NULL;
+    pa_bool_t muted = FALSE;
+    const pa_cvolume *vol = NULL;
+
+    if (s != u->sink) {
+        return PA_HOOK_OK;
+    }
+
+    pa_log_debug("%s: sink_proplist_changed_hook_callback", u->device_name);
+
+    pa_assert(u);
+    pa_assert(s);
+
+    v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_BUFFERS);
+    if (v) {
+        if (pa_startswith(v, PA_ALSA_SINK_PROP_BUFFERS_PRIMARY)) {
+            switch_buffers(u, SINK_SWITCH_PRIMARY);
+        }
+        else if (pa_startswith(v, PA_ALSA_SINK_PROP_BUFFERS_ALTERNATIVE)) {
+            switch_buffers(u, SINK_SWITCH_ALTERNATIVE);
+        }
+    }
+    v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_MIXER_GAIN);
+    if (v) {
+        update_mixer_gain_steps(u, v);
+    }
+
+    v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_MIXER);
+    if (v) {
+        update_mixer_setup(u, v);
+    }
+
+
+    return PA_HOOK_OK;
+}
+
+static int init_volume_cache(struct userdata *u) {
+    char *fn;
+    char *fname;
+    int gdbm_cache_size;
+
+    /* We include the host identifier in the file name because gdbm
+     * files are CPU dependant, and we don't want things to go wrong
+     * if we are on a multiarch system. */
+
+    fn = pa_sprintf_malloc("%s:mixer-volumes."CANONICAL_HOST".gdbm", u->device_name);
+    fname = pa_state_path(fn, TRUE);
+    pa_xfree(fn);
+
+    if (!fname)
+        return 1;
+
+    if (!(u->gdbm_file = gdbm_open(fname, 0, GDBM_WRCREAT|GDBM_NOLOCK, 0600, NULL))) {
+        pa_log("Failed to open volume database '%s': %s", fname, gdbm_strerror(gdbm_errno));
+        pa_xfree(fname);
+        return 1;
+    }
+
+    /* By default the cache of gdbm is rather large, let's reduce it a bit to save memory */
+    gdbm_cache_size = 10;
+    gdbm_setopt(u->gdbm_file, GDBM_CACHESIZE, &gdbm_cache_size, sizeof(gdbm_cache_size));
+
+    pa_log_info("%s: Sucessfully opened database file '%s'.", u->device_name, fname);
+    pa_xfree(fname);
+
+    u->cache_volumes = TRUE;
+
+    return 0;
+}
+
+static struct entry* read_entry(struct userdata *u, const char *name) {
+    datum key, data;
+    struct entry *e;
+
+    pa_assert(u);
+    pa_assert(name);
+
+    key.dptr = (char*) name;
+    key.dsize = (int) strlen(name);
+
+    data = gdbm_fetch(u->gdbm_file, key);
+
+    if (!data.dptr)
+        goto fail;
+
+    if (data.dsize != sizeof(struct entry)) {
+        pa_log_debug("Database contains entry for device %s of wrong size %lu != %lu. Probably due to upgrade, ignoring.", name, (unsigned long) data.dsize, (unsigned long) sizeof(struct entry));
+        goto fail;
+    }
+
+    e = (struct entry*) data.dptr;
+
+    if (e->version != ENTRY_VERSION) {
+        pa_log_debug("Version of database entry for device %s doesn't match our version. Probably due to upgrade, ignoring.", name);
+        goto fail;
+    }
+
+    if (!(pa_cvolume_valid(&e->volume))) {
+        pa_log_warn("Invalid volume stored in database for device %s", name);
+        goto fail;
+    }
+
+    return e;
+
+fail:
+
+    pa_xfree(data.dptr);
+    return NULL;
+}
+
+static int store_mixer_volume(struct userdata *u, struct mixer_control_t *m) {
+    struct entry entry;
+    char *name;
+    datum key, data;
+
+    pa_assert(u);
+    pa_assert(m);
+
+    memset(&entry, 0, sizeof(entry));
+    entry.version = ENTRY_VERSION;
+
+    name = pa_xstrdup(m->name);
+    entry.volume = m->cache_volume;
+    entry.muted = m->cache_muted;
+
+    key.dptr = name;
+    key.dsize = (int)strlen(name);
+
+    data.dptr = (void*) &entry;
+    data.dsize = sizeof(entry);
+
+    pa_log_info("%s: storing volume/mute for mixer %s. vol %d", u->device_name, name, m->cache_volume.values[0]);
+
+    gdbm_store(u->gdbm_file, key, data, GDBM_REPLACE);
+
+    pa_xfree(name);
+
+    return 0;
+}
+
+/** Load mixer values either from gdbm or current hw mixer levels.
+ *
+ * Might leave active_mixer in different state than before calling,
+ * so make sure to set correct mixer after calling this.
+ */
+static int load_mixer_volumes(struct userdata *u) {
+    struct mixer_control_t *m = NULL;
+    struct entry *entry = NULL;
+    int values_read = 0;
+    pa_assert(u);
+
+    for (m = u->mixer_list; m; m = m->next) {
+
+        if (u->cache_volumes)
+            entry = read_entry(u, m->name);
+
+        if (entry && entry->volume.channels > 0) {
+            m->cache_volume = entry->volume;
+            m->cache_muted = entry->muted;
+            pa_log_info("%s: load volume for mixer %s: %d", u->device_name, m->name, m->cache_volume.values[0]);
+            values_read++;
+        } else {
+            /* just try to get something to start with */
+            if (!set_mixer_elem_by_name(u, m->name)) {
+                m->cache_volume = *pa_sink_get_volume(u->sink, TRUE);
+                m->cache_muted = pa_sink_get_mute(u->sink, TRUE);
+                pa_log_info("%s: get initial volume for mixer %s: %d",
+                        u->device_name, m->name, m->cache_volume.values[0]);
+            }
+        }
+
+        if (entry)
+            pa_xfree(entry);
+    }
+
+    return values_read;
+}
+
+/** Load default volume to all mixers (0.95*hw_volume_max).
+ */
+static void load_default_mixer_volumes(struct userdata *u) {
+    struct mixer_control_t *m;
+    int ii;
+    pa_assert(u->cache_volumes);
+
+    /* set all mixers to default level */
+    pa_log_info("%s: set hw_volume_max*0.95 to all mixers", u->device_name);
+    for (m = u->mixer_list; m; m = m->next) {
+        m->cache_volume.channels = u->sink->channel_map.channels;
+        for (ii = 0; ii < m->cache_volume.channels; ii++) {
+            if (m->hw_dB_supported)
+                m->cache_volume.values[ii] = pa_sw_volume_from_dB(- m->hw_dB_max/100.0)*0.95;
+            else
+                m->cache_volume.values[ii] = from_alsa_volume(u, m->hw_volume_max*0.95);
+        }
+        m->cache_muted = FALSE;
+    }
+}
+
+static void store_mixer_volumes(struct userdata *u) {
+    struct mixer_control_t *m = NULL;
+    pa_assert(u);
+
+    for (m = u->mixer_list; m; m = m->next) {
+
+        if (u->cache_volumes) {
+            /* update current volume from active mixer */
+            if (m == u->active_mixer) {
+                m->cache_volume = m->hardware_volume;
+                m->cache_muted = pa_sink_get_mute(u->sink, FALSE);
+            }
+            store_mixer_volume(u, m);
+        } else {
+            /* set mixer levels to cache levels */
+            set_mixer_elem_by_name(u, m->name);
+            set_alsa_mixer_volumes(u, m, &m->cache_volume);
+        }
+    }
+
+    /* sync immediately */
+    gdbm_sync(u->gdbm_file);
+    pa_log_info("%s: Synced.", u->device_name);
+}
+
+int pa__init(pa_module*m) {
+
+    pa_modargs *ma = NULL;
+    struct userdata *u = NULL;
+    const char *dev_id;
+    pa_sample_spec ss;
+    pa_channel_map map;
+    char *alsa_mixer = NULL;
+    char *mixer_load = NULL;
+    uint32_t nfrags, frag_size;
+    uint32_t alt_nfrags, alt_frag_size;
+    snd_pcm_uframes_t period_size;
+    snd_pcm_uframes_t alt_period_size;
+    size_t frame_size;
+    size_t alt_frame_size;
+    snd_pcm_info_t *pcm_info = NULL;
+    int err;
+    char *t;
+    const char *name;
+    char *name_buf = NULL;
+    int namereg_fail;
+    pa_bool_t use_mmap = TRUE, b, d;
+    pa_sink_new_data data;
+    const pa_alsa_profile_info *profile;
+    pa_bool_t ignore_dB = FALSE;
+    int mixer_count = 0;
+
+    snd_pcm_info_alloca(&pcm_info);
+
+    pa_assert(m);
+
+    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+        pa_log("Failed to parse module arguments");
+        goto fail;
+    }
+
+    ss = m->core->default_sample_spec;
+    if (pa_modargs_get_sample_spec_and_channel_map(ma, &ss, &map, PA_CHANNEL_MAP_ALSA) < 0) {
+        pa_log("Failed to parse sample specification and channel map");
+        goto fail;
+    }
+
+    if (pa_modargs_get_value_boolean(ma, "ignore_dB", &ignore_dB) < 0) {
+        pa_log("Failed to parse ignore_dB argument.");
+        goto fail;
+    }
+
+    alsa_mixer = pa_xstrdup(pa_modargs_get_value(ma, "mixer", "Master"));
+    replace_chars(alsa_mixer, '_', ' ');
+
+    if (pa_modargs_get_value(ma, "mixer_load", NULL)) {
+        mixer_load = pa_xstrdup(pa_modargs_get_value(ma, "mixer_load", NULL));
+        replace_chars(mixer_load, '_', ' ');
+        pa_log_info("preload mixers %s", mixer_load);
+    } else {
+        /* Default to loading alsa_mixer, if mixer_load is not defined. */
+        mixer_load = pa_xstrdup(alsa_mixer);
+    }
+
+    frame_size = pa_frame_size(&ss);
+
+    nfrags = m->core->default_n_fragments;
+    frag_size = pa_usec_to_bytes(m->core->default_fragment_size_msec*1000, &ss);
+    if (frag_size <= 0)
+        frag_size = frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "fragments", &nfrags) < 0 || pa_modargs_get_value_u32(ma, "fragment_size", &frag_size) < 0) {
+        pa_log("Failed to parse buffer metrics");
+        goto fail;
+    }
+    period_size = frag_size/frame_size;
+
+    alt_frame_size = pa_frame_size(&ss);
+
+    /* 0 is default value from pa_modargs_get */
+    alt_period_size = 0;
+    alt_nfrags = 0;
+    alt_frag_size = alt_frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "alt_fragments", &alt_nfrags) < 0 || pa_modargs_get_value_u32(ma, "alt_fragment_size", &alt_frag_size) < 0) {
+        pa_log("Failed to parse alt buffer metrics");
+        goto fail;
+    }
+
+    if (alt_nfrags != 0) {
+        alt_period_size = alt_frag_size/alt_frame_size;
+    }
+
+    if (pa_modargs_get_value_boolean(ma, "mmap", &use_mmap) < 0) {
+        pa_log("Failed to parse mmap argument.");
+        goto fail;
+    }
+
+    u = pa_xnew0(struct userdata, 1);
+    u->ignore_dB = ignore_dB;
+    u->switch_mode = SINK_SWITCH_PRIMARY;
+    if (alt_nfrags != 0)
+        u->switching_enabled = TRUE;
+    else
+        u->switching_enabled = FALSE;
+    u->core = m->core;
+    u->module = m;
+    m->userdata = u;
+    u->use_mmap = use_mmap;
+    u->first = TRUE;
+    u->rtpoll = pa_rtpoll_new();
+    pa_thread_mq_init(&u->thread_mq, m->core->mainloop, u->rtpoll);
+    u->alsa_rtpoll_item = NULL;
+
+    snd_config_update_free_global();
+
+    b = use_mmap;
+    d = FALSE; /* use_tsched */
+    profile = NULL; /* no profile specified */
+
+    if ((dev_id = pa_modargs_get_value(ma, "device_id", NULL))) {
+
+        if (!(u->pcm_handle = pa_alsa_open_by_device_id_auto(
+                      dev_id,
+                      &u->device_name,
+                      &ss, &map,
+                      SND_PCM_STREAM_PLAYBACK,
+                      &nfrags, &period_size, period_size * nfrags,
+                      &b, &d, &profile)))
+
+            goto fail;
+
+    } else {
+
+        if (!(u->pcm_handle = pa_alsa_open_by_device_string(
+                      pa_modargs_get_value(ma, "device", DEFAULT_DEVICE),
+                      &u->device_name,
+                      &ss, &map,
+                      SND_PCM_STREAM_PLAYBACK,
+                      &nfrags, &period_size, period_size * nfrags,
+                      &b, &d, FALSE)))
+            goto fail;
+
+    }
+
+    pa_assert(u->device_name);
+    pa_log_info("Successfully opened device %s.", u->device_name);
+
+    if (use_mmap && !b) {
+        pa_log_info("Device doesn't support mmap(), falling back to UNIX read/write mode.");
+        u->use_mmap = use_mmap = b;
+    }
+
+    if (u->use_mmap)
+        pa_log_info("Successfully enabled mmap() mode.");
+
+    if ((err = snd_pcm_info(u->pcm_handle, pcm_info)) < 0) {
+        pa_log("Error fetching PCM info: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if ((err = pa_alsa_set_sw_params(u->pcm_handle, period_size)) < 0) {
+        pa_log("Failed to set software parameters: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    /* ALSA might tweak the sample spec, so recalculate the frame size */
+    frame_size = pa_frame_size(&ss);
+    alt_frame_size = pa_frame_size(&ss);
+
+    if ((err = snd_mixer_open(&u->mixer_handle, 0)) < 0) {
+        pa_log("Error opening mixer: %s", snd_strerror(err));
+    } else {
+        pa_bool_t found = FALSE;
+
+        if (pa_alsa_prepare_mixer(u->mixer_handle, u->device_name) >= 0)
+            found = TRUE;
+        else {
+            snd_pcm_info_t *info;
+
+            snd_pcm_info_alloca(&info);
+
+            if (snd_pcm_info(u->pcm_handle, info) >= 0) {
+                char *md;
+                int card_idx;
+
+                if ((card_idx = snd_pcm_info_get_card(info)) >= 0) {
+
+                    md = pa_sprintf_malloc("hw:%i", card_idx);
+
+                    if (strcmp(u->device_name, md))
+                        if (pa_alsa_prepare_mixer(u->mixer_handle, md) >= 0)
+                            found = TRUE;
+                    pa_xfree(md);
+                }
+            }
+        }
+
+        if (!found) {
+            snd_mixer_close(u->mixer_handle);
+            u->mixer_handle = NULL;
+        }
+    }
+
+    if ((name = pa_modargs_get_value(ma, "sink_name", NULL)))
+        namereg_fail = 1;
+    else {
+        name = name_buf = pa_sprintf_malloc("alsa_output.%s", u->device_name);
+        namereg_fail = 0;
+    }
+
+    pa_sink_new_data_init(&data);
+    data.driver = __FILE__;
+    data.module = m;
+    pa_sink_new_data_set_name(&data, name);
+    data.namereg_fail = namereg_fail;
+    pa_sink_new_data_set_sample_spec(&data, &ss);
+    pa_sink_new_data_set_channel_map(&data, &map);
+
+    pa_alsa_init_proplist_pcm(m->core, data.proplist, u->pcm_handle);
+    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_STRING, u->device_name);
+    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE, "%lu", (unsigned long) (period_size * frame_size * nfrags));
+    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE, "%lu", (unsigned long) (period_size * frame_size));
+    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_ACCESS_MODE, (u->use_mmap ? "mmap" : "serial"));
+
+    u->sink = pa_sink_new(m->core, &data, PA_SINK_HARDWARE|PA_SINK_LATENCY);
+    pa_sink_new_data_done(&data);
+    pa_xfree(name_buf);
+
+    if (!u->sink) {
+        pa_log("Failed to create sink object");
+        goto fail;
+    }
+
+    u->sink->parent.process_msg = sink_process_msg;
+    u->sink->update_requested_latency = NULL;
+    u->sink->userdata = u;
+
+    pa_sink_set_asyncmsgq(u->sink, u->thread_mq.inq);
+    pa_sink_set_rtpoll(u->sink, u->rtpoll);
+    pa_sink_set_description(u->sink, t = pa_sprintf_malloc(
+                                    "ALSA PCM on %s (%s)%s",
+                                    u->device_name,
+                                    snd_pcm_info_get_name(pcm_info),
+                                    use_mmap ? " via DMA" : ""));
+    pa_xfree(t);
+
+    u->frame_size = frame_size;
+    u->fragment_size = frag_size = period_size * frame_size;
+    u->nfragments = nfrags;
+    u->hwbuf_size = u->fragment_size * nfrags;
+    u->period_size = period_size;
+
+    if (u->switching_enabled) {
+        u->pri_frame_size = frame_size;
+        u->pri_fragment_size = frag_size = period_size * frame_size;
+        u->pri_nfragments = nfrags;
+        u->pri_hwbuf_size = u->fragment_size * nfrags;
+        u->pri_period_size = period_size;
+
+        u->alt_frame_size = alt_frame_size;
+        u->alt_fragment_size = alt_frag_size = alt_period_size * alt_frame_size;
+        u->alt_nfragments = alt_nfrags;
+        u->alt_hwbuf_size = u->alt_fragment_size * alt_nfrags;
+        u->alt_period_size = alt_period_size;
+    }
+
+
+    pa_log_info("PRI: Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->fragment_size);
+    if (u->switching_enabled)
+        pa_log_info("ALT: Using %u fragments of size %lu bytes.", alt_nfrags, (long unsigned) u->alt_fragment_size);
+
+    pa_memchunk_reset(&u->memchunk);
+
+    u->channel_map = map;
+    if (!(u->thread = pa_thread_new(thread_func, u))) {
+        pa_log("Failed to create thread.");
+        goto fail;
+    }
+
+    if (mixer_load)
+        mixer_count = get_mixer_elements(u, mixer_load);
+
+    init_volume_cache(u);
+
+    pa_proplist_sets(u->sink->proplist, PA_ALSA_SINK_PROP_BUFFERS, PA_ALSA_SINK_PROP_BUFFERS_PRIMARY);
+    pa_proplist_sets(u->sink->proplist, PA_ALSA_SINK_PROP_MIXER, "(none)");
+
+    /* hook for buffer & mixer switching, only if either buffer switching or
+     * mixer gain step modification is possible. */
+    if (u->switching_enabled || mixer_load)
+        u->sink_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_PROPLIST_CHANGED],
+                                                        PA_HOOK_LATE,
+                                                        (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
+
+    pa_sink_put(u->sink);
+
+    /* pa_sink_put modifies sink flags */
+    u->default_flags = u->sink->flags; 
+
+#if 0
+    /* allow stream restore to apply old volumes */
+    if (u->sink->set_volume)
+        u->sink->set_volume(u->sink);
+    if (u->sink->set_mute)
+        u->sink->set_mute(u->sink);
+#endif
+
+    if (mixer_count > 0) {
+        if (load_mixer_volumes(u) == 0 && u->cache_volumes)
+            load_default_mixer_volumes(u);
+    }
+
+    set_mixer_elem_by_name(u, alsa_mixer);
+
+    if (u->active_mixer) {
+        char *tmp = pa_sprintf_malloc("%s:%s", u->active_mixer->name, PA_ALSA_SINK_PROP_MIXER_CONTROL);
+        pa_proplist_sets(u->sink->proplist, PA_ALSA_SINK_PROP_MIXER, tmp);
+        pa_xfree(tmp);
+        pa_log_debug("%s: update active mixer volume", u->device_name);
+        pa_sink_set_volume(u->sink, &u->active_mixer->cache_volume, TRUE, TRUE);
+        pa_sink_set_mute(u->sink, u->active_mixer->cache_muted);
+    }
+
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
+    if (mixer_load)
+        pa_xfree(mixer_load);
+
+    pa_modargs_free(ma);
+
+    return 0;
+
+ fail:
+
+    if (alsa_mixer)
+        pa_xfree(alsa_mixer);
+
+    if (mixer_load)
+        pa_xfree(mixer_load);
+
+    if (ma)
+        pa_modargs_free(ma);
+
+    pa__done(m);
+
+    return -1;
+}
+
+void pa__done(pa_module*m) {
+    struct userdata *u;
+
+    pa_assert(m);
+
+    if (!(u = m->userdata))
+        return;
+
+    if (u->sink_proplist_changed_slot)
+        pa_hook_slot_free(u->sink_proplist_changed_slot);
+
+    if (u->cache_volumes)
+        store_mixer_volumes(u);
+
+    if (u->mixer_list)
+        free_mixer_elements(u);
+
+    if (u->gdbm_file)
+        gdbm_close(u->gdbm_file);
+
+    if (u->sink)
+        pa_sink_unlink(u->sink);
+
+    if (u->thread) {
+        pa_asyncmsgq_send(u->thread_mq.inq, NULL, PA_MESSAGE_SHUTDOWN, NULL, 0, NULL);
+        pa_thread_free(u->thread);
+    }
+
+    pa_thread_mq_done(&u->thread_mq);
+
+    if (u->sink)
+        pa_sink_unref(u->sink);
+
+    if (u->memchunk.memblock)
+        pa_memblock_unref(u->memchunk.memblock);
+
+    if (u->alsa_rtpoll_item)
+        pa_rtpoll_item_free(u->alsa_rtpoll_item);
+
+    if (u->rtpoll)
+        pa_rtpoll_free(u->rtpoll);
+
+    if (u->mixer_handle)
+        snd_mixer_close(u->mixer_handle);
+
+    if (u->pcm_handle) {
+        snd_pcm_drop(u->pcm_handle);
+        snd_pcm_close(u->pcm_handle);
+    }
+
+    pa_xfree(u->device_name);
+    pa_xfree(u);
+
+    snd_config_update_free_global();
+}
-- 
1.6.2.rc1.13.gfd76c.dirty

