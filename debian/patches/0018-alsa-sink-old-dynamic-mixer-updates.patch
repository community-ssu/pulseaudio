From 947ae108b0cc88a43eeb1afe0bcd9ef4cc9e621c Mon Sep 17 00:00:00 2001
From: Juho Hamalainen <ext-juho.hamalainen@nokia.com>
Date: Mon, 2 Feb 2009 12:56:03 +0200
Subject: [PATCH 18/22] alsa-sink-old: dynamic mixer updates

- Set mixer controls during init, and dynamic switching by properties.
- Modify ALSA volume steps using properties (as comma separated values)
---
 src/modules/alsa/module-alsa-sink-old.c |  582 ++++++++++++++++++++++++-------
 src/modules/alsa/module-alsa-sink-old.h |   13 +-
 2 files changed, 461 insertions(+), 134 deletions(-)

diff --git a/src/modules/alsa/module-alsa-sink-old.c b/src/modules/alsa/module-alsa-sink-old.c
index 1a0d766..af631ae 100644
--- a/src/modules/alsa/module-alsa-sink-old.c
+++ b/src/modules/alsa/module-alsa-sink-old.c
@@ -63,6 +63,8 @@ PA_MODULE_USAGE(
         "channels=<number of channels> "
         "rate=<sample rate> "
         "mixer=<initial ALSA mixer> "
+        "mixer_load=<load mixer controls in startup> "
+        "mixer_off_volume=<mixer level when it isn't used> "
         "fragments=<number of fragments> "
         "fragment_size=<fragment size> "
         "alt_fragments=<number of fragments> "
@@ -75,6 +77,24 @@ PA_MODULE_USAGE(
 #define SINK_SWITCH_PRIMARY (0)
 #define SINK_SWITCH_ALTERNATIVE (1)
 
+struct mixer_control_t {
+    char *name;
+    pa_alsa_fdlist *mixer_fdl;
+    snd_mixer_elem_t *mixer_elem;
+    snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
+    unsigned channels;
+    long hw_volume_max;
+    long hw_volume_min;
+    unsigned gain_step_count;
+    long *gain_step;
+
+    /* cache proplist strings */
+    char *prop_mixer_gain_step;
+    char *prop_mixer_gain_step_count;
+
+    PA_LLIST_FIELDS(struct mixer_control_t);
+};
+
 struct userdata {
     pa_core *core;
     pa_module *module;
@@ -85,11 +105,7 @@ struct userdata {
     pa_rtpoll *rtpoll;
 
     snd_pcm_t *pcm_handle;
-
-    pa_alsa_fdlist *mixer_fdl;
     snd_mixer_t *mixer_handle;
-    snd_mixer_elem_t *mixer_elem;
-    long hw_volume_max, hw_volume_min;
 
     size_t frame_size, fragment_size, hwbuf_size;
     snd_pcm_uframes_t period_size;
@@ -107,9 +123,14 @@ struct userdata {
     pa_bool_t switching_enabled;
     int switch_mode;
 
-    pa_hook_slot *sink_proplist_changed_slot;
-    char *mixer_name;
+    /* store for all loaded mixers */
+    PA_LLIST_HEAD(struct mixer_control_t, mixer_list);
+    struct mixer_control_t *active_mixer;
     pa_channel_map channel_map;
+    pa_cvolume mixer_off_volume;
+
+    pa_hook_slot *sink_proplist_changed_slot;
+
     char *device_name;
 
     pa_bool_t use_mmap;
@@ -117,8 +138,6 @@ struct userdata {
     pa_bool_t first;
 
     pa_rtpoll_item *alsa_rtpoll_item;
-
-    snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
 };
 
 static const char* const valid_modargs[] = {
@@ -129,6 +148,8 @@ static const char* const valid_modargs[] = {
     "channels",
     "rate",
     "mixer",
+    "mixer_load",
+    "mixer_off_volume",
     "fragments",
     "fragment_size",
     "alt_fragments",
@@ -138,6 +159,14 @@ static const char* const valid_modargs[] = {
     NULL
 };
 
+static void replace_chars(char *str, const char c, const char new_c) {
+    unsigned ii = 0;
+    pa_assert(str);
+    while(str[ii++] != '\0') { // is there a pa function for this?
+        if (str[ii] == c)
+            str[ii] = new_c;
+    }
+}
 
 static void switch_buffers(struct userdata *u, int switch_mode) {
     unsigned num_inputs = 0;
@@ -176,6 +205,8 @@ static void switch_buffers(struct userdata *u, int switch_mode) {
         u->nfragments = u->alt_nfragments;
         u->period_size = u->alt_period_size;
     }
+
+    /* update buffer metrics */
     pa_proplist_setf(u->sink->proplist,
                      PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE,
                      "%lu", (unsigned long) (u->period_size * u->frame_size * u->nfragments));
@@ -545,7 +576,10 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
 
                 case PA_SINK_UNLINKED:
                 case PA_SINK_INIT:
-                    ;
+                    break;
+                case PA_SINK_INVALID_STATE:
+                    pa_log_error("invalid state");
+                    break;
             }
 
             break;
@@ -554,6 +588,9 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
             break;
         case PA_SINK_MESSAGE_REMOVE_INPUT:
             break;
+
+        default:
+            break;
     }
 
     return pa_sink_process_msg(o, code, data, offset, chunk);
@@ -576,109 +613,152 @@ static int mixer_callback(snd_mixer_elem_t *elem, unsigned int mask) {
     return 0;
 }
 
-static int sink_get_volume_cb(pa_sink *s) {
-    struct userdata *u = s->userdata;
+static int get_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *mixer, pa_cvolume *volume) {
     int err;
     int i;
 
     pa_assert(u);
-    pa_assert(u->mixer_elem);
+    pa_assert(mixer);
+    pa_assert(volume);
 
-    for (i = 0; i < s->sample_spec.channels; i++) {
-        long set_vol, vol;
+    for (i = 0; i < u->sink->sample_spec.channels; i++) {
+        long set_vol = 0, vol = 0;
 
-        pa_assert(snd_mixer_selem_has_playback_channel(u->mixer_elem, u->mixer_map[i]));
+        pa_assert(snd_mixer_selem_has_playback_channel(mixer->mixer_elem, mixer->mixer_map[i]));
 
-        if ((err = snd_mixer_selem_get_playback_volume(u->mixer_elem, u->mixer_map[i], &vol)) < 0)
-            goto fail;
+        if ((err = snd_mixer_selem_get_playback_volume(mixer->mixer_elem, mixer->mixer_map[i], &vol)) < 0) {
+            pa_log_error("Unable to read volume: %s", snd_strerror(err));
+            return 1;
+        }
 
-        set_vol = (long) roundf(((float) s->volume.values[i] * (u->hw_volume_max - u->hw_volume_min)) / PA_VOLUME_NORM) + u->hw_volume_min;
+        set_vol = (long) roundf(((float) volume->values[i] * (mixer->hw_volume_max - mixer->hw_volume_min)) / PA_VOLUME_NORM) + mixer->hw_volume_min;
 
         /* Try to avoid superfluous volume changes */
-        if (set_vol != vol)
-            s->volume.values[i] = (pa_volume_t) roundf(((float) (vol - u->hw_volume_min) * PA_VOLUME_NORM) / (u->hw_volume_max - u->hw_volume_min));
+        if (set_vol != vol) {
+            volume->values[i] = (pa_volume_t) roundf(((float) (vol - mixer->hw_volume_min) * PA_VOLUME_NORM) / (mixer->hw_volume_max - mixer->hw_volume_min));
+        }
     }
 
     return 0;
+}
 
-fail:
-    pa_log_error("Unable to read volume: %s", snd_strerror(err));
+static int sink_get_volume_cb(pa_sink *s) {
+    struct userdata *u = s->userdata;
 
-    s->get_volume = NULL;
-    s->set_volume = NULL;
-    return -1;
+    if (get_alsa_mixer_volumes(u, u->active_mixer, &s->volume)) {
+        s->get_volume = NULL;
+        s->set_volume = NULL;
+        return -1;
+    } else {
+        return 0;
+    }
 }
 
-static int sink_set_volume_cb(pa_sink *s) {
-    struct userdata *u = s->userdata;
+static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *mixer, const pa_cvolume *volume) {
     int err;
     int i;
+    int step;
 
     pa_assert(u);
-    pa_assert(u->mixer_elem);
+    pa_assert(mixer->mixer_elem);
 
-    for (i = 0; i < s->sample_spec.channels; i++) {
+    for (i = 0; i < u->sink->sample_spec.channels; i++) {
         long alsa_vol;
         pa_volume_t vol;
 
-        pa_assert(snd_mixer_selem_has_playback_channel(u->mixer_elem, u->mixer_map[i]));
+        pa_assert(snd_mixer_selem_has_playback_channel(mixer->mixer_elem, mixer->mixer_map[i]));
 
-        vol = s->volume.values[i];
+        vol = volume->values[i];
 
         if (vol > PA_VOLUME_NORM)
             vol = PA_VOLUME_NORM;
 
-        alsa_vol = (long) roundf(((float) vol * (u->hw_volume_max - u->hw_volume_min)) / PA_VOLUME_NORM) + u->hw_volume_min;
+        alsa_vol = (long) roundf(((float) vol * (mixer->hw_volume_max - mixer->hw_volume_min)) / PA_VOLUME_NORM) + mixer->hw_volume_min;
 
-        if ((err = snd_mixer_selem_set_playback_volume(u->mixer_elem, u->mixer_map[i], alsa_vol)) < 0)
-            goto fail;
+        if (mixer->gain_step) {
+            step = (mixer->hw_volume_max - mixer->hw_volume_min)/mixer->gain_step_count;
+            step = alsa_vol/step;
+
+            if (step < 0)
+                alsa_vol = mixer->gain_step[0];
+            else if (step >= (int)mixer->gain_step_count)
+                alsa_vol = mixer->gain_step[mixer->gain_step_count-1];
+            else
+                alsa_vol = mixer->gain_step[step];
+
+            pa_log_debug("%s: gain step %d vol %ld", mixer->name, step, alsa_vol);
+        }
+
+        if ((err = snd_mixer_selem_set_playback_volume(mixer->mixer_elem, mixer->mixer_map[i], alsa_vol)) < 0) {
+            pa_log_error("Unable to set volume: %s", snd_strerror(err));
+            return 1;
+        }
     }
 
     return 0;
+}
 
-fail:
-    pa_log_error("Unable to set volume: %s", snd_strerror(err));
+static int sink_set_volume_cb(pa_sink *s) {
+    struct userdata *u = s->userdata;
 
-    s->get_volume = NULL;
-    s->set_volume = NULL;
-    return -1;
+    if (set_alsa_mixer_volumes(u, u->active_mixer, &s->volume)) {
+        s->get_volume = NULL;
+        s->set_volume = NULL;
+        return -1;
+    }
+
+    return 0;
 }
 
-static int sink_get_mute_cb(pa_sink *s) {
-    struct userdata *u = s->userdata;
+static int get_alsa_mixer_mute(struct userdata *u, struct mixer_control_t *mixer, pa_bool_t *muted) {
     int err, sw;
 
     pa_assert(u);
-    pa_assert(u->mixer_elem);
+    pa_assert(mixer->mixer_elem);
 
-    if ((err = snd_mixer_selem_get_playback_switch(u->mixer_elem, 0, &sw)) < 0) {
+    if ((err = snd_mixer_selem_get_playback_switch(mixer->mixer_elem, 0, &sw)) < 0) {
         pa_log_error("Unable to get switch: %s", snd_strerror(err));
-
-        s->get_mute = NULL;
-        s->set_mute = NULL;
         return -1;
     }
 
-    s->muted = !sw;
+    *muted = !sw;
 
     return 0;
 }
 
-static int sink_set_mute_cb(pa_sink *s) {
+static int sink_get_mute_cb(pa_sink *s) {
     struct userdata *u = s->userdata;
+
+    if (get_alsa_mixer_mute(u, u->active_mixer, &s->muted)) {
+        s->get_mute = NULL;
+        s->set_mute = NULL;
+        return -1;
+    }
+    return 0;
+}
+
+static int set_alsa_mixer_mute(struct userdata *u, struct mixer_control_t *mixer, pa_bool_t muted) {
     int err;
 
     pa_assert(u);
-    pa_assert(u->mixer_elem);
+    pa_assert(mixer->mixer_elem);
 
-    if ((err = snd_mixer_selem_set_playback_switch_all(u->mixer_elem, !s->muted)) < 0) {
+    if ((err = snd_mixer_selem_set_playback_switch_all(mixer->mixer_elem, !muted)) < 0) {
         pa_log_error("Unable to set switch: %s", snd_strerror(err));
+        return -1;
+    }
+
+    return 0;
+}
 
+static int sink_set_mute_cb(pa_sink *s) {
+    struct userdata *u = s->userdata;
+
+    if (set_alsa_mixer_mute(u, u->active_mixer, s->muted)) {
         s->get_mute = NULL;
         s->set_mute = NULL;
         return -1;
     }
-
     return 0;
 }
 
@@ -824,38 +904,105 @@ static int open_alsa_mixer(struct userdata *u, const char *dev_id) {
     return 0;
 }
 
-static int set_alsa_mixer(struct userdata *u, const char *mixer) {
-    int ret = 0;
+static void mute_unused_mixers(struct userdata *u, struct mixer_control_t *active_mixer) {
+    struct mixer_control_t *m = NULL;
+    pa_assert(u);
+    pa_assert(u->mixer_off_volume.channels > 0);
+    for (m = u->mixer_list; m; m = m->next) {
+        if (m != active_mixer)
+            set_alsa_mixer_volumes(u, m, &u->mixer_off_volume);
+    }
+}
+
+static int set_mixer_elem_by_name(struct userdata *u, const char *mixer) {
+    struct mixer_control_t *m = NULL;
+
+    for (m = u->mixer_list; m; m = m->next) {
+        if (strcmp(mixer, m->name) == 0) {
+            pa_log_info("%s: setting active mixer to %s", u->device_name, m->name);
+
+            if (snd_mixer_selem_has_playback_volume(m->mixer_elem))
+                if (pa_alsa_calc_mixer_map(m->mixer_elem, &u->channel_map, m->mixer_map, TRUE) >= 0) {
+                    u->sink->get_volume = sink_get_volume_cb;
+                    u->sink->set_volume = sink_set_volume_cb;
+                    u->sink->flags |= PA_SINK_HW_VOLUME_CTRL;
+                }
+
+            if (snd_mixer_selem_has_playback_switch(m->mixer_elem)) {
+                u->sink->get_mute = sink_get_mute_cb;
+                u->sink->set_mute = sink_set_mute_cb;
+                u->sink->flags |= PA_SINK_HW_VOLUME_CTRL;
+            }
+
+            u->active_mixer = m;
+            break;
+        } else {
+            pa_log_info("%s: no preloaded mixer %s found", u->device_name, mixer);
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+static struct mixer_control_t* mixer_control_new(const char *name,
+                                                 pa_alsa_fdlist *mixer_fdl,
+                                                 snd_mixer_elem_t *mixer_elem,
+                                                 snd_mixer_selem_channel_id_t *mixer_map,
+                                                 const unsigned channels,
+                                                 long hw_volume_min,
+                                                 long hw_volume_max,
+                                                 unsigned gain_step_count,
+                                                 long *gain_step) {
+    struct mixer_control_t *m = NULL;
+    m = pa_xnew0(struct mixer_control_t, 1);
+    PA_LLIST_INIT(struct mixer_control_t, m);
+
+    m->name = pa_xstrdup(name);
+    m->mixer_fdl = mixer_fdl;
+    m->mixer_elem = mixer_elem;
+    memcpy(&m->mixer_map, mixer_map, sizeof(snd_mixer_selem_channel_id_t)*SND_MIXER_SCHN_LAST);
+    m->channels = channels;
+    m->hw_volume_min = hw_volume_min;
+    m->hw_volume_max = hw_volume_max;
+    m->gain_step_count = gain_step_count;
+    if (gain_step_count > 0) {
+        m->gain_step = pa_xnew0(long, gain_step_count);
+        memcpy(&m->gain_step, gain_step, sizeof(long)*gain_step_count);
+    } else {
+        m->gain_step_count = 0;
+        m->gain_step = NULL;
+    }
+
+    /* cache proplist strings */
+    m->prop_mixer_gain_step_count = pa_sprintf_malloc(PA_ALSA_SINK_PROP_MIXER_GAIN_STEP_COUNT, m->name);
+    replace_chars(m->prop_mixer_gain_step_count, ' ', '_');
+    m->prop_mixer_gain_step = pa_sprintf_malloc(PA_ALSA_SINK_PROP_MIXER_GAIN_STEP, m->name);
+    replace_chars(m->prop_mixer_gain_step, ' ', '_');
+
+    return m;
+}
+
+
+static struct mixer_control_t* get_mixer_element(struct userdata *u,
+                                                 const char *mixer) {
+    struct mixer_control_t *m = NULL;
     snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
     pa_alsa_fdlist *mixer_fdl = NULL;
     snd_mixer_elem_t *mixer_elem = NULL;
+    long hw_volume_min;
+    long hw_volume_max;
 
     if (u->mixer_handle) {
-        if (u->mixer_elem) {
-            pa_log_info("close old mixer element");
-            if (u->mixer_fdl) {
-                pa_alsa_fdlist_free(u->mixer_fdl);
-                u->mixer_fdl = NULL;
-            }
-            u->sink->get_volume = NULL;
-            u->sink->set_volume = NULL;
-            u->sink->get_mute = NULL;
-            u->sink->set_mute = NULL;
-        }
         /* Try using mixer as both primary and fallback mixer, to ensure mixer selection
-         * even when mixer hasn't got both volume and mute switches */
+         * even when mixer doesn't have both volume and mute switches */
         if (!(mixer_elem = pa_alsa_find_elem(u->mixer_handle, mixer, mixer, TRUE))) {
-            ret = -1;
-            /* Try to select previously used mixer again */
-            if (u->mixer_name)
-                if (!(mixer_elem = pa_alsa_find_elem(u->mixer_handle, u->mixer_name, u->mixer_name, TRUE))) {
-                    pa_log_warn("Could not select mixer at all");
-                    goto done;
-                }
+            pa_log_error("%s: could not select mixer %s at all", u->device_name, mixer);
+            goto fail;
         }
     } else {
-        pa_log("No mixer handle.");
-        goto done;
+        pa_log_error("%s: No mixer handle.", u->device_name);
+        goto fail;
     }
 
     if (u->mixer_handle && mixer_elem) {
@@ -863,50 +1010,149 @@ static int set_alsa_mixer(struct userdata *u, const char *mixer) {
 
         if (snd_mixer_selem_has_playback_volume(mixer_elem))
             if (pa_alsa_calc_mixer_map(mixer_elem, &u->channel_map, mixer_map, TRUE) >= 0) {
-                u->sink->get_volume = sink_get_volume_cb;
-                u->sink->set_volume = sink_set_volume_cb;
-                snd_mixer_selem_get_playback_volume_range(mixer_elem, &u->hw_volume_min, &u->hw_volume_max);
-                u->sink->flags |= PA_SINK_HW_VOLUME_CTRL;
+                snd_mixer_selem_get_playback_volume_range(mixer_elem, &hw_volume_min, &hw_volume_max);
             }
 
-        if (snd_mixer_selem_has_playback_switch(mixer_elem)) {
-            u->sink->get_mute = sink_get_mute_cb;
-            u->sink->set_mute = sink_set_mute_cb;
-            u->sink->flags |= PA_SINK_HW_VOLUME_CTRL;
-        }
-
         mixer_fdl = pa_alsa_fdlist_new();
 
         if (pa_alsa_fdlist_set_mixer(mixer_fdl, u->mixer_handle, u->module->core->mainloop) < 0) {
             pa_log("Failed to initialize file descriptor monitoring");
-            //return -1; // goto fail;
-            goto done;
+            goto fail;
         }
 
         snd_mixer_elem_set_callback(mixer_elem, mixer_callback);
         snd_mixer_elem_set_callback_private(mixer_elem, u);
 
-        u->mixer_elem = mixer_elem;
-        u->mixer_fdl = mixer_fdl;
-        memcpy(&u->mixer_map, &mixer_map, sizeof(snd_mixer_selem_channel_id_t)*SND_MIXER_SCHN_LAST);
+        m = mixer_control_new(mixer,
+                              mixer_fdl,
+                              mixer_elem,
+                              mixer_map,
+                              u->sink->sample_spec.channels,
+                              hw_volume_min,
+                              hw_volume_max,
+                              0, NULL);
+
+        pa_log_info("%s: new mixer found: %s", u->device_name, m->name);
 
-        /* Remember selected mixer name */
-        if (u->mixer_name && ret > -1) {
-            pa_xfree(u->mixer_name);
-            u->mixer_name = NULL;
+    } else {
+        mixer_fdl = NULL;
+    }
+
+    return m;
+fail:
+    if (mixer_fdl) {
+        pa_alsa_fdlist_free(mixer_fdl);
+        mixer_fdl = NULL;
+    }
+
+    return NULL;
+}
+
+static int get_mixer_elements(struct userdata *u, const char *mixer_list) {
+    const char *state = NULL;
+    struct mixer_control_t *m = NULL;
+    char *mixer;
+    pa_assert(u);
+    pa_assert(mixer_list);
+
+    while ((mixer = pa_split(mixer_list, ",", &state))) {
+        if (mixer) {
+            m = get_mixer_element(u, mixer);
+            if (m) {
+                PA_LLIST_PREPEND(struct mixer_control_t, u->mixer_list, m);
+            }
+            pa_xfree(mixer);
         }
-        if (!u->mixer_name)
-            u->mixer_name = pa_xstrdup(mixer);
+    }
+
+    return 0;
+}
+
+static void free_mixer_element(struct mixer_control_t *m) {
+    pa_xfree(m->name);
+    pa_alsa_fdlist_free(m->mixer_fdl);
+    m->mixer_elem = NULL;
+    if (m->gain_step_count > 0) {
+        if (m->gain_step)
+            pa_xfree(m->gain_step);
+    }
+    pa_xfree(m->prop_mixer_gain_step);
+    pa_xfree(m->prop_mixer_gain_step_count);
+
+    pa_xfree(m);
+}
+
+static void free_mixer_elements(struct userdata *u) {
+    struct mixer_control_t *m;
+    pa_log_debug("free mixer elements");
+
+    while ((m = u->mixer_list)) {
+        PA_LLIST_REMOVE(struct mixer_control_t, u->mixer_list, m);
+        free_mixer_element(m);
+    }
+}
+
+static int update_mixer_gain_steps(struct userdata *u,
+                                   struct mixer_control_t *m,
+                                   const char *step_list,
+                                   const unsigned count) {
+    const char *state = NULL;
+    unsigned i = 0;
+    char *num_str;
+    unsigned num;
+
+    if (count > 0) {
+        if (m->gain_step)
+            pa_xfree(m->gain_step);
+        m->gain_step = pa_xnew0(long, count);
+        m->gain_step_count = count;
     } else {
-        u->mixer_fdl = NULL;
+        pa_log_warn("Step count <= 0");
+        return 1;
     }
 
-done:
-    return ret;
+    while ((num_str = pa_split(step_list, ",", &state))) {
+        if (num_str) {
+            if (i >= m->gain_step_count) {
+                pa_xfree(num_str);
+                goto bad_data;
+            }
+            if (pa_atou(num_str, &num) != 0) {
+                pa_xfree(num_str);
+                goto bad_data;
+            }
+            m->gain_step[i] = num;
+            i++;
+            pa_xfree(num_str);
+        }
+    }
+
+    if (i != m->gain_step_count)
+        goto bad_data;
+
+    pa_log_info("%s: updated gain steps (%u)", u->device_name, count);
+    return 0;
+
+bad_data:
+    pa_xfree(m->gain_step);
+    m->gain_step = NULL;
+    m->gain_step_count = 0;
+    pa_log_error("bad data for gain steps (\"%s\" count %u)", step_list, count);
+    return 1;
 }
 
 static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink *s, struct userdata *u) {
     const char *v = NULL;
+    unsigned count = 0;
+    const char *step_list = NULL;
+    pa_bool_t muted = FALSE;
+    const pa_cvolume *vol = NULL;
+    pa_bool_t update_volumes = FALSE;
+
+    if (s != u->sink)
+        return PA_HOOK_OK;
+
+    pa_log_debug("%s: sink_proplist_changed_hook_callback", u->device_name);
 
     pa_assert(u);
     pa_assert(s);
@@ -921,17 +1167,60 @@ static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink
         }
     }
 
-    v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_MIXER);
-    if (v) {
-        if (strcmp(v, u->mixer_name) != 0) {
-            pa_log_info("select mixer: %s", v);
-            if (set_alsa_mixer(u, v) < 0) {
-                pa_log_debug("reset old mixer name");
-                pa_proplist_sets(s->proplist, PA_ALSA_SINK_PROP_MIXER, u->mixer_name);
+    if (u->active_mixer) {
+        v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_MIXER);
+        if (v) {
+            if (strcmp(v, u->active_mixer->name) != 0) {
+
+                pa_log_info("select mixer: %s", v);
+
+                vol = pa_sink_get_volume(u->sink, TRUE);
+                muted = pa_sink_get_mute(u->sink, TRUE);
+                if (u->mixer_off_volume.channels > 0)
+                    set_alsa_mixer_volumes(u, u->active_mixer, &u->mixer_off_volume);
+                if (set_mixer_elem_by_name(u, v)) {
+                    /* try to load new mixer element */
+                    get_mixer_elements(u, v);
+                    if (set_mixer_elem_by_name(u, v)) {
+                        pa_log_error("%s: cannot load new mixer control %s", u->device_name, v);
+                        /* set correct mixer name to properties */
+                        pa_proplist_sets(s->proplist, PA_ALSA_SINK_PROP_MIXER, u->active_mixer->name);
+                    }
+                }
+
+                update_volumes = TRUE;
+            }
+        }
+    }
+
+    if (u->active_mixer) {
+        v = pa_proplist_gets(s->proplist, u->active_mixer->prop_mixer_gain_step_count);
+        if (v) {
+            if (pa_atou(v, &count)) {
+                pa_log_error("couldn't get gain count");
+            } else {
+                step_list = pa_proplist_gets(s->proplist, u->active_mixer->prop_mixer_gain_step);
+                if (step_list) {
+                    if (update_mixer_gain_steps(u, u->active_mixer, step_list, count)) {
+                        /* couldn't get steps, unset bad property values */
+                        pa_proplist_unset(s->proplist, u->active_mixer->prop_mixer_gain_step_count);
+                        pa_proplist_unset(s->proplist, u->active_mixer->prop_mixer_gain_step);
+                    }
+                    if (!vol) {
+                        vol = pa_sink_get_volume(u->sink, TRUE);
+                        muted = pa_sink_get_mute(u->sink, TRUE);
+                    }
+                    update_volumes = TRUE;
+                }
             }
         }
     }
 
+    if (update_volumes) {
+        pa_sink_set_volume(u->sink, vol);
+        pa_sink_set_mute(u->sink, muted);
+    }
+
     return PA_HOOK_OK;
 }
 
@@ -943,7 +1232,9 @@ int pa__init(pa_module*m) {
     pa_sample_spec ss;
     pa_channel_map map;
     char *alsa_mixer = NULL;
-    unsigned ii;
+    char *mixer_load = NULL;
+    uint32_t mixer_off_volume_u;
+    long mixer_off_volume;
     uint32_t nfrags, frag_size;
     uint32_t alt_nfrags, alt_frag_size;
     snd_pcm_uframes_t period_size;
@@ -959,6 +1250,7 @@ int pa__init(pa_module*m) {
     pa_bool_t use_mmap = TRUE, b, d;
     pa_sink_new_data data;
     const pa_alsa_profile_info *profile;
+    unsigned i;
 
     snd_pcm_info_alloca(&pcm_info);
 
@@ -976,10 +1268,20 @@ int pa__init(pa_module*m) {
     }
 
     alsa_mixer = pa_xstrdup(pa_modargs_get_value(ma, "mixer", "Master"));
-    ii = 0;
-    while(alsa_mixer[ii++] != '\0') { // is there a pa function for this?
-        if (alsa_mixer[ii] == '_')
-            alsa_mixer[ii] = ' ';
+    replace_chars(alsa_mixer, '_', ' ');
+
+    if (pa_modargs_get_value(ma, "mixer_load", NULL)) {
+        mixer_load = pa_xstrdup(pa_modargs_get_value(ma, "mixer_load", NULL));
+        replace_chars(mixer_load, '_', ' ');
+        pa_log_info("preload mixers %s", mixer_load);
+    }
+
+    mixer_off_volume = -1; /* Default to mixer_off_volume disabled */
+    if (pa_modargs_get_value_u32(ma, "mixer_off_volume", &mixer_off_volume_u) < 0) {
+        pa_log("Failed to parse mixer_off_volume");
+        goto fail;
+    } else {
+        mixer_off_volume = mixer_off_volume_u;
     }
 
     frame_size = pa_frame_size(&ss);
@@ -1022,6 +1324,13 @@ int pa__init(pa_module*m) {
         u->switching_enabled = TRUE;
     else
         u->switching_enabled = FALSE;
+    if (mixer_off_volume > -1) {
+        for (i = 0; i < map.channels; i++)
+            u->mixer_off_volume.values[i] = mixer_off_volume;
+        u->mixer_off_volume.channels = map.channels;
+    } else {
+        u->mixer_off_volume.channels = 0;
+    }
     u->core = m->core;
     u->module = m;
     m->userdata = u;
@@ -1154,6 +1463,7 @@ int pa__init(pa_module*m) {
         u->alt_period_size = alt_period_size;
     }
 
+
     pa_log_info("PRI: Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->fragment_size);
     if (u->switching_enabled)
         pa_log_info("ALT: Using %u fragments of size %lu bytes.", alt_nfrags, (long unsigned) u->alt_fragment_size);
@@ -1161,36 +1471,47 @@ int pa__init(pa_module*m) {
     pa_memchunk_reset(&u->memchunk);
 
     u->channel_map = map;
-    if (set_alsa_mixer(u, alsa_mixer) < 0)
-        goto fail;
-
     if (!(u->thread = pa_thread_new(thread_func, u))) {
         pa_log("Failed to create thread.");
         goto fail;
     }
 
-    /* Get initial mixer settings */
-    if (u->sink->get_volume)
-        u->sink->get_volume(u->sink);
-    if (u->sink->get_mute)
-        u->sink->get_mute(u->sink);
+    if (mixer_load) {
+        get_mixer_elements(u, mixer_load);
+    }
 
-    if (!u->mixer_name)
-        u->mixer_name = pa_sprintf_malloc("(none)");
+    set_mixer_elem_by_name(u, alsa_mixer);
 
     pa_proplist_sets(u->sink->proplist, PA_ALSA_SINK_PROP_BUFFERS, PA_ALSA_SINK_PROP_BUFFERS_PRIMARY);
-    pa_proplist_sets(u->sink->proplist, PA_ALSA_SINK_PROP_MIXER, u->mixer_name);
+    if (u->active_mixer)
+        pa_proplist_sets(u->sink->proplist, PA_ALSA_SINK_PROP_MIXER, u->active_mixer->name);
+    else
+        pa_proplist_sets(u->sink->proplist, PA_ALSA_SINK_PROP_MIXER, "(none)");
 
-    /* hook for buffer & mixer switching */
-    u->sink_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_PROPLIST_CHANGED],
-                                                    PA_HOOK_LATE,
-                                                    (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
+    /* hook for buffer & mixer switching, only if either buffer switching or
+     * mixer gain step modification is possible. */
+    if (u->switching_enabled || mixer_load)
+        u->sink_proplist_changed_slot = pa_hook_connect(&m->core->hooks[PA_CORE_HOOK_SINK_PROPLIST_CHANGED],
+                                                        PA_HOOK_LATE,
+                                                        (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
 
     pa_sink_put(u->sink);
 
+    /* allow stream restore to apply old volumes */
+    if (u->sink->set_volume)
+        u->sink->set_volume(u->sink);
+    if (u->sink->set_mute)
+        u->sink->set_mute(u->sink);
+
+    if (u->mixer_off_volume.channels > 0)
+        mute_unused_mixers(u, u->active_mixer);
+
     if (alsa_mixer)
         pa_xfree(alsa_mixer);
 
+    if (mixer_load)
+        pa_xfree(mixer_load);
+
     pa_modargs_free(ma);
 
     return 0;
@@ -1200,6 +1521,9 @@ fail:
     if (alsa_mixer)
         pa_xfree(alsa_mixer);
 
+    if (mixer_load)
+        pa_xfree(mixer_load);
+
     if (ma)
         pa_modargs_free(ma);
 
@@ -1216,6 +1540,9 @@ void pa__done(pa_module*m) {
     if (!(u = m->userdata))
         return;
 
+    if (u->mixer_list)
+        free_mixer_elements(u);
+
     if (u->sink)
         pa_sink_unlink(u->sink);
 
@@ -1238,9 +1565,6 @@ void pa__done(pa_module*m) {
     if (u->rtpoll)
         pa_rtpoll_free(u->rtpoll);
 
-    if (u->mixer_fdl)
-        pa_alsa_fdlist_free(u->mixer_fdl);
-
     if (u->mixer_handle)
         snd_mixer_close(u->mixer_handle);
 
@@ -1249,8 +1573,6 @@ void pa__done(pa_module*m) {
         snd_pcm_close(u->pcm_handle);
     }
 
-    if (u->mixer_name)
-        pa_xfree(u->mixer_name);
     pa_xfree(u->device_name);
     pa_xfree(u);
 
diff --git a/src/modules/alsa/module-alsa-sink-old.h b/src/modules/alsa/module-alsa-sink-old.h
index 69309cd..c230680 100644
--- a/src/modules/alsa/module-alsa-sink-old.h
+++ b/src/modules/alsa/module-alsa-sink-old.h
@@ -1,9 +1,14 @@
-#ifndef foomodulealsasinkfoo
-#define foomodulealsasinkfoo
+#ifndef foomodulealsasinkoldfoo
+#define foomodulealsasinkoldfoo
 
-#define PA_ALSA_SINK_PROP_MIXER   "x-maemo.alsa_sink.mixer"    /* Name of mixer control, PCM/Master/etc */
-#define PA_ALSA_SINK_PROP_BUFFERS "x-maemo.alsa_sink.buffers"  /* Buffer mode, primary/alternative */
+/* Name of mixer control, PCM/Master/etc */
+#define PA_ALSA_SINK_PROP_MIXER   "x-maemo.alsa_sink.mixer"
+/* String of comma separated numbers defining alsa volumes */
+#define PA_ALSA_SINK_PROP_MIXER_GAIN_STEP "x-maemo.alsa_sink.mixer.%s.gain_step"
+/* String containing gain step count number */
+#define PA_ALSA_SINK_PROP_MIXER_GAIN_STEP_COUNT "x-maemo.alsa_sink.mixer.%s.gain_step_count"
 
+#define PA_ALSA_SINK_PROP_BUFFERS "x-maemo.alsa_sink.buffers"  /* Buffer mode, primary/alternative */
 #define PA_ALSA_SINK_PROP_BUFFERS_PRIMARY     "primary"
 #define PA_ALSA_SINK_PROP_BUFFERS_ALTERNATIVE "alternative"
 
-- 
1.6.1.224.gb56c

