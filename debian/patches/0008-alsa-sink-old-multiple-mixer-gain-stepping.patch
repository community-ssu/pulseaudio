From 95f313fb1025a56a36d04a400349965121c836f1 Mon Sep 17 00:00:00 2001
From: Juho Hamalainen <ext-juho.hamalainen@nokia.com>
Date: Thu, 5 Mar 2009 12:07:32 +0200
Subject: [PATCH 08/49] alsa-sink-old: multiple mixer gain stepping

---
 src/modules/alsa/module-alsa-sink-old.c |  352 ++++++++++++++++++++++---------
 src/modules/alsa/module-alsa-sink-old.h |   13 +-
 2 files changed, 266 insertions(+), 99 deletions(-)

diff --git a/src/modules/alsa/module-alsa-sink-old.c b/src/modules/alsa/module-alsa-sink-old.c
index 96c5390..bfcd3cf 100644
--- a/src/modules/alsa/module-alsa-sink-old.c
+++ b/src/modules/alsa/module-alsa-sink-old.c
@@ -82,14 +82,19 @@ PA_MODULE_USAGE(
 #define SINK_SWITCH_ALTERNATIVE (1)
 #define SINK_DEFAULT_FLAGS PA_SINK_HARDWARE|PA_SINK_LATENCY
 
+struct gain_step_t {
+    int step;
+    pa_bool_t enabled;
+    pa_volume_t volume;
+    PA_LLIST_FIELDS(struct gain_step_t);
+};
+
 struct mixer_control_t {
     char *name;
     pa_alsa_fdlist *mixer_fdl;
     snd_mixer_elem_t *mixer_elem;
     snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
     unsigned channels;
-    unsigned gain_step_count;
-    long *gain_step;
 
     pa_bool_t hw_volume_control;
 
@@ -99,14 +104,14 @@ struct mixer_control_t {
     pa_bool_t mixer_separate_channels;
     pa_cvolume hardware_volume;
 
+    PA_LLIST_HEAD(struct gain_step_t, gain_step);
+    struct mixer_control_t **slaves;
+    pa_bool_t slave;
+
     /* store mixer volumes when mixer not in use */
     pa_cvolume cache_volume;
     pa_bool_t cache_muted;
 
-    /* cache proplist strings */
-    char *prop_mixer_gain_step;
-    char *prop_mixer_gain_step_count;
-
     PA_LLIST_FIELDS(struct mixer_control_t);
 };
 
@@ -736,6 +741,56 @@ static void sink_get_volume_cb(pa_sink *s) {
 
 
 static long update_alsa_volume(struct mixer_control_t *m, long alsa_vol) {
+
+    struct gain_step_t *g;
+    long vol = alsa_vol;
+    int step = 0;
+    int i;
+    int step_count = 0;
+
+    for (g = m->gain_step; g; g = g->next)
+        step_count++;
+
+    pa_log("update alsa volume for mixer %s, step count %d", m->name, step_count);
+
+    if (m->hw_dB_supported) {
+    pa_log("min %d max %d alsa_vol %ld", m->hw_dB_min, m->hw_dB_max, alsa_vol);
+        step = ((-m->hw_dB_max) + (-m->hw_dB_min)) / step_count;
+        step = (-alsa_vol)/step;
+        if (step < 0)
+            step = -step;
+
+    } else {
+        step = (m->hw_volume_max - m->hw_volume_min) / step_count;
+        step = alsa_vol/step;
+    }
+
+    pa_log("got step %d", step);
+
+    if (step < 0)
+        step = 0;
+    if (step >= step_count)
+        step = step_count-1;
+
+    if (step == 0)
+        vol = m->gain_step->volume;
+    else {
+        i = 1;
+        for (g = m->gain_step->next; g; g = g->next) {
+            if (step == i) {
+                vol = g->volume;
+                break;
+            }
+            i++;
+        }
+    }
+
+    pa_log("update alsa vol from %ld to %ld", alsa_vol, vol);
+
+    return vol;
+
+    
+#if 0
     long vol;
     int step = 0;
     pa_assert(m);
@@ -752,6 +807,8 @@ static long update_alsa_volume(struct mixer_control_t *m, long alsa_vol) {
 
     pa_log_debug("update alsa volume from %ld to %ld", alsa_vol, vol);
     return vol;
+#endif
+    return 0;
 }
 
 static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m, pa_cvolume *vv) {
@@ -778,6 +835,9 @@ static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m,
                 alsa_vol += m->hw_dB_max;
                 alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, m->hw_dB_min, m->hw_dB_max);
 
+                if (m->gain_step)
+                    alsa_vol = update_alsa_volume(m, alsa_vol);
+
                 if ((err = snd_mixer_selem_set_playback_dB(m->mixer_elem, m->mixer_map[i], alsa_vol, 1)) < 0)
                     goto fail;
 
@@ -817,6 +877,9 @@ static int set_alsa_mixer_volumes(struct userdata *u, struct mixer_control_t *m,
             alsa_vol += m->hw_dB_max;
             alsa_vol = PA_CLAMP_UNLIKELY(alsa_vol, m->hw_dB_min, m->hw_dB_max);
 
+            if (m->gain_step)
+                alsa_vol = update_alsa_volume(m, alsa_vol);
+
             if ((err = snd_mixer_selem_set_playback_dB_all(m->mixer_elem, alsa_vol, 1)) < 0)
                 goto fail;
 
@@ -880,6 +943,16 @@ static void sink_set_volume_cb(pa_sink *s) {
         return;
     }
 
+    if (u->active_mixer->slaves) {
+        int i;
+        pa_log("SET SLAVE VOLUMES");
+        for (i = 0; u->active_mixer->slaves[i]; i++) {
+            pa_log("slave %s", u->active_mixer->slaves[i]->name);
+            set_alsa_mixer_volumes(u, u->active_mixer->slaves[i], &s->virtual_volume);
+        }
+    }
+
+    pa_log("control volumes %s", u->active_mixer->name);
     if (set_alsa_mixer_volumes(u, u->active_mixer, &s->virtual_volume)) {
         s->get_volume = NULL;
         s->set_volume = NULL;
@@ -1175,12 +1248,6 @@ static struct mixer_control_t* get_mixer_element(struct userdata *u, const char
         snd_mixer_elem_set_callback(m->mixer_elem, mixer_callback);
         snd_mixer_elem_set_callback_private(m->mixer_elem, u);
 
-        /* cache proplist strings */
-        m->prop_mixer_gain_step_count = pa_sprintf_malloc(PA_ALSA_SINK_PROP_MIXER_GAIN_STEP_COUNT, m->name);
-        replace_chars(m->prop_mixer_gain_step_count, ' ', '_');
-        m->prop_mixer_gain_step = pa_sprintf_malloc(PA_ALSA_SINK_PROP_MIXER_GAIN_STEP, m->name);
-        replace_chars(m->prop_mixer_gain_step, ' ', '_');
-
         pa_log_info("%s: new mixer found: %s", u->device_name, m->name);
     }
 
@@ -1224,16 +1291,23 @@ static int get_mixer_elements(struct userdata *u, const char *mixer_list) {
     return count;
 }
 
+static void clear_gain_steps(struct mixer_control_t *m) {
+    struct gain_step_t *g;
+    pa_log("clear_gain_steps");
+    while ((g = m->gain_step)) {
+        pa_log("free");
+        PA_LLIST_REMOVE(struct gain_step_t, m->gain_step, g);
+        pa_xfree(g);
+    }
+    pa_log("done");
+}
+
 static void free_mixer_element(struct mixer_control_t *m) {
     pa_xfree(m->name);
     pa_alsa_fdlist_free(m->mixer_fdl);
     m->mixer_elem = NULL;
-    if (m->gain_step_count > 0) {
-        if (m->gain_step)
-            pa_xfree(m->gain_step);
-    }
-    pa_xfree(m->prop_mixer_gain_step);
-    pa_xfree(m->prop_mixer_gain_step_count);
+
+    clear_gain_steps(m);
 
     pa_xfree(m);
 }
@@ -1250,54 +1324,131 @@ static void free_mixer_elements(struct userdata *u) {
     }
 }
 
-/* TODO: is this deprecated? */
-static int update_mixer_gain_steps(struct userdata *u,
-                                   struct mixer_control_t *m,
-                                   const char *step_list,
-                                   const unsigned count) {
+static void my_split(const char *src, const char *separator, char **left, char **right) {
     const char *state = NULL;
-    unsigned i = 0;
-    char *num_str;
-    unsigned num;
+    char *str;
 
-    if (count > 0) {
-        if (m->gain_step)
-            pa_xfree(m->gain_step);
-        m->gain_step = pa_xnew0(long, count);
-        m->gain_step_count = count;
-    } else {
-        pa_log_warn("Step count <= 0");
-        return 1;
+    while ((str = pa_split(src, separator, &state))) {
+        if (str) {
+            if (!*left)
+                *left = str;
+            else if (!*right)
+                *right = str;
+            else
+                pa_xfree(str);
+        }
     }
+}
 
-    while ((num_str = pa_split(step_list, ",", &state))) {
-        if (num_str) {
-            if (i >= m->gain_step_count) {
-                pa_xfree(num_str);
-                goto bad_data;
-            }
-            if (pa_atou(num_str, &num) != 0) {
-                pa_xfree(num_str);
-                goto bad_data;
+#define MAX_MIXER_COUNT (16)
+static int mixers_from_str(struct userdata *u, struct mixer_control_t **mixers, const char *list_str) {
+    struct mixer_control_t *m;
+    const char *state = NULL;
+    int mixer_count = 0;
+    char *str;
+
+    while ((str = pa_split(list_str, ",", &state))) {
+        if (str) {
+            m = get_mixer_elem_by_name(u, str);
+            if (m)
+                mixers[mixer_count++] = m;
+            pa_xfree(str);
+        }
+        if (mixer_count == MAX_MIXER_COUNT)
+            break;
+    }
+    mixers[mixer_count] = NULL;
+
+    return mixer_count;
+}
+
+static int levels(struct userdata *u, struct mixer_control_t **mixers, const char *mixer_values) {
+    struct gain_step_t *g;
+    struct gain_step_t *last = NULL;
+    const char *state = NULL;
+    int ret = 0;
+    char *str;
+    int i;
+    int vol;
+
+    pa_log("LEVELS %s", mixer_values);
+
+    for (i = 0; mixers[i]; i++) {
+        if (!last)
+            last = mixers[i]->gain_step;
+        str = pa_split(mixer_values, ",", &state);
+        pa_log("STR: %s", str);
+        g = pa_xnew0(struct gain_step_t, 1);
+        PA_LLIST_INIT(struct gain_step_t, g);
+        g->enabled = FALSE;
+//        PA_LLIST_INSERT_AFTER(struct gain_step_t, mixers[i]->gain_step, last, g);
+//        last = g;
+        PA_LLIST_PREPEND(struct gain_step_t, mixers[i]->gain_step, g);
+
+        if (str) {
+            if (pa_atoi(str, &vol) == 0) {
+                g->enabled = TRUE;
+                g->volume = (pa_volume_t)vol;
+                pa_log("%s set %d: %ld", mixers[i]->name, i, vol);
             }
-            m->gain_step[i] = num;
-            i++;
-            pa_xfree(num_str);
+
+            pa_xfree(str);
         }
     }
 
-    if (i != m->gain_step_count)
-        goto bad_data;
+    return ret;
+}
 
-    pa_log_info("%s: updated gain steps (%u)", u->device_name, count);
-    return 0;
+static int mixer_levels_from_str(struct userdata *u, struct mixer_control_t **mixers, const char *mixer_values) {
+    const char *state = NULL;
+    int ret = 0;
+    char *str;
+    int i;
 
- bad_data:
-    pa_xfree(m->gain_step);
-    m->gain_step = NULL;
-    m->gain_step_count = 0;
-    pa_log_error("bad data for gain steps (\"%s\" count %u)", step_list, count);
-    return 1;
+    pa_log("mixer levels from str %s", mixer_values);
+
+    while ((str = pa_split(mixer_values, "|", &state))) {
+        if (str) {
+            levels(u, mixers, str);
+            pa_xfree(str);
+        }
+    }
+
+    return ret;
+}
+
+static int update_mixer_gain_steps(struct userdata *u, const char *step_list) {
+    struct mixer_control_t **mixers;
+    struct gain_step_t *g;
+    const char *state = NULL;
+    char *str;
+    char *mixer_list = NULL;
+    char *mixer_values = NULL;
+    int mixer_count = 0;
+
+    my_split(step_list, "#", &mixer_list, &mixer_values);
+
+    if (mixer_list && mixer_values) {
+        mixers = pa_xmalloc0(sizeof(struct mixer_control_t*) * (MAX_MIXER_COUNT+1));
+        mixer_count = mixers_from_str(u, mixers, mixer_list);
+
+        if (mixers[0] != NULL) {
+            int i;
+            for (i = 0; mixers[i]; i++) {
+                pa_log("mixer[%d] %s", i, mixers[i]->name);
+
+                clear_gain_steps(mixers[i]);
+            }
+        }
+
+        if (mixer_count > 0) {
+            mixer_levels_from_str(u, mixers, mixer_values);
+        }
+    }
+
+    pa_xfree(mixers);
+
+    return mixer_count;
 }
 
 static void set_vol(pa_cvolume *vol, const int channels, pa_volume_t value) {
@@ -1319,22 +1470,14 @@ static int set_mixer_value(struct userdata *u, const char *value_str) {
     char *value = NULL;
     pa_cvolume vol;
 
-    while ((str = pa_split(value_str, ":", &state))) {
-        if (str) {
-            if (!mixer)
-                mixer = str;
-            else if (!value)
-                value = str;
-            else
-                pa_xfree(str);
-        }
-    }
+    my_split(value_str, ":", &mixer, &value);
 
     if (mixer && value) {
 
         if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_OFF) == 0) {
             m = get_mixer_elem_by_name(u, mixer);
             if (m) {
+                m->slave = FALSE;
                 pa_log_info("%s: set mixer %s off", u->device_name, mixer);
                 if (m->hw_dB_supported)
                     set_vol(&vol, u->sink->channel_map.channels, pa_sw_volume_from_dB(m->hw_dB_min));
@@ -1345,6 +1488,7 @@ static int set_mixer_value(struct userdata *u, const char *value_str) {
         } else if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_MAX) == 0) {
             m = get_mixer_elem_by_name(u, mixer);
             if (m) {
+                m->slave = FALSE;
                 pa_log_info("%s: set mixer %s max", u->device_name, mixer);
                 if (m->hw_dB_supported)
                     set_vol(&vol, u->sink->channel_map.channels, pa_sw_volume_from_dB(- m->hw_dB_max/100.0));
@@ -1365,6 +1509,14 @@ static int set_mixer_value(struct userdata *u, const char *value_str) {
                     }
                 }
             }
+            if (ret == 0)
+                u->active_mixer->slave = FALSE;
+        } else if (strcmp(value, PA_ALSA_SINK_PROP_MIXER_SLAVE) == 0) {
+            m = get_mixer_elem_by_name(u, mixer);
+            if (m) {
+                pa_log("%s: set mixer %s slave", u->device_name, mixer);
+                m->slave = TRUE;
+            }
 
         } else {
             pa_log_error("%s: bad mixer setup pair (%s)", u->device_name, value_str);
@@ -1384,6 +1536,39 @@ static int set_mixer_value(struct userdata *u, const char *value_str) {
     return ret;
 }
 
+static int update_slave_list(struct userdata *u) {
+    struct mixer_control_t *m;
+    int count = 0;
+
+    if (!u->active_mixer) {
+        /* don't update slave list, since no control mixer */
+        return 0;
+    }
+
+    for (m = u->mixer_list; m; m = m->next) {
+        if (m->slaves)
+            pa_xfree(m->slaves);
+        if (m->slave)
+            count++;
+    }
+
+    if (count > 0) {
+        int i = 0;
+        u->active_mixer->slaves = pa_xmalloc0(sizeof(struct mixer_control_t*) * (count+1));
+
+        for (m = u->mixer_list; m; m = m->next) {
+            if (i == count)
+                break;
+            if (m->slave)
+                u->active_mixer->slaves[i++] = m;
+        }
+
+        u->active_mixer->slaves[i] = NULL;
+    }
+
+    return 0;
+}
+
 /** Parse mixer control list.
  *
  * Parses comma separated list of MIXER:STATE pairs.
@@ -1408,6 +1593,8 @@ static int update_mixer_setup(struct userdata *u, const char *value_list) {
         }
     }
 
+    update_slave_list(u);
+
     /* update previously stored volumes to sink */
     if (u->active_mixer) {
         pa_log_info("%s: update stored volumes to sink", u->device_name);
@@ -1430,7 +1617,6 @@ static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink
     const char *step_list = NULL;
     pa_bool_t muted = FALSE;
     const pa_cvolume *vol = NULL;
-    pa_bool_t update_volumes = FALSE;
 
     if (s != u->sink) {
         return PA_HOOK_OK;
@@ -1450,40 +1636,16 @@ static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink
             switch_buffers(u, SINK_SWITCH_ALTERNATIVE);
         }
     }
+    v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_MIXER_GAIN);
+    if (v) {
+        update_mixer_gain_steps(u, v);
+    }
 
     v = pa_proplist_gets(s->proplist, PA_ALSA_SINK_PROP_MIXER);
     if (v) {
         update_mixer_setup(u, v);
     }
 
-    /* TODO: is this deprecated? */
-    if (u->active_mixer) {
-        v = pa_proplist_gets(s->proplist, u->active_mixer->prop_mixer_gain_step_count);
-        if (v) {
-            if (pa_atou(v, &count)) {
-                pa_log_error("couldn't get gain count");
-            } else {
-                step_list = pa_proplist_gets(s->proplist, u->active_mixer->prop_mixer_gain_step);
-                if (step_list) {
-                    if (update_mixer_gain_steps(u, u->active_mixer, step_list, count)) {
-                        /* couldn't get steps, unset bad property values */
-                        pa_proplist_unset(s->proplist, u->active_mixer->prop_mixer_gain_step_count);
-                        pa_proplist_unset(s->proplist, u->active_mixer->prop_mixer_gain_step);
-                    }
-                    if (!vol) {
-                        vol = pa_sink_get_volume(u->sink, TRUE);
-                        muted = pa_sink_get_mute(u->sink, TRUE);
-                    }
-                    update_volumes = TRUE;
-                }
-            }
-        }
-    }
-
-    if (update_volumes) {
-        pa_sink_set_volume(u->sink, vol, TRUE, TRUE);
-        pa_sink_set_mute(u->sink, muted);
-    }
 
     return PA_HOOK_OK;
 }
diff --git a/src/modules/alsa/module-alsa-sink-old.h b/src/modules/alsa/module-alsa-sink-old.h
index 57fd7d1..ce4f030 100644
--- a/src/modules/alsa/module-alsa-sink-old.h
+++ b/src/modules/alsa/module-alsa-sink-old.h
@@ -13,11 +13,16 @@
 #define PA_ALSA_SINK_PROP_MIXER_OFF     "off"
 #define PA_ALSA_SINK_PROP_MIXER_MAX     "max"
 #define PA_ALSA_SINK_PROP_MIXER_CONTROL "control"
+#define PA_ALSA_SINK_PROP_MIXER_SLAVE   "slave"
 
-/* String of comma separated numbers defining alsa volumes */
-#define PA_ALSA_SINK_PROP_MIXER_GAIN_STEP "x-maemo.alsa_sink.mixer.%s.gain_step"
-/* String containing gain step count number */
-#define PA_ALSA_SINK_PROP_MIXER_GAIN_STEP_COUNT "x-maemo.alsa_sink.mixer.%s.gain_step_count"
+/* String of comma separated numbers defining alsa volumes
+ *
+ * MIXER LIST|GAIN STEPS
+ * eg. without dB "HP DAC,Earphone#0,0|50,30|60,40"
+ * with dB "HP DAC,Earphone#-500,-400|-300,-200|-100,0"
+ *
+ */
+#define PA_ALSA_SINK_PROP_MIXER_GAIN "x-maemo.alsa_sink.mixer_gain"
 
 #define PA_ALSA_SINK_PROP_BUFFERS "x-maemo.alsa_sink.buffers"  /* Buffer mode, primary/alternative */
 #define PA_ALSA_SINK_PROP_BUFFERS_PRIMARY     "primary"
-- 
1.6.2.rc1.13.gfd76c.dirty

