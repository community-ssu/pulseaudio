From 083bff5818ddcfecbd07f09eee73a61f451d8ac1 Mon Sep 17 00:00:00 2001
From: Juho Hamalainen <jusa@IT-W1767.(none)>
Date: Thu, 4 Jun 2009 13:24:31 +0300
Subject: [PATCH 61/64] alsa-old: start as suspended

---
 src/modules/alsa/module-alsa-sink-old.c   |  220 ++++++++++------
 src/modules/alsa/module-alsa-source-old.c |  417 +++++++++++++++++------------
 2 files changed, 386 insertions(+), 251 deletions(-)

diff --git a/src/modules/alsa/module-alsa-sink-old.c b/src/modules/alsa/module-alsa-sink-old.c
index f6dc0f4..6a5c863 100644
--- a/src/modules/alsa/module-alsa-sink-old.c
+++ b/src/modules/alsa/module-alsa-sink-old.c
@@ -119,6 +119,9 @@ struct userdata {
     pa_bool_t use_mmap;
 
     pa_bool_t first;
+    pa_bool_t initialized;
+    char *init_device_id;
+    char *init_device_string;
 
     pa_rtpoll_item *alsa_rtpoll_item;
 };
@@ -441,7 +444,16 @@ static int build_pollfd(struct userdata *u) {
 
 static int suspend(struct userdata *u) {
     pa_assert(u);
-    pa_assert(u->pcm_handle);
+    //pa_assert(u->pcm_handle);
+
+    if (!u->pcm_handle) {
+        pa_log_debug("no pcm handle, alsa device is not initialized yet");
+        if (u->alsa_rtpoll_item) {
+            pa_rtpoll_item_free(u->alsa_rtpoll_item);
+            u->alsa_rtpoll_item = NULL;
+        }
+        return 0;
+    }
 
     /* Let's suspend */
     if (!pa_streq(u->device_name, "sink.hw1")) /* FIXME: maemo hw1 has issues draining, it takes too long */
@@ -459,6 +471,8 @@ static int suspend(struct userdata *u) {
     return 0;
 }
 
+static int initialize_sink(struct userdata *u);
+
 static int unsuspend(struct userdata *u) {
     pa_sample_spec ss;
     int err;
@@ -470,6 +484,11 @@ static int unsuspend(struct userdata *u) {
 
     pa_log_info("Trying resume...");
 
+    if (!u->initialized) {
+        pa_log_debug("unsuspend for the first time -> init alsa");
+        return initialize_sink(u);
+    }
+
     snd_config_update_free_global();
     if ((err = snd_pcm_open(&u->pcm_handle, u->device_name, SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK)) < 0) {
         pa_log("Error opening PCM device %s: %s", u->device_name, snd_strerror(err));
@@ -514,6 +533,7 @@ static int unsuspend(struct userdata *u) {
     u->first = TRUE;
 
     pa_log_info("Resumed successfully...");
+    u->initialized = TRUE;
 
     return 0;
 
@@ -558,7 +578,7 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
                 case PA_SINK_RUNNING:
 
                     if (u->sink->thread_info.state == PA_SINK_INIT) {
-                        if (build_pollfd(u) < 0)
+                        if (u->initialized && build_pollfd(u) < 0)
                             return -1;
                     }
 
@@ -608,7 +628,7 @@ static void thread_func(void *userdata) {
         int ret;
 
         /* Render some data and write it to the dsp */
-        if (PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
+        if (u->initialized && PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
             int work_done = 0;
 
             if (u->sink->thread_info.rewind_requested)
@@ -638,7 +658,7 @@ static void thread_func(void *userdata) {
             goto finish;
 
         /* Tell ALSA about this and process its response */
-        if (PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
+        if (u->initialized && PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
             struct pollfd *pollfd;
             unsigned short revents = 0;
             int err;
@@ -727,11 +747,116 @@ static pa_hook_result_t sink_proplist_changed_hook_callback(pa_core *c, pa_sink
     return PA_HOOK_OK;
 }
 
+static int initialize_sink(struct userdata *u) {
+
+    int err;
+    char *t;
+    snd_pcm_info_t *pcm_info = NULL;
+    pa_bool_t use_mmap, b, d;
+    pa_sample_spec ss;
+    uint32_t nfrags, period_size;
+    const pa_alsa_profile_info *profile;
+
+    d = FALSE; /* use_tsched */
+    use_mmap = u->use_mmap;
+    nfrags = u->nfragments;
+    period_size = u->period_size;
+    ss = u->sink->sample_spec;
+    profile = NULL; /* no profile specified */
+
+    snd_pcm_info_alloca(&pcm_info);
+    snd_config_update_free_global();
+
+    if (u->device_name) {
+        pa_xfree(u->device_name);
+        u->device_name = NULL;
+    }
+
+    if (u->init_device_id) {
+
+        if (!(u->pcm_handle = pa_alsa_open_by_device_id_auto(
+                      (const char*)u->init_device_id,
+                      &u->device_name,
+                      &ss, &u->channel_map,
+                      SND_PCM_STREAM_PLAYBACK,
+                      &nfrags, &period_size, period_size * nfrags,
+                      &b, &d, &profile)))
+
+            goto fail;
+
+    } else {
+
+        if (!(u->pcm_handle = pa_alsa_open_by_device_string(
+                      (const char*)u->init_device_string,
+                      &u->device_name,
+                      &ss, &u->channel_map,
+                      SND_PCM_STREAM_PLAYBACK,
+                      &nfrags, &period_size, period_size * nfrags,
+                      &b, &d, FALSE)))
+            goto fail;
+
+    }
+
+    u->sink->sample_spec = ss;
+
+    /* ALSA might tweak the sample spec, so recalculate the frame size */
+    u->frame_size = pa_frame_size(&ss);
+    u->alt_frame_size = pa_frame_size(&ss);
+
+    pa_assert(u->device_name);
+    pa_log_info("Successfully opened device %s.", u->device_name);
+
+    if (use_mmap && !b) {
+        pa_log_info("Device doesn't support mmap(), falling back to UNIX read/write mode.");
+        u->use_mmap = use_mmap = b;
+    }
+
+    if (u->use_mmap)
+        pa_log_info("Successfully enabled mmap() mode.");
+
+    if ((err = snd_pcm_info(u->pcm_handle, pcm_info)) < 0) {
+        pa_log("Error fetching PCM info: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    if ((err = pa_alsa_set_sw_params(u->pcm_handle, period_size)) < 0) {
+        pa_log("Failed to set software parameters: %s", snd_strerror(err));
+        goto fail;
+    }
+
+    pa_sink_set_description(u->sink, t = pa_sprintf_malloc(
+                                    "ALSA PCM on %s (%s)%s",
+                                    u->device_name,
+                                    snd_pcm_info_get_name(pcm_info),
+                                    use_mmap ? " via DMA" : ""));
+    pa_xfree(t);
+
+    pa_alsa_init_proplist_pcm(u->core, u->sink->proplist, u->pcm_handle, NULL);
+    pa_proplist_sets(u->sink->proplist, PA_PROP_DEVICE_STRING, u->device_name);
+    pa_proplist_setf(u->sink->proplist, PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE, "%lu", (unsigned long) (u->period_size * u->frame_size * nfrags));
+    pa_proplist_setf(u->sink->proplist, PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE, "%lu", (unsigned long) (u->period_size * u->frame_size));
+    pa_proplist_sets(u->sink->proplist, PA_PROP_DEVICE_ACCESS_MODE, (u->use_mmap ? "mmap" : "serial"));
+
+    if (build_pollfd(u) < 0)
+        goto fail;
+
+    /* FIXME: We need to reload the volume somehow */
+
+    u->first = TRUE;
+
+    u->initialized = TRUE;
+    pa_log_info("%s initialized for the FIRST time", u->device_name);
+
+    return 0;
+
+fail:
+    return -1;
+}
+
 int pa__init(pa_module*m) {
 
     pa_modargs *ma = NULL;
     struct userdata *u = NULL;
-    const char *dev_id;
     pa_sample_spec ss;
     pa_channel_map map;
     uint32_t nfrags, frag_size;
@@ -740,17 +865,11 @@ int pa__init(pa_module*m) {
     snd_pcm_uframes_t alt_period_size;
     size_t frame_size;
     size_t alt_frame_size;
-    snd_pcm_info_t *pcm_info = NULL;
-    int err;
-    char *t;
     const char *name;
     char *name_buf = NULL;
     int namereg_fail;
-    pa_bool_t use_mmap = TRUE, b, d;
+    pa_bool_t use_mmap = TRUE;
     pa_sink_new_data data;
-    const pa_alsa_profile_info *profile;
-
-    snd_pcm_info_alloca(&pcm_info);
 
     pa_assert(m);
 
@@ -813,62 +932,17 @@ int pa__init(pa_module*m) {
     u->rtpoll = pa_rtpoll_new();
     pa_thread_mq_init(&u->thread_mq, m->core->mainloop, u->rtpoll);
     u->alsa_rtpoll_item = NULL;
+    u->initialized = FALSE;
 
     snd_config_update_free_global();
 
-    b = use_mmap;
-    d = FALSE; /* use_tsched */
-    profile = NULL; /* no profile specified */
-
-    if ((dev_id = pa_modargs_get_value(ma, "device_id", NULL))) {
-
-        if (!(u->pcm_handle = pa_alsa_open_by_device_id_auto(
-                      dev_id,
-                      &u->device_name,
-                      &ss, &map,
-                      SND_PCM_STREAM_PLAYBACK,
-                      &nfrags, &period_size, period_size * nfrags,
-                      &b, &d, &profile)))
-
-            goto fail;
-
-    } else {
-
-        if (!(u->pcm_handle = pa_alsa_open_by_device_string(
-                      pa_modargs_get_value(ma, "device", DEFAULT_DEVICE),
-                      &u->device_name,
-                      &ss, &map,
-                      SND_PCM_STREAM_PLAYBACK,
-                      &nfrags, &period_size, period_size * nfrags,
-                      &b, &d, FALSE)))
-            goto fail;
-
-    }
+    /* save device_id & string for later initialization */
+    if (pa_modargs_get_value(ma, "device_id", NULL))
+        u->init_device_id = pa_xstrdup(pa_modargs_get_value(ma, "device_id", NULL));
+    u->init_device_string = pa_xstrdup(pa_modargs_get_value(ma, "device", DEFAULT_DEVICE));
 
-    pa_assert(u->device_name);
-    pa_log_info("Successfully opened device %s.", u->device_name);
-
-    if (use_mmap && !b) {
-        pa_log_info("Device doesn't support mmap(), falling back to UNIX read/write mode.");
-        u->use_mmap = use_mmap = b;
-    }
-
-    if (u->use_mmap)
-        pa_log_info("Successfully enabled mmap() mode.");
-
-    if ((err = snd_pcm_info(u->pcm_handle, pcm_info)) < 0) {
-        pa_log("Error fetching PCM info: %s", snd_strerror(err));
-        goto fail;
-    }
-
-    if ((err = pa_alsa_set_sw_params(u->pcm_handle, period_size)) < 0) {
-        pa_log("Failed to set software parameters: %s", snd_strerror(err));
-        goto fail;
-    }
-
-    /* ALSA might tweak the sample spec, so recalculate the frame size */
-    frame_size = pa_frame_size(&ss);
-    alt_frame_size = pa_frame_size(&ss);
+    /* device not initialized yet, but save something to device_name */
+    u->device_name = pa_sprintf_malloc("(uninitialized)");
 
     if ((name = pa_modargs_get_value(ma, "sink_name", NULL)))
         namereg_fail = 1;
@@ -885,12 +959,6 @@ int pa__init(pa_module*m) {
     pa_sink_new_data_set_sample_spec(&data, &ss);
     pa_sink_new_data_set_channel_map(&data, &map);
 
-    pa_alsa_init_proplist_pcm(m->core, data.proplist, u->pcm_handle, NULL);
-    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_STRING, u->device_name);
-    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE, "%lu", (unsigned long) (period_size * frame_size * nfrags));
-    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE, "%lu", (unsigned long) (period_size * frame_size));
-    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_ACCESS_MODE, (u->use_mmap ? "mmap" : "serial"));
-
     u->sink = pa_sink_new(m->core, &data, PA_SINK_HARDWARE|PA_SINK_LATENCY);
     pa_sink_new_data_done(&data);
     pa_xfree(name_buf);
@@ -906,12 +974,6 @@ int pa__init(pa_module*m) {
 
     pa_sink_set_asyncmsgq(u->sink, u->thread_mq.inq);
     pa_sink_set_rtpoll(u->sink, u->rtpoll);
-    pa_sink_set_description(u->sink, t = pa_sprintf_malloc(
-                                    "ALSA PCM on %s (%s)%s",
-                                    u->device_name,
-                                    snd_pcm_info_get_name(pcm_info),
-                                    use_mmap ? " via DMA" : ""));
-    pa_xfree(t);
 
     u->frame_size = frame_size;
     u->fragment_size = frag_size = period_size * frame_size;
@@ -953,6 +1015,7 @@ int pa__init(pa_module*m) {
                                                         (pa_hook_cb_t)sink_proplist_changed_hook_callback, u);
 
     pa_sink_put(u->sink);
+    pa_sink_suspend(u->sink, TRUE); /* start suspended */
 
     pa_modargs_free(ma);
 
@@ -1006,6 +1069,11 @@ void pa__done(pa_module*m) {
         snd_pcm_close(u->pcm_handle);
     }
 
+    if (u->init_device_id)
+        pa_xfree(u->init_device_id);
+    if (u->init_device_string)
+        pa_xfree(u->init_device_string);
+
     pa_xfree(u->device_name);
     pa_xfree(u);
 
diff --git a/src/modules/alsa/module-alsa-source-old.c b/src/modules/alsa/module-alsa-source-old.c
index 4b229d7..e5e3958 100644
--- a/src/modules/alsa/module-alsa-source-old.c
+++ b/src/modules/alsa/module-alsa-source-old.c
@@ -129,6 +129,11 @@ struct userdata {
     pa_rtpoll_item *alsa_rtpoll_item;
 
     snd_mixer_selem_channel_id_t mixer_map[SND_MIXER_SCHN_LAST];
+
+    pa_bool_t initialized;
+    char *init_device_id;
+    char *init_device_string;
+    char *init_alsa_mixer;
 };
 
 static const char* const valid_modargs[] = {
@@ -440,8 +445,16 @@ static int build_pollfd(struct userdata *u) {
 
 static int suspend(struct userdata *u) {
     pa_assert(u);
-    pa_assert(u->pcm_handle);
+    //pa_assert(u->pcm_handle);
 
+    if (!u->pcm_handle) {
+        pa_log_debug("no pcm handle, alsa device is not initialized yet");
+        if (u->alsa_rtpoll_item) {
+            pa_rtpoll_item_free(u->alsa_rtpoll_item);
+            u->alsa_rtpoll_item = NULL;
+        }
+        return 0;
+    }
     /* Let's suspend */
     snd_pcm_close(u->pcm_handle);
     u->pcm_handle = NULL;
@@ -456,6 +469,8 @@ static int suspend(struct userdata *u) {
     return 0;
 }
 
+static int initialize_source(struct userdata *u);
+
 static int unsuspend(struct userdata *u) {
     pa_sample_spec ss;
     int err;
@@ -466,6 +481,11 @@ static int unsuspend(struct userdata *u) {
     pa_assert(u);
     pa_assert(!u->pcm_handle);
 
+    if (!u->initialized) {
+        pa_log_debug("unsuspend for the first time -> init alsa");
+        return initialize_source(u);
+    }
+
     pa_log_info("Trying resume...");
 
     snd_config_update_free_global();
@@ -557,10 +577,11 @@ static int source_process_msg(pa_msgobject *o, int code, void *data, int64_t off
                 case PA_SOURCE_RUNNING:
 
                     if (u->source->thread_info.state == PA_SOURCE_INIT) {
-                        if (build_pollfd(u) < 0)
+                        if (u->initialized && build_pollfd(u) < 0)
                             return -1;
 
-                        snd_pcm_start(u->pcm_handle);
+                        if (u->initialized)
+                            snd_pcm_start(u->pcm_handle);
                     }
 
                     if (u->source->thread_info.state == PA_SOURCE_SUSPENDED) {
@@ -856,7 +877,7 @@ static void thread_func(void *userdata) {
         int ret;
 
         /* Read some data and pass it to the sources */
-        if (PA_SOURCE_IS_OPENED(u->source->thread_info.state)) {
+        if (u->initialized && PA_SOURCE_IS_OPENED(u->source->thread_info.state)) {
 
             if (u->use_mmap) {
                 if (mmap_read(u) < 0)
@@ -876,7 +897,7 @@ static void thread_func(void *userdata) {
             goto finish;
 
         /* Tell ALSA about this and process its response */
-        if (PA_SOURCE_IS_OPENED(u->source->thread_info.state)) {
+        if (u->initialized && PA_SOURCE_IS_OPENED(u->source->thread_info.state)) {
             struct pollfd *pollfd;
             unsigned short revents = 0;
             int err;
@@ -959,133 +980,51 @@ static pa_hook_result_t source_proplist_changed_hook_callback(pa_core *c, pa_sou
     return PA_HOOK_OK;
 }
 
-int pa__init(pa_module*m) {
-
-    pa_modargs *ma = NULL;
-    struct userdata *u = NULL;
-    const char *dev_id;
+static int initialize_source(struct userdata *u) {
     pa_sample_spec ss;
-    pa_channel_map map;
-    char *alsa_mixer = NULL;
-    unsigned ii;
-    uint32_t nfrags, frag_size;
-    uint32_t alt_nfrags, alt_frag_size;
-    snd_pcm_uframes_t period_size;
-    snd_pcm_uframes_t alt_period_size;
-    size_t frame_size;
-    size_t alt_frame_size;
+    uint32_t nfrags;
     snd_pcm_info_t *pcm_info = NULL;
     int err;
     char *t;
-    const char *name;
-    char *name_buf = NULL;
-    int namereg_fail;
     pa_bool_t use_mmap = TRUE, b, d, ignore_dB = FALSE;
-    pa_source_new_data data;
     const pa_alsa_profile_info *profile;
 
-    snd_pcm_info_alloca(&pcm_info);
-
-    pa_assert(m);
-
-    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
-        pa_log("Failed to parse module arguments");
-        goto fail;
-    }
-
-    ss = m->core->default_sample_spec;
-    if (pa_modargs_get_sample_spec_and_channel_map(ma, &ss, &map, PA_CHANNEL_MAP_ALSA) < 0) {
-        pa_log("Failed to parse sample specification");
-        goto fail;
-    }
-
-    alsa_mixer = pa_xstrdup(pa_modargs_get_value(ma, "mixer", "Capture"));
-    ii = 0;
-    while(alsa_mixer[ii++] != '\0') {
-        if (alsa_mixer[ii] == '_')
-            alsa_mixer[ii] = ' ';
-    }
-
-    frame_size = pa_frame_size(&ss);
-
-    nfrags = m->core->default_n_fragments;
-    frag_size = pa_usec_to_bytes(m->core->default_fragment_size_msec*1000, &ss);
-    if (frag_size <= 0)
-        frag_size = frame_size;
-
-    if (pa_modargs_get_value_u32(ma, "fragments", &nfrags) < 0 || pa_modargs_get_value_u32(ma, "fragment_size", &frag_size) < 0) {
-        pa_log("Failed to parse buffer metrics");
-        goto fail;
-    }
-    period_size = frag_size/frame_size;
-
-    alt_frame_size = pa_frame_size(&ss);
-
-    /* 0 is default value from pa_modargs_get */
-    alt_period_size = 0;
-    alt_nfrags = 0;
-    alt_frag_size = alt_frame_size;
-
-    if (alt_frag_size <= 0)
-        alt_frag_size = alt_frame_size;
-
-    if (pa_modargs_get_value_u32(ma, "alt_fragments", &alt_nfrags) < 0 || pa_modargs_get_value_u32(ma, "alt_fragment_size", &alt_frag_size) < 0) {
-        pa_log("Failed to parse buffer metrics");
-        goto fail;
-    }
-
-    if (alt_nfrags != 0)
-        alt_period_size = alt_frag_size/alt_frame_size;
-
-    if (pa_modargs_get_value_boolean(ma, "mmap", &use_mmap) < 0) {
-        pa_log("Failed to parse mmap argument.");
-        goto fail;
-    }
-
-    if (pa_modargs_get_value_boolean(ma, "ignore_dB", &ignore_dB) < 0) {
-        pa_log("Failed to parse ignore_dB argument.");
-        goto fail;
-    }
+    use_mmap = u->use_mmap;
+    nfrags = u->nfragments;
 
-    u = pa_xnew0(struct userdata, 1);
-    u->switch_mode = SOURCE_SWITCH_PRIMARY;
-    if (alt_nfrags != 0)
-        u->switching_enabled = TRUE;
-    else
-        u->switching_enabled = FALSE;
-    u->core = m->core;
-    u->module = m;
-    m->userdata = u;
-    u->use_mmap = use_mmap;
-    u->rtpoll = pa_rtpoll_new();
-    pa_thread_mq_init(&u->thread_mq, m->core->mainloop, u->rtpoll);
-    u->alsa_rtpoll_item = NULL;
+    ss = u->source->sample_spec;
 
+    snd_pcm_info_alloca(&pcm_info);
     snd_config_update_free_global();
 
     b = use_mmap;
     d = FALSE; /* use_tsched */
     profile = NULL; /* no profile specified */
 
-    if ((dev_id = pa_modargs_get_value(ma, "device_id", NULL))) {
+    if (u->device_name) {
+        pa_xfree(u->device_name);
+        u->device_name = NULL;
+    }
+
+    if (u->init_device_id) {
 
         if (!(u->pcm_handle = pa_alsa_open_by_device_id_auto(
-                      dev_id,
+                      (const char*)u->init_device_id,
                       &u->device_name,
-                      &ss, &map,
+                      &ss, &u->source->channel_map,
                       SND_PCM_STREAM_CAPTURE,
-                      &nfrags, &period_size, period_size * nfrags,
+                      &nfrags, &u->period_size, u->period_size * nfrags,
                       &b, &d, &profile)))
             goto fail;
 
     } else {
 
         if (!(u->pcm_handle = pa_alsa_open_by_device_string(
-                      pa_modargs_get_value(ma, "device", DEFAULT_DEVICE),
+                      u->init_device_string,
                       &u->device_name,
-                      &ss, &map,
+                      &ss, &u->source->channel_map,
                       SND_PCM_STREAM_CAPTURE,
-                      &nfrags, &period_size, period_size * nfrags,
+                      &nfrags, &u->period_size, u->period_size * nfrags,
                       &b, &d, FALSE)))
             goto fail;
     }
@@ -1106,13 +1045,14 @@ int pa__init(pa_module*m) {
         goto fail;
     }
 
-    if ((err = pa_alsa_set_sw_params(u->pcm_handle, period_size)) < 0) {
+    if ((err = pa_alsa_set_sw_params(u->pcm_handle, u->period_size)) < 0) {
         pa_log("Failed to set software parameters: %s", snd_strerror(err));
         goto fail;
     }
 
     /* ALSA might tweak the sample spec, so recalculate the frame size */
-    frame_size = pa_frame_size(&ss);
+    u->frame_size = pa_frame_size(&ss);
+    u->alt_frame_size = pa_frame_size(&ss);
 
     if ((err = snd_mixer_open(&u->mixer_handle, 0)) < 0)
         pa_log("Error opening mixer: %s", snd_strerror(err));
@@ -1122,7 +1062,7 @@ int pa__init(pa_module*m) {
         if (pa_alsa_prepare_mixer(u->mixer_handle, u->device_name) >= 0)
             found = TRUE;
         else {
-            char *md = pa_sprintf_malloc("hw:%s", dev_id);
+            char *md = pa_sprintf_malloc("hw:%s", u->init_device_id);
 
             if (strcmp(u->device_name, md))
                 if (pa_alsa_prepare_mixer(u->mixer_handle, md) >= 0)
@@ -1132,7 +1072,7 @@ int pa__init(pa_module*m) {
         }
 
         if (found)
-            if (!(u->mixer_elem = pa_alsa_find_elem(u->mixer_handle, alsa_mixer, "Mic", FALSE)))
+            if (!(u->mixer_elem = pa_alsa_find_elem(u->mixer_handle, u->init_alsa_mixer, "Mic", FALSE)))
                 found = FALSE;
 
         if (!found) {
@@ -1141,41 +1081,12 @@ int pa__init(pa_module*m) {
         }
     }
 
-    if ((name = pa_modargs_get_value(ma, "source_name", NULL)))
-        namereg_fail = 1;
-    else {
-        name = name_buf = pa_sprintf_malloc("alsa_input.%s", u->device_name);
-        namereg_fail = 0;
-    }
-
-    pa_source_new_data_init(&data);
-    data.driver = __FILE__;
-    data.module = m;
-    pa_source_new_data_set_name(&data, name);
-    data.namereg_fail = namereg_fail;
-    pa_source_new_data_set_sample_spec(&data, &ss);
-    pa_source_new_data_set_channel_map(&data, &map);
-
-    pa_alsa_init_proplist_pcm(m->core, data.proplist, u->pcm_handle, NULL);
-    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_STRING, u->device_name);
-    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE, "%lu", (unsigned long) (period_size * frame_size * nfrags));
-    pa_proplist_setf(data.proplist, PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE, "%lu", (unsigned long) (period_size * frame_size));
-    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_ACCESS_MODE, (u->use_mmap ? "mmap" : "serial"));
-
-    u->source = pa_source_new(m->core, &data, PA_SOURCE_HARDWARE|PA_SOURCE_LATENCY);
-    pa_source_new_data_done(&data);
-    pa_xfree(name_buf);
+    pa_alsa_init_proplist_pcm(u->core, u->source->proplist, u->pcm_handle, NULL);
+    pa_proplist_sets(u->source->proplist, PA_PROP_DEVICE_STRING, u->device_name);
+    pa_proplist_setf(u->source->proplist, PA_PROP_DEVICE_BUFFERING_BUFFER_SIZE, "%lu", (unsigned long) (u->period_size * u->frame_size * u->nfragments));
+    pa_proplist_setf(u->source->proplist, PA_PROP_DEVICE_BUFFERING_FRAGMENT_SIZE, "%lu", (unsigned long) (u->period_size * u->frame_size));
+    pa_proplist_sets(u->source->proplist, PA_PROP_DEVICE_ACCESS_MODE, (u->use_mmap ? "mmap" : "serial"));
 
-    if (!u->source) {
-        pa_log("Failed to create source object");
-        goto fail;
-    }
-
-    u->source->parent.process_msg = source_process_msg;
-    u->source->userdata = u;
-
-    pa_source_set_asyncmsgq(u->source, u->thread_mq.inq);
-    pa_source_set_rtpoll(u->source, u->rtpoll);
     pa_source_set_description(u->source, t = pa_sprintf_malloc(
                                       "ALSA PCM on %s (%s)%s",
                                       u->device_name,
@@ -1183,32 +1094,6 @@ int pa__init(pa_module*m) {
                                       use_mmap ? " via DMA" : ""));
     pa_xfree(t);
 
-    u->source->flags = PA_SOURCE_HARDWARE|PA_SOURCE_LATENCY;
-
-    u->frame_size = frame_size;
-    u->fragment_size = frag_size = period_size * frame_size;
-    u->nfragments = nfrags;
-    u->hwbuf_size = u->fragment_size * nfrags;
-    u->period_size = period_size;
-
-    if (u->switching_enabled) {
-        u->pri_frame_size = frame_size;
-        u->pri_fragment_size = frag_size = period_size * frame_size;
-        u->pri_nfragments = nfrags;
-        u->pri_hwbuf_size = u->fragment_size * nfrags;
-        u->pri_period_size = period_size;
-
-        u->alt_frame_size = alt_frame_size;
-        u->alt_fragment_size = alt_frag_size = alt_period_size * alt_frame_size;
-        u->alt_nfragments = alt_nfrags;
-        u->alt_hwbuf_size = u->alt_fragment_size * alt_nfrags;
-        u->alt_period_size = alt_period_size;
-    }
-
-    pa_log_info("PRI: Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->pri_fragment_size);
-    if (u->switching_enabled)
-        pa_log_info("ALT: Using %u fragments of size %lu bytes.", alt_nfrags, (long unsigned) u->alt_fragment_size);
-
     if (u->mixer_handle) {
         pa_assert(u->mixer_elem);
 
@@ -1257,7 +1142,7 @@ int pa__init(pa_module*m) {
             }
 
             if (suitable) {
-                u->mixer_seperate_channels = pa_alsa_calc_mixer_map(u->mixer_elem, &map, u->mixer_map, FALSE) >= 0;
+                u->mixer_seperate_channels = pa_alsa_calc_mixer_map(u->mixer_elem, &u->source->channel_map, u->mixer_map, FALSE) >= 0;
 
                 u->source->get_volume = source_get_volume_cb;
                 u->source->set_volume = source_set_volume_cb;
@@ -1279,7 +1164,7 @@ int pa__init(pa_module*m) {
 
         u->mixer_fdl = pa_alsa_fdlist_new();
 
-        if (pa_alsa_fdlist_set_mixer(u->mixer_fdl, u->mixer_handle, m->core->mainloop) < 0) {
+        if (pa_alsa_fdlist_set_mixer(u->mixer_fdl, u->mixer_handle, u->core->mainloop) < 0) {
             pa_log("Failed to initialize file descriptor monitoring");
             goto fail;
         }
@@ -1289,11 +1174,8 @@ int pa__init(pa_module*m) {
     } else
         u->mixer_fdl = NULL;
 
-    if (!(u->thread = pa_thread_new(thread_func, u))) {
-        pa_log("Failed to create thread.");
-        goto fail;
-    }
     /* Get initial mixer settings */
+#if 0
     if (data.volume_is_set) {
         if (u->source->set_volume)
             u->source->set_volume(u->source);
@@ -1309,6 +1191,182 @@ int pa__init(pa_module*m) {
         if (u->source->get_mute)
             u->source->get_mute(u->source);
     }
+#endif
+
+    u->initialized = TRUE;
+    if (build_pollfd(u) < 0)
+        goto fail;
+
+    return 0;
+
+fail:
+    return -1;
+}
+
+int pa__init(pa_module*m) {
+
+    pa_modargs *ma = NULL;
+    struct userdata *u = NULL;
+    pa_sample_spec ss;
+    pa_channel_map map;
+    char *alsa_mixer = NULL;
+    unsigned ii;
+    uint32_t nfrags, frag_size;
+    uint32_t alt_nfrags, alt_frag_size;
+    snd_pcm_uframes_t period_size;
+    snd_pcm_uframes_t alt_period_size;
+    size_t frame_size;
+    size_t alt_frame_size;
+    const char *name;
+    char *name_buf = NULL;
+    int namereg_fail;
+    pa_bool_t use_mmap = TRUE, ignore_dB = FALSE;
+    pa_source_new_data data;
+
+    pa_assert(m);
+
+    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
+        pa_log("Failed to parse module arguments");
+        goto fail;
+    }
+
+    ss = m->core->default_sample_spec;
+    if (pa_modargs_get_sample_spec_and_channel_map(ma, &ss, &map, PA_CHANNEL_MAP_ALSA) < 0) {
+        pa_log("Failed to parse sample specification");
+        goto fail;
+    }
+
+    alsa_mixer = pa_xstrdup(pa_modargs_get_value(ma, "mixer", "Capture"));
+    ii = 0;
+    while(alsa_mixer[ii++] != '\0') {
+        if (alsa_mixer[ii] == '_')
+            alsa_mixer[ii] = ' ';
+    }
+
+    frame_size = pa_frame_size(&ss);
+
+    nfrags = m->core->default_n_fragments;
+    frag_size = pa_usec_to_bytes(m->core->default_fragment_size_msec*1000, &ss);
+    if (frag_size <= 0)
+        frag_size = frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "fragments", &nfrags) < 0 || pa_modargs_get_value_u32(ma, "fragment_size", &frag_size) < 0) {
+        pa_log("Failed to parse buffer metrics");
+        goto fail;
+    }
+    period_size = frag_size/frame_size;
+
+    alt_frame_size = pa_frame_size(&ss);
+
+    /* 0 is default value from pa_modargs_get */
+    alt_period_size = 0;
+    alt_nfrags = 0;
+    alt_frag_size = alt_frame_size;
+
+    if (alt_frag_size <= 0)
+        alt_frag_size = alt_frame_size;
+
+    if (pa_modargs_get_value_u32(ma, "alt_fragments", &alt_nfrags) < 0 || pa_modargs_get_value_u32(ma, "alt_fragment_size", &alt_frag_size) < 0) {
+        pa_log("Failed to parse buffer metrics");
+        goto fail;
+    }
+
+    if (alt_nfrags != 0)
+        alt_period_size = alt_frag_size/alt_frame_size;
+
+    if (pa_modargs_get_value_boolean(ma, "mmap", &use_mmap) < 0) {
+        pa_log("Failed to parse mmap argument.");
+        goto fail;
+    }
+
+    if (pa_modargs_get_value_boolean(ma, "ignore_dB", &ignore_dB) < 0) {
+        pa_log("Failed to parse ignore_dB argument.");
+        goto fail;
+    }
+
+    u = pa_xnew0(struct userdata, 1);
+    u->switch_mode = SOURCE_SWITCH_PRIMARY;
+    if (alt_nfrags != 0)
+        u->switching_enabled = TRUE;
+    else
+        u->switching_enabled = FALSE;
+    u->core = m->core;
+    u->module = m;
+    m->userdata = u;
+    u->use_mmap = use_mmap;
+    u->rtpoll = pa_rtpoll_new();
+    pa_thread_mq_init(&u->thread_mq, m->core->mainloop, u->rtpoll);
+    u->alsa_rtpoll_item = NULL;
+    u->initialized = FALSE;
+
+    /* save device_id & string for later initialization */
+    if (pa_modargs_get_value(ma, "device_id", NULL))
+        u->init_device_id = pa_xstrdup(pa_modargs_get_value(ma, "device_id", NULL));
+    u->init_device_string = pa_xstrdup(pa_modargs_get_value(ma, "device", DEFAULT_DEVICE));
+
+    /* device not initialized yet, but save something to device_name */
+    u->device_name = pa_sprintf_malloc("(uninitialized)");
+
+    if ((name = pa_modargs_get_value(ma, "source_name", NULL)))
+        namereg_fail = 1;
+    else {
+        name = name_buf = pa_sprintf_malloc("alsa_input.%s", u->device_name);
+        namereg_fail = 0;
+    }
+
+    pa_source_new_data_init(&data);
+    data.driver = __FILE__;
+    data.module = m;
+    pa_source_new_data_set_name(&data, name);
+    data.namereg_fail = namereg_fail;
+    pa_source_new_data_set_sample_spec(&data, &ss);
+    pa_source_new_data_set_channel_map(&data, &map);
+
+    u->source = pa_source_new(m->core, &data, PA_SOURCE_HARDWARE|PA_SOURCE_LATENCY);
+    pa_source_new_data_done(&data);
+    pa_xfree(name_buf);
+
+    if (!u->source) {
+        pa_log("Failed to create source object");
+        goto fail;
+    }
+
+    u->source->parent.process_msg = source_process_msg;
+    u->source->userdata = u;
+
+    pa_source_set_asyncmsgq(u->source, u->thread_mq.inq);
+    pa_source_set_rtpoll(u->source, u->rtpoll);
+
+    u->source->flags = PA_SOURCE_HARDWARE|PA_SOURCE_LATENCY;
+
+    u->frame_size = frame_size;
+    u->fragment_size = frag_size = period_size * frame_size;
+    u->nfragments = nfrags;
+    u->hwbuf_size = u->fragment_size * nfrags;
+    u->period_size = period_size;
+
+    if (u->switching_enabled) {
+        u->pri_frame_size = frame_size;
+        u->pri_fragment_size = frag_size = period_size * frame_size;
+        u->pri_nfragments = nfrags;
+        u->pri_hwbuf_size = u->fragment_size * nfrags;
+        u->pri_period_size = period_size;
+
+        u->alt_frame_size = alt_frame_size;
+        u->alt_fragment_size = alt_frag_size = alt_period_size * alt_frame_size;
+        u->alt_nfragments = alt_nfrags;
+        u->alt_hwbuf_size = u->alt_fragment_size * alt_nfrags;
+        u->alt_period_size = alt_period_size;
+    }
+
+    pa_log_info("PRI: Using %u fragments of size %lu bytes.", nfrags, (long unsigned) u->pri_fragment_size);
+    if (u->switching_enabled)
+        pa_log_info("ALT: Using %u fragments of size %lu bytes.", alt_nfrags, (long unsigned) u->alt_fragment_size);
+
+    if (!(u->thread = pa_thread_new(thread_func, u))) {
+        pa_log("Failed to create thread.");
+        goto fail;
+    }
 
     pa_proplist_sets(u->source->proplist, PROP_BUFFERS, PROP_BUFFERS_PRIMARY);
 
@@ -1319,7 +1377,9 @@ int pa__init(pa_module*m) {
                                                           (pa_hook_cb_t)source_proplist_changed_hook_callback, u);
 
     pa_source_put(u->source);
+    pa_source_suspend(u->source, TRUE);
 
+    u->init_alsa_mixer = pa_xstrdup(alsa_mixer);
     if (alsa_mixer)
         pa_xfree(alsa_mixer);
 
@@ -1378,6 +1438,13 @@ void pa__done(pa_module*m) {
         snd_pcm_close(u->pcm_handle);
     }
 
+    if (u->init_device_id)
+        pa_xfree(u->init_device_id);
+    if (u->init_device_string)
+        pa_xfree(u->init_device_string);
+    if (u->init_alsa_mixer)
+        pa_xfree(u->init_alsa_mixer);
+
     pa_xfree(u->device_name);
     pa_xfree(u);
 
-- 
1.6.3.1

